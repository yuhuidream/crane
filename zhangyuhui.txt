./.gitignore:4:*.sublime-project
./.gitignore:5:*.sublime-workspace
./.gitignore:6:*.sublime-toks
./.gitignore:20:*.vim
Binary file ./extlib/libmlucas_cr5.a matches
Binary file ./extlib/libqpc_cr5.a matches
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qs_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qs_port.h:46:* to be used with the other QP component, by simply including "qf_port.h"
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qep_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qf_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qf_port.h:43:* counter value of a time event may be much bigger
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qf_port.h:46:                 /* The maximum number of active objects in the application */
./extlib/inc/qpc/ports/arm-cortex/vanilla/gnu/qf_port.h:48:                    /* The maximum number of event pools in the application */
./extlib/inc/qpc/ports/arm-cortex/qk/gnu/qs_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/ports/arm-cortex/qk/gnu/qs_port.h:47:* simply including "qf_port.h" *before* "qs.h".
./extlib/inc/qpc/ports/arm-cortex/qk/gnu/qep_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/ports/arm-cortex/qk/gnu/qf_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/ports/arm-cortex/qk/gnu/qf_port.h:40:                 /* The maximum number of active objects in the application */
./extlib/inc/qpc/ports/arm-cortex/qk/gnu/qf_port.h:42:                    /* The maximum number of event pools in the application */
./extlib/inc/qpc/include/qevt.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qevt.h:50:* version of the QP as a decimal constant XYZ, where X is a 1-digit
./extlib/inc/qpc/include/qevt.h:90:    * If the macro is left undefined, the default definition simply returns
./extlib/inc/qpc/include/qevt.h:115:    * in UML is the specification of an asynchronous stimulus that triggers
./extlib/inc/qpc/include/qevt.h:218:/** \brief helper macro to calculate static dimension of a 1-dim \a array_ */
./extlib/inc/qpc/include/qs.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qs.h:84:* Currently, the maximum of all records cannot exceed 256.
./extlib/inc/qpc/include/qs.h:124:    QS_QF_TIMEEVT_ARM,                          /**< a time event was armed */
./extlib/inc/qpc/include/qs.h:125:    QS_QF_TIMEEVT_AUTO_DISARM,   /**< a time event expired and was disarmed */
./extlib/inc/qpc/include/qs.h:126:    QS_QF_TIMEEVT_DISARM_ATTEMPT,/**< attempt to disarm a disarmed QTimeEvt */
./extlib/inc/qpc/include/qs.h:127:    QS_QF_TIMEEVT_DISARM,        /**< true disarming of an armed time event */
./extlib/inc/qpc/include/qs.h:128:    QS_QF_TIMEEVT_REARM,                      /**< rearming of a time event */
./extlib/inc/qpc/include/qs.h:129:    QS_QF_TIMEEVT_POST,   /**< a time event posted itself directly to an AO */
./extlib/inc/qpc/include/qs.h:130:    QS_QF_TIMEEVT_CTR,              /**< a time event counter was requested */
./extlib/inc/qpc/include/qs.h:182:    /** \brief The size (in bytes) of the QS time stamp. Valid values: 1, 2,
./extlib/inc/qpc/include/qs.h:186:    * configure the ::QSTimeCtr type. Here the macro is not defined so the
./extlib/inc/qpc/include/qs.h:193:    typedef uint8_t QSTimeCtr;
./extlib/inc/qpc/include/qs.h:194:    #define QS_TIME_()          (QS_u8_(QS_onGetTime()))
./extlib/inc/qpc/include/qs.h:196:    typedef uint16_t QSTimeCtr;
./extlib/inc/qpc/include/qs.h:197:    #define QS_TIME_()          (QS_u16_(QS_onGetTime()))
./extlib/inc/qpc/include/qs.h:199:    /** \brief The type of the QS time stamp
./extlib/inc/qpc/include/qs.h:201:    * This type determines the dynamic range of QS time stamps
./extlib/inc/qpc/include/qs.h:203:    typedef uint32_t QSTimeCtr;
./extlib/inc/qpc/include/qs.h:204:    /** \brief Internal macro to output time stamp to a QS record
./extlib/inc/qpc/include/qs.h:206:    #define QS_TIME_()          (QS_u32_(QS_onGetTime()))
./extlib/inc/qpc/include/qs.h:418:* This function delivers one byte at a time from the QS data buffer.
./extlib/inc/qpc/include/qs.h:421:* available at the time, the function returns QS_EOD (End-Of-Data).
./extlib/inc/qpc/include/qs.h:437:* The argument \a pNbytes is also used as input to provide the maximum size of
./extlib/inc/qpc/include/qs.h:445:* is empty at the time of the call. The non-NULL return often means that
./extlib/inc/qpc/include/qs.h:455:/* platform-specific callback functions, need to be implemented by clients  */
./extlib/inc/qpc/include/qs.h:460:* #QS_INIT. You need to implement this function in your application.
./extlib/inc/qpc/include/qs.h:461:* At a minimum, the function must configure the QS buffer by calling
./extlib/inc/qpc/include/qs.h:469:* The following example illustrates an implementation of QS_onStartup():
./extlib/inc/qpc/include/qs.h:477:* #QS_EXIT. You need to implement this function in your application.
./extlib/inc/qpc/include/qs.h:492:/** \brief Callback to obtain a timestamp for a QS record.
./extlib/inc/qpc/include/qs.h:495:* #QS_TIME_ to add the time stamp to a QS record.
./extlib/inc/qpc/include/qs.h:497:* \note Some of the predefined QS records from QP do not output the time
./extlib/inc/qpc/include/qs.h:498:* stamp. However, ALL user records do output the time stamp.
./extlib/inc/qpc/include/qs.h:499:* \note QS_onGetTime() is called in a critical section and should not
./extlib/inc/qpc/include/qs.h:503: The following example shows using a system call to implement QS
./extlib/inc/qpc/include/qs.h:504:* time stamping:
./extlib/inc/qpc/include/qs.h:505:* \include qs_onGetTime.c
./extlib/inc/qpc/include/qs.h:507:QSTimeCtr QS_onGetTime(void);
./extlib/inc/qpc/include/qs.h:563:* \note Because active objects are state machines at the same time,
./extlib/inc/qpc/include/qs.h:631:/** \brief Local Filter for a given time event object \a obj_.
./extlib/inc/qpc/include/qs.h:633:* This macro sets up the time event object local filter if #Q_SPY is defined,
./extlib/inc/qpc/include/qs.h:635:* pointer to the time event object you want to monitor.
./extlib/inc/qpc/include/qs.h:637:* The time event filter allows you to filter QS records pertaining
./extlib/inc/qpc/include/qs.h:638:* only to a given time event. With this filter disabled, QS will
./extlib/inc/qpc/include/qs.h:639:* output records from all time events in your application. The object
./extlib/inc/qpc/include/qs.h:640:* filter is disabled by setting the time event pointer \a obj_ to NULL.
./extlib/inc/qpc/include/qs.h:642:* The time event filter affects the following QS records:
./extlib/inc/qpc/include/qs.h:660:* The local filter is disabled by setting the time event pointer \a obj_
./extlib/inc/qpc/include/qs.h:1136:* Providing a signal dictionary QS record can vastly improve readability of
./extlib/inc/qpc/include/qs.h:1184:* Providing an object dictionary QS record can vastly improve readability of
./extlib/inc/qpc/include/qs.h:1206:* Providing a function dictionary QS record can vastly improve readability of
./extlib/inc/qpc/include/qs.h:1305:    void const *teObjFilter;           /**<  time event for QF local filter */
./extlib/inc/qpc/include/qcompo_dyn.h:6: *  Every time we "new" a component, we test if there is any existing        *
./extlib/inc/qpc/include/qcompo_dyn.h:40: *  Second, implement two call back functions for new and free.              *
./extlib/inc/qpc/include/qf_ext.h:109:    * 1. Core a is stealed by Core b and Core c simultaneously
./extlib/inc/qpc/include/qf_ext.h:218:* This is a extended mechanism for BBU. In BBU, we sometimes have some very
./extlib/inc/qpc/include/qf_ext.h:219:* long tests which will last for a long time and even not terminate, such as
./extlib/inc/qpc/include/qf_ext.h:235:* in interrupt handler(QF_tick() of timer or IPC(SGI) handler).
./extlib/inc/qpc/include/qf_ext.h:248:/** \brief Check if a time event used for LRAB
./extlib/inc/qpc/include/qf_ext.h:250:int QTimeEvt_4LRAB(QTimeEvt *te);
./extlib/inc/qpc/include/qf_ext.h:258:/** \brief flag to indicate that a time event expires to break long RTC
./extlib/inc/qpc/include/qf_ext.h:267:* Current implement is based on QHsm, NOT QMsm, maybe need to re-implemented
./extlib/inc/qpc/include/qf_ext.h:498:* \a c, victim core which will be shut down
./extlib/inc/qpc/include/qf_ext.h:504:/** \brief This function is called by victim core, after this, this core will
./extlib/inc/qpc/include/qvanilla.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qspinlock.h:33:/* macros used to lock and unlock a QTimeEvt */
./extlib/inc/qpc/include/qspinlock.h:34:#define QTE_SPIN_LOCK(te_)    Q_spinLock(&(((QTimeEvt *)te_)->lock))
./extlib/inc/qpc/include/qspinlock.h:35:#define QTE_SPIN_UNLOCK(te_)  Q_spinUnlock(&(((QTimeEvt *)te_)->lock))
./extlib/inc/qpc/include/qspinlock.h:37:#define QTE_HEAD_SPIN_LOCK(rate_)   Q_spinLock(&(QF_timeEvtHead_[rate_].lock))
./extlib/inc/qpc/include/qspinlock.h:38:#define QTE_HEAD_SPIN_UNLOCK(rate_) Q_spinUnlock(&(QF_timeEvtHead_[rate_].lock))
./extlib/inc/qpc/include/qequeue.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qequeue.h:44:* event queue implementation. Also, this file is needed when the "raw"
./extlib/inc/qpc/include/qequeue.h:53:    * native QF event queue implementation. Valid values: 1, 2, or 4;
./extlib/inc/qpc/include/qequeue.h:67:    * The dynamic range of this data type determines the maximum length
./extlib/inc/qpc/include/qequeue.h:83:* the event queue for active objects, or as a simple "raw" event queue for
./extlib/inc/qpc/include/qequeue.h:95:* internal implementation uses the standard ring-buffer plus one external
./extlib/inc/qpc/include/qequeue.h:96:* location that optimizes the queue operation for the most frequent case
./extlib/inc/qpc/include/qequeue.h:107:* The other set of functions, uses this structure as a simple "raw" event
./extlib/inc/qpc/include/qequeue.h:127:    * When the queue is empty (which is most of the time), the extra
./extlib/inc/qpc/include/qequeue.h:129:    * greatly optimizing the performance of the queue. Only bursts of events
./extlib/inc/qpc/include/qequeue.h:158:    /** \brief minimum number of free events ever in the ring buffer.
./extlib/inc/qpc/include/qequeue.h:186:/** \brief "raw" thread-safe QF event queue implementation for the event
./extlib/inc/qpc/include/qequeue.h:190:* The argument \a margin specifies the minimum number of free entries
./extlib/inc/qpc/include/qequeue.h:207:/** \brief "raw" thread-safe QF event queue implementation for the
./extlib/inc/qpc/include/qequeue.h:221:/** \brief "raw" thread-safe QF event queue implementation for the
./extlib/inc/qpc/include/qa_susp.h:89:/** \brief AO set up a alarm(arm a ms time event) and go to sleep
./extlib/inc/qpc/include/qa_susp.h:91:* \a ms, time when the sleeping AO will be waked up
./extlib/inc/qpc/include/qa_susp.h:92:* \sa QTimeEvt_yell()
./extlib/inc/qpc/include/qa_susp.h:96:/** \brief When the time event which is armed by a sleeping AO expires, it
./extlib/inc/qpc/include/qa_susp.h:99:* \a te, pointer of time event
./extlib/inc/qpc/include/qa_susp.h:100:* \sa QA_mSleep(), QTimeEvt_isAlarm()
./extlib/inc/qpc/include/qa_susp.h:102:void QTimeEvt_yell(QTimeEvt *te);
./extlib/inc/qpc/include/qa_susp.h:104:/** \brief Check if this time evt is armed by a sleeping AO
./extlib/inc/qpc/include/qa_susp.h:106:* \a te, pointer of time event
./extlib/inc/qpc/include/qa_susp.h:107:* \sa QA_mSleep(), QTimeEvt_yell()
./extlib/inc/qpc/include/qa_susp.h:109:int QTimeEvt_isAlarm(QTimeEvt *te);
./extlib/inc/qpc/include/qa_susp.h:131:* \note This macro have several versions according to diffrent implements
./extlib/inc/qpc/include/qa_susp.h:248:#define QTimeEvt_isAlarm(te)             ((void)te, 0)
./extlib/inc/qpc/include/qa_susp.h:249:#define QTimeEvt_yell(te)                do{(void)te;}while(0)
./extlib/inc/qpc/include/qpset.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qpset.h:85:/** \brief find the maximum element in the set, and assign it to n_,
./extlib/inc/qpc/include/qpset.h:104:    /** \brief bimask representing 8-element subsets of the set
./extlib/inc/qpc/include/qpset.h:164:/** \brief find the maximum element in the set, and assign it to \a n_
./extlib/inc/qpc/include/qf_conf.h:26:/** \brief automatic switch of QTimeEvt trigger(timer irq)
./extlib/inc/qpc/include/qp_port.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qp_port.h:55:* begining of time", which is the maximum backwards compatibilty. This is
./extlib/inc/qpc/include/qp_port.h:114:/** \brief Deprecated time event constructor */
./extlib/inc/qpc/include/qp_port.h:115:#define QTimeEvt_ctor(me_, sig_) \
./extlib/inc/qpc/include/qp_port.h:116:    QTimeEvt_ctorX((me_), (QActive *)0, (sig_), (uint8_t)0)
./extlib/inc/qpc/include/qp_port.h:118:/** \brief Deprecated time event one-shot arm operation */
./extlib/inc/qpc/include/qp_port.h:119:#define QTimeEvt_postIn(me_, act_, nTicks_) do { \
./extlib/inc/qpc/include/qp_port.h:121:    QTimeEvt_armX((me_), (nTicks_), (uint8_t)0); \
./extlib/inc/qpc/include/qp_port.h:124:/** \brief Deprecated time event periodic arm operation */
./extlib/inc/qpc/include/qp_port.h:125:#define QTimeEvt_postEvery(me_, act_, nTicks_) do { \
./extlib/inc/qpc/include/qp_port.h:127:    QTimeEvt_armX((me_), (nTicks_), (nTicks_)); \
./extlib/inc/qpc/include/qs_dummy.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qep.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qep.h:94:* of the QM modeling tool, but are the fastest and need the least run-time
./extlib/inc/qpc/include/qep.h:99:* and requrie significantly more run-time code (0.5-1KB) to execute.
./extlib/inc/qpc/include/qep.h:164:* Processes one event at a time in Run-to-Completion fashion. The argument
./extlib/inc/qpc/include/qep.h:243:* QHsm_top() is the ultimate root of state hierarchy in all HSMs derived
./extlib/inc/qpc/include/qep.h:420:    Q_VTE_SIG,              /**< signal after which can be valid time event */
./extlib/inc/qpc/include/qassert.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qassert.h:201:/** Compile-time assertion exploits the fact that in C/C++ a dimension of
./extlib/inc/qpc/include/qassert.h:203:* error if the compile-time expression (\a test_) is not TRUE. The assertion
./extlib/inc/qpc/include/qassert.h:204:* has no runtime side effects.
./extlib/inc/qpc/include/qmpool.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qmpool.h:44:* memory pool implementation.
./extlib/inc/qpc/include/qmpool.h:59:    * The dynamic range of this data type determines the maximum size
./extlib/inc/qpc/include/qmpool.h:84:    * The dynamic range of this data type determines the maximum number
./extlib/inc/qpc/include/qmpool.h:123:    /**  maximum block size (in bytes)
./extlib/inc/qpc/include/qmpool.h:135:    /** minimum number of free blocks ever present in this pool
./extlib/inc/qpc/include/qk.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qk.h:141:    * minimum.
./extlib/inc/qpc/include/qk.h:151:    * minimum.
./extlib/inc/qpc/include/qa_stk.h:14:/** \brief The minimum stack size which is supported
./extlib/inc/qpc/include/qa_stk.h:35:* \note Simply compare the 16-Byte of the stack top with the signature
./extlib/inc/qpc/include/qf.h:23:* but WITHOUT ANY WARRANTY; without even the implied warranty of
./extlib/inc/qpc/include/qf.h:65:    * The dynamic range of this data type determines the maximum block
./extlib/inc/qpc/include/qf.h:88:    /** \brief macro to override the default QTimeEvtCtr size.
./extlib/inc/qpc/include/qf.h:125:    * a native event queue implementation that can be used as well.
./extlib/inc/qpc/include/qf.h:168:    /** \brief Used as timer event pointer for long RTC auto break
./extlib/inc/qpc/include/qf.h:271:    * The argument \a margin specifies the minimum number of free slots in
./extlib/inc/qpc/include/qf.h:282:    * Direct event posting is the simplest asynchronous communication method
./extlib/inc/qpc/include/qf.h:324:    * minimum free slots in the queue, which must still be available
./extlib/inc/qpc/include/qf.h:464:* time events, can be still delivered to the event queue of the active
./extlib/inc/qpc/include/qf.h:479:* time from the event queue.
./extlib/inc/qpc/include/qf.h:531:* queue implementation and is sometimes implemented in the QF port
./extlib/inc/qpc/include/qf.h:539:/* friend class QTimeEvt; */
./extlib/inc/qpc/include/qf.h:546:* require the use of QM, but are the fastest and need the least run-time
./extlib/inc/qpc/include/qf.h:568:    typedef uint8_t QTimeEvtCtr;
./extlib/inc/qpc/include/qf.h:571:    /** \brief type of the Time Event counter, which determines the dynamic
./extlib/inc/qpc/include/qf.h:572:    * range of the time delays measured in clock ticks.
./extlib/inc/qpc/include/qf.h:580:    typedef uint16_t QTimeEvtCtr;
./extlib/inc/qpc/include/qf.h:582:    typedef uint32_t QTimeEvtCtr;
./extlib/inc/qpc/include/qf.h:587:/** \brief Time Event structure
./extlib/inc/qpc/include/qf.h:589:* Time events are special QF events equipped with the notion of time passage.
./extlib/inc/qpc/include/qf.h:590:* The basic usage model of the time events is as follows. An active object
./extlib/inc/qpc/include/qf.h:591:* allocates one or more QTimeEvt objects (provides the storage for them).
./extlib/inc/qpc/include/qf.h:592:* When the active object needs to arrange for a timeout, it arms one of its
./extlib/inc/qpc/include/qf.h:593:* time events to fire either just once (one-shot) or periodically. Each time
./extlib/inc/qpc/include/qf.h:594:* event times out independently from the others, so a QF application can make
./extlib/inc/qpc/include/qf.h:595:* multiple parallel timeout requests (from the same or different active
./extlib/inc/qpc/include/qf.h:597:* inserts the time event directly into the recipient's event queue. The
./extlib/inc/qpc/include/qf.h:598:* recipient then processes the time event just like any other event.
./extlib/inc/qpc/include/qf.h:600:* Time events, as any other QF events derive from the ::QEvt base structure.
./extlib/inc/qpc/include/qf.h:601:* Typically, you will use a time event as-is, but you can also further
./extlib/inc/qpc/include/qf.h:602:* derive more specialized time events from it by adding some more data
./extlib/inc/qpc/include/qf.h:604:* time events.
./extlib/inc/qpc/include/qf.h:606:* Internally, the armed time events are organized into linked lists--one list
./extlib/inc/qpc/include/qf.h:608:* invocation of the QF_tickX_() function. Only armed (timing out) time events
./extlib/inc/qpc/include/qf.h:609:* are in the list, so only armed time events consume CPU cycles.
./extlib/inc/qpc/include/qf.h:611:* \sa ::QTimeEvtTag for the description of the data members \n \ref derivation
./extlib/inc/qpc/include/qf.h:613:* \note QF manages the time events in the function QF_tickX_(), which
./extlib/inc/qpc/include/qf.h:616:* \note In this version of QF QTimeEvt objects should be allocated statically
./extlib/inc/qpc/include/qf.h:618:* recycle the dynamically allocated Time Events.
./extlib/inc/qpc/include/qf.h:620:typedef struct QTimeEvtTag {
./extlib/inc/qpc/include/qf.h:621:    /** base structure from which QTimeEvt derives
./extlib/inc/qpc/include/qf.h:626:    /** link to the next time event in the list */
./extlib/inc/qpc/include/qf.h:627:    struct QTimeEvtTag * volatile next;
./extlib/inc/qpc/include/qf.h:629:    /** the active object that receives the time events */
./extlib/inc/qpc/include/qf.h:632:    /** the internal down-counter of the time event. The down-counter
./extlib/inc/qpc/include/qf.h:633:    * is decremented by 1 in every QF_tickX_() invocation. The time event
./extlib/inc/qpc/include/qf.h:636:    QTimeEvtCtr volatile ctr;
./extlib/inc/qpc/include/qf.h:638:    /** the interval for the periodic time event (zero for the one-shot
./extlib/inc/qpc/include/qf.h:639:    * time event). The value of the interval is re-loaded to the internal
./extlib/inc/qpc/include/qf.h:640:    * down-counter when the time event expires, so that the time event
./extlib/inc/qpc/include/qf.h:641:    * keeps timing out periodically.
./extlib/inc/qpc/include/qf.h:643:    QTimeEvtCtr interval;
./extlib/inc/qpc/include/qf.h:649:} QTimeEvt;
./extlib/inc/qpc/include/qf.h:653:/** \brief The extended "constructor" to initialize a Time Event.
./extlib/inc/qpc/include/qf.h:655:* When creating a time event, you must commit it to a specific active object
./extlib/inc/qpc/include/qf.h:659:* \note You should call this function exactly once for every Time Event object
./extlib/inc/qpc/include/qf.h:660:* BEFORE arming the Time Event.
./extlib/inc/qpc/include/qf.h:662:void QTimeEvt_ctorX(QTimeEvt * const me, QActive * const act,
./extlib/inc/qpc/include/qf.h:665:/** \brief Arm a time event (one shot or periodic) for direct event posting.
./extlib/inc/qpc/include/qf.h:667:* Arms a time event \a me_ to fire in \a nTicks_ with an interval of
./extlib/inc/qpc/include/qf.h:668:* \a interval. If \a interval is zero, the time event is armed for one shot.
./extlib/inc/qpc/include/qf.h:669:* The time event gets directly posted (using the FIFO policy) into the event
./extlib/inc/qpc/include/qf.h:672:* After posting, a one-shot time event gets automatically disarmed while
./extlib/inc/qpc/include/qf.h:673:* a periodic time event (interval != 0) is automatically re-armed.
./extlib/inc/qpc/include/qf.h:675:* A time event can be disarmed at any time by calling the QTimeEvt_disarm()
./extlib/inc/qpc/include/qf.h:676:* operation. Also, a time event can be re-armed to fire in a different
./extlib/inc/qpc/include/qf.h:677:* number of clock ticks by calling the QTimeEvt_rearm() function.
./extlib/inc/qpc/include/qf.h:679:* \note An attempt to reuse (arm again) a running time event raises an
./extlib/inc/qpc/include/qf.h:682:* The following example shows how to arm a one-shot time event from a state
./extlib/inc/qpc/include/qf.h:686:void QTimeEvt_armX(QTimeEvt * const me,
./extlib/inc/qpc/include/qf.h:687:                   QTimeEvtCtr const nTicks, QTimeEvtCtr const interval);
./extlib/inc/qpc/include/qf.h:689:/** \brief Rearm a time event.
./extlib/inc/qpc/include/qf.h:691:* The time event \a me gets rearmed with a new number of clock ticks
./extlib/inc/qpc/include/qf.h:693:* periodic time event or to prevent a one-shot time event from expiring
./extlib/inc/qpc/include/qf.h:694:* (e.g., a watchdog time event). Rearming a periodic timer leaves the
./extlib/inc/qpc/include/qf.h:696:* a periodic time event.
./extlib/inc/qpc/include/qf.h:698:* The function returns 1 (TRUE) if the time event was running as it
./extlib/inc/qpc/include/qf.h:699:* was re-armed. The return of 0 (FALSE) means that the time event was
./extlib/inc/qpc/include/qf.h:701:* possible for one-shot time events that have been automatically disarmed
./extlib/inc/qpc/include/qf.h:702:* upon expiration. In this case the FALSE return means that the time event
./extlib/inc/qpc/include/qf.h:706:uint8_t QTimeEvt_rearm(QTimeEvt * const me, QTimeEvtCtr const nTicks);
./extlib/inc/qpc/include/qf.h:708:/** \brief Disarm a time event.
./extlib/inc/qpc/include/qf.h:710:* The time event \a me gets disarmed and can be reused. The function
./extlib/inc/qpc/include/qf.h:711:* returns 1 (TRUE) if the time event was truly disarmed, that is, it
./extlib/inc/qpc/include/qf.h:712:* was running. The return of 0 (FALSE) means that the time event was
./extlib/inc/qpc/include/qf.h:714:* possible for one-shot time events that have been automatically disarmed
./extlib/inc/qpc/include/qf.h:715:* upon expiration. In this case the FALSE return means that the time event
./extlib/inc/qpc/include/qf.h:719:uint8_t QTimeEvt_disarm(QTimeEvt * const me);
./extlib/inc/qpc/include/qf.h:721:/** \brief Get the current value of the down-counter of a time event.
./extlib/inc/qpc/include/qf.h:723:* If the time event is armed, the function returns the current value of
./extlib/inc/qpc/include/qf.h:724:* the down-counter of the given time event. If the time event is not
./extlib/inc/qpc/include/qf.h:729:QTimeEvtCtr QTimeEvt_ctr(QTimeEvt const * const me);
./extlib/inc/qpc/include/qf.h:735:/** \brief Timer structure, used for on-demand-tick
./extlib/inc/qpc/include/qf.h:737:typedef struct QTimerTag{
./extlib/inc/qpc/include/qf.h:738:    /** function to start a physical timer
./extlib/inc/qpc/include/qf.h:742:    /** function to stop a physical timer
./extlib/inc/qpc/include/qf.h:746:    /** function to get the left interval before the timer alarm expires
./extlib/inc/qpc/include/qf.h:754:    /** the maximal interval that the timer supports
./extlib/inc/qpc/include/qf.h:758:}QTimer;
./extlib/inc/qpc/include/qf.h:760:/** \brief Register a physical timer to QP for different tickRates
./extlib/inc/qpc/include/qf.h:762:void QTimer_register(void (*start)(void),
./extlib/inc/qpc/include/qf.h:788:    * The size of the array is determined of the maximum number of active
./extlib/inc/qpc/include/qf.h:818:* to the array of subscriber-lists. \a maxSignal is the dimension of this
./extlib/inc/qpc/include/qf.h:819:* array and at the same time the maximum signal that can be published or
./extlib/inc/qpc/include/qf.h:841:* This function initializes one event pool at a time and must be called
./extlib/inc/qpc/include/qf.h:846:* the maximum size of events that can be allocated from the pool.
./extlib/inc/qpc/include/qf.h:850:* for the simplicity of the internal implementation, you must initialize
./extlib/inc/qpc/include/qf.h:855:* a native QF event pool implementation. The macro #QF_EPOOL_TYPE_ determines
./extlib/inc/qpc/include/qf.h:882:* \note This function is strongly platform-dependent and is not implemented
./extlib/inc/qpc/include/qf.h:884:* for the given application. All QF ports must implement QF_run().
./extlib/inc/qpc/include/qf.h:886:* \note When the Quantum Kernel (QK) is used as the underlying real-time
./extlib/inc/qpc/include/qf.h:890:* you don't need to provide any platform-specific implementation (so, no
./extlib/inc/qpc/include/qf.h:891:* qf_port.c file is necessary). Moreover, QK implements the function QF_run()
./extlib/inc/qpc/include/qf.h:901:* might take some time to complete. The typical use of this function is
./extlib/inc/qpc/include/qf.h:906:* This function is strongly platform-specific and is not implemented in
./extlib/inc/qpc/include/qf.h:908:* for the given application. Some QF ports might not require implementing
./extlib/inc/qpc/include/qf.h:918:* The timeline for calling QF_onStartup() depends on the particular
./extlib/inc/qpc/include/qf.h:929:* This function is strongly platform-specific and is not implemented in
./extlib/inc/qpc/include/qf.h:931:* for the given application. Some QF ports might not require implementing
./extlib/inc/qpc/include/qf.h:948:* condition can be asynchronously changed at any time by an interrupt.
./extlib/inc/qpc/include/qf.h:1012:    /** \brief Processes all armed time events at every clock tick.
./extlib/inc/qpc/include/qf.h:1014:    * This function must be called periodically from a time-tick ISR or from
./extlib/inc/qpc/include/qf.h:1015:    * the highest-priority task so that QF can manage the timeout events.
./extlib/inc/qpc/include/qf.h:1024:    * \sa ::QTimeEvt.
./extlib/inc/qpc/include/qf.h:1043:    * identify the ISR as the sender of the time events.
./extlib/inc/qpc/include/qf.h:1062:/** \brief Returns true (1) if all time events at a given tick rate
./extlib/inc/qpc/include/qf.h:1063:* \a tickRate are inactive and false (0) any time event is active.
./extlib/inc/qpc/include/qf.h:1067:uint8_t QF_noTimeEvtsActiveX(uint8_t const tickRate);
./extlib/inc/qpc/include/qf.h:1076:* object exceeds the maximum value #QF_MAX_ACTIVE. Also, this function
./extlib/inc/qpc/include/qf.h:1092:* object exceeds the maximum value #QF_MAX_ACTIVE or is not used.
./extlib/inc/qpc/include/qf.h:1096:/** \brief This function returns the minimum of free entries of the given
./extlib/inc/qpc/include/qf.h:1099:* This function returns the minimum number of free blocks in the given
./extlib/inc/qpc/include/qf.h:1104:* \note Requesting the minimum of an uninitialized pool raises an assertion
./extlib/inc/qpc/include/qf.h:1109:/** \brief This function returns the minimum of free entries of
./extlib/inc/qpc/include/qf.h:1112:* This function returns the minimum of free ever present in the given event
./extlib/inc/qpc/include/qf.h:1117:* queue implementation is used. Requesting the queue minimum of an unused
./extlib/inc/qpc/include/qf.h:1123:/** \brief Internal QF implementation of the dynamic event allocator.
./extlib/inc/qpc/include/qf.h:1127:* impossible due to event pool depletion, or incorrect (too big) size
./extlib/inc/qpc/include/qf.h:1182:* This function implements a simple garbage collector for the dynamic events.
./extlib/inc/qpc/include/qf.h:1219:    * The #QF_CRIT_EXIT_NOP() macro contains minimal code required to
./extlib/inc/qpc/include/qf.h:1254:    * of a byte. This macro can be re-implemented in the QP ports, if the CPU
./extlib/inc/qpc/include/qf.h:1257:    * If the macro is not defined in the port, the default implementation
./mk/footer.mk:58:# dist_clean is optimized in skel.mk if we are building in out of project tree
./mk/Readme.txt:11:# deal in the Software without restriction, including without limitation the   #
./mk/Readme.txt:35:This is my attempt to implement a non-recursive make build system.  For
./mk/Readme.txt:40:will be a blend of nice ideas I have seen plus some improvements.  If
./mk/Readme.txt:42:it perform well, do you have any suggestions for the improvements ...
./mk/Readme.txt:43:and so on.  This implementation is based on GNU make and its new
./mk/Readme.txt:125:targets (in contrary to other implementation which usually require
./mk/Readme.txt:126:you to run it at the top level and make full build each time).
./mk/Readme.txt:128:This build system was designed to have very simple structure of the
./mk/Readme.txt:167:2. The targets are simply objects - or in more general files that
./mk/Readme.txt:188:simply say in Rules.mk:
./mk/Readme.txt:192:If you have directory with large number of files where simple glob is
./mk/Readme.txt:332:   several subdirectories in one directory) then simple 'make' in this
./mk/Readme.txt:347:simple to use - go ahead and take a look again at these Rules.mk in
./mk/Readme.txt:348:various directories.  Setting up you project should be simple by now :).
./mk/Readme.txt:358:[2] There is one limitation that you should be aware.
./mk/Readme.txt:382:simply expanded variables - not recursive). If you have such need I'd
./mk/Readme.txt:396:'immediate' and 'deferred' in section 'Reading Makefiles' of make
./mk/Readme.txt:397:manual).  This implies that the $(d) variable is not valid during
./mk/Readme.txt:430:save_vars: This one is very simple it just saves the target specific
./mk/Readme.txt:441:	allow you to do that just make simple shell script that will do
./mk/Readme.txt:466:expanded and so on.  It will save you a lot of time :).
./mk/def_rules.mk:15:# Sometimes you have a code that you're not in charge of and which gives
./mk/def_rules.mk:53:# into the file with .E appended - sometimes this can be handy.
./mk/def_rules.mk:99:# The syntax for AUTO_TD_RULES is similar to AUTO_RULES but instead of
./mk/user_rules.mk:8:# we only support .S, not .s. which will go to gcc other than as, gcc support many syntax of C-similar in .S file    
./mk/skel.mk:23:# you can say simply
./mk/skel.mk:75:# good enough for me.  You can improve this by using a special script
./mk/skel.mk:89:# since LDLIBS is a variable that implicit make rules are using).
./mk/skel.mk:90:# LDLIBS can be either simple or recursive, but simpler version is
./mk/skel.mk:219:#How to work around the limitation of shell (Linux is 2M, Win is 32k)
./bbuinfo.h:1:#define btime "2018-04-03:10:39:12"
./.arcconfig:7:  "history.immutable": false,
./driver/dma/dma.c:394:		bbu_printf("DMA: transfer data timeout!\r\n");
./driver/dma/dma.c:437:		bbu_printf("DMA: transfer data timeout!\r\n");
./driver/dma/dma.c:767:int dma_wait_done(uint32_t channel, uint32_t timeout, uint32_t flags){
./driver/dma/dma.c:775:	count += (uint64_t)timeout;
./driver/dma/dma_dec.h:6:#include "timer_dec.h"
./driver/dma/dma_dec.h:172:int dma_wait_done(uint32_t channel, uint32_t timeout, uint32_t flags);
Binary file ./driver/dma/obj/arm/squ_dma.o matches
./driver/dma/obj/arm/dma.d:27: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/dma/obj/arm/dma.d:37: /home/feature_phone/crane/driver/timer/clock.h \
./driver/dma/obj/arm/dma.d:40: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/dma/obj/arm/dma.o matches
Binary file ./driver/uart/obj/arm/uart.o matches
./driver/uart/obj/arm/uart.d:39: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/uart/obj/arm/uart.d:42: /home/feature_phone/crane/driver/timer/clock.h \
./driver/uart/uart.c:16:#include "timer_dec.h"
./driver/uart/uart.c:47:    //the Rx timeout interrupt indicates there are trailing bytes, need to follow the steps in manual
./driver/uart/uart.c:54:    if ((uart_iir & IIR_IID10_MSK)==SHIFT1(0x2)) {//If Rx FIFO/timeout interrupt 
./driver/uart/uart.c:56:        if (uart_iir & IIR_TOD) { //timeout interrupt
./driver/uart/uart.c:57:            //step2: disable the Rx timeout interrupt
./driver/uart/uart.c:138:            //step5: no more data in FIFO,re-enable Receive Timeout
./driver/uart/uart.c:253:      This guarantees internal timings/coherency. 
./driver/uart/uart.c:280:    /* Receiver Data Available and timeout Interrupt Enable */  
./driver/pmic/ustica.h:156:* Function     :    ustica_get_start_ramp_time_setting
./driver/pmic/ustica.h:160:                    start ramping time
./driver/pmic/ustica.h:161:* Parameters   :    ramp_time: 112 ~ 14336us
./driver/pmic/ustica.h:166:uint8_t ustica_get_start_ramp_time_setting(int ramp_time);
./driver/pmic/obj/arm/dummy.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmic/obj/arm/dummy.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./driver/pmic/obj/arm/procida.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmic/obj/arm/procida.d:36: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/pmic/obj/arm/procida.o matches
Binary file ./driver/pmic/obj/arm/pm8xx_lib.o matches
./driver/pmic/obj/arm/pmic.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmic/obj/arm/pmic.d:36: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/pmic/obj/arm/pmic.o matches
Binary file ./driver/pmic/obj/arm/dummy.o matches
Binary file ./driver/pmic/obj/arm/ustica.o matches
./driver/pmic/obj/arm/ustica.d:30: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmic/obj/arm/ustica.d:39: /home/feature_phone/crane/driver/timer/clock.h \
./driver/pmic/obj/arm/pm8xx_lib.d:31: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmic/obj/arm/pm8xx_lib.d:40: /home/feature_phone/crane/driver/timer/clock.h \
./driver/pmic/pmic.h:6:#include "timer_dec.h"
./driver/pmic/ustica.c:4:#include "timer_dec.h"
./driver/pmic/ustica.c:633:* Function     :    ustica_get_start_ramp_time_setting
./driver/pmic/ustica.c:637:                    start ramping time
./driver/pmic/ustica.c:638:* Parameters   :    ramp_time: 112 ~ 14336us
./driver/pmic/ustica.c:643:uint8_t ustica_get_start_ramp_time_setting(int ramp_time)
./driver/pmic/ustica.c:647:      if(ramp_time < 112 || ramp_time > 14336)
./driver/pmic/ustica.c:649:      if(ramp_time >= 112 && ramp_time < 224)          setting = 0x0;
./driver/pmic/ustica.c:650:      else if(ramp_time >= 224 && ramp_time < 448)     setting = 0x1;
./driver/pmic/ustica.c:651:      else if(ramp_time >= 448 && ramp_time < 896)     setting = 0x2;
./driver/pmic/ustica.c:652:      else if(ramp_time >= 896 && ramp_time < 1792)    setting = 0x3;
./driver/pmic/ustica.c:653:      else if(ramp_time >= 1792 && ramp_time < 3584)   setting = 0x4;
./driver/pmic/ustica.c:654:      else if(ramp_time >= 3584 && ramp_time < 7168)   setting = 0x5;
./driver/pmic/ustica.c:655:      else if(ramp_time >= 7168 && ramp_time < 14336)  setting = 0x6;
./driver/pmic/ustica.c:656:      else if(ramp_time >= 14336)                      setting = 0x7;
./driver/pmic/ustica.c:657:      else bbu_printf("Procida: the ramp time is out of range\n\r");
./driver/pmic/ustica.c:942:void ustica_onkey_enable(int onkey_index, int press_time)
./driver/pmic/ustica.c:952:	bbu_printf("press time %d s\n\r",press_time);
./driver/pmic/ustica.c:954:	reg |= (((press_time -1) << 4));
./driver/pmic/ustica.c:1032:    //Increase the current limit of Buck1, otherwise PMIC can't survive mlucas+GC MMO6 stress.
./driver/pmic/ustica.c:1050:    //According to PMIC datasheet chapter 5.2 table 24: the 32k XO Tstart = 1s typical and 10s maximum.
./driver/pmic/procida.c:5:#include "timer_dec.h"
./driver/pmic/procida.c:728:* Function     :    procida_get_start_ramp_time_setting
./driver/pmic/procida.c:732:                    start ramping time
./driver/pmic/procida.c:733:* Parameters   :    ramp_time: 112 ~ 14336us
./driver/pmic/procida.c:738:uint8_t procida_get_start_ramp_time_setting(int ramp_time)
./driver/pmic/procida.c:742:      if(ramp_time < 112 || ramp_time > 14336)
./driver/pmic/procida.c:744:      if(ramp_time >= 112 && ramp_time < 224)          setting = 0x0;
./driver/pmic/procida.c:745:      else if(ramp_time >= 224 && ramp_time < 448)     setting = 0x1;
./driver/pmic/procida.c:746:      else if(ramp_time >= 448 && ramp_time < 896)     setting = 0x2;
./driver/pmic/procida.c:747:      else if(ramp_time >= 896 && ramp_time < 1792)    setting = 0x3;
./driver/pmic/procida.c:748:      else if(ramp_time >= 1792 && ramp_time < 3584)   setting = 0x4;
./driver/pmic/procida.c:749:      else if(ramp_time >= 3584 && ramp_time < 7168)   setting = 0x5;
./driver/pmic/procida.c:750:      else if(ramp_time >= 7168 && ramp_time < 14336)  setting = 0x6;
./driver/pmic/procida.c:751:      else if(ramp_time >= 14336)                      setting = 0x7;
./driver/pmic/procida.c:752:      else bbu_printf("Procida: the ramp time is out of range\n\r");
./driver/pmic/procida.c:1102:    	//Increase the current limit of Buck1, otherwise PMIC can't survive mlucas+GC MMO6 stress.
./driver/pmic/procida.c:1120:    	//According to PMIC datasheet chapter 5.2 table 24: the 32k XO Tstart = 1s typical and 10s maximum.
./driver/pmic/procida.h:183:* Function     :    procida_get_start_ramp_time_setting
./driver/pmic/procida.h:187:                    start ramping time
./driver/pmic/procida.h:188:* Parameters   :    ramp_time: 112 ~ 14336us
./driver/pmic/procida.h:193:uint8_t procida_get_start_ramp_time_setting(int ramp_time);
./driver/pmu/ppset_cr5.c:10:#include "timer_dec.h"
./driver/pmu/ppset_cr5.c:19:Which means AP only has real time value of c_aop,  need to update/get the c_cop, c_axiop value when CP not changing them.
./driver/pmu/ppset_cr5.c:677:     The time gap between the write response of FCCR and the exact update of FCCR is more than six 26MHz cycles.
./driver/pmu/ppset_cr5.c:683:    //BIT1 is set at T after all BIT3|BIT4|BIT5 is set. T is PMU internal mataince time after FC is done.
./driver/pmu/ppset_cr5.c:697:    //+++Step11(opt):calibrate the system tick count according to new PP if the CPU local timers are used.
./driver/pmu/ppset_cr5.c:976:    //Increase the current limit of Buck1, otherwise PMIC can't survive mlucas+GC MMO6 stress.
./driver/pmu/ppset_cr5.c:996:    //According to PMIC datasheet chapter 5.2 table 24: the 32k XO Tstart = 1s typical and 10s maximum.
./driver/pmu/ppset_cr5.c:1044:/*BIT_25: let AXI clock does not trigger core clock at the same time.
./driver/pmu/ppset_cr5.c:1113: /*Note: we direclty do the CS change to PP0 for simple*/
./driver/pmu/ppset_cr5.c:1335:/*Must make sure there is only one entity of this function is in executing at any time,
./driver/pmu/ppset_cr5.c:1418:    //This bit and the FC request bits should have already been cleared by hardware at this time,
./driver/pmu/ppset_cr5.c:1432:/*Must make sure there is only one entity of this function is in executing at any time,
./driver/pmu/ppset_cr5.c:1512:    //This bit and the FC request bits should have already been cleared by hardware at this time,
./driver/pmu/ppset_cr5.c:1525:/*Must make sure there is only one entity of this function is in executing at any time,
./driver/pmu/ppset_cr5.c:1532:    c_axiop = axiop_get_dump(&temp); //we support both AP, CP to change aclk, so need get c_axiop in real time
./driver/pmu/ppset_cr5.c:1560:    //This bit and the FC request bits should have already been cleared by hardware at this time,
./driver/pmu/ppset_cr5.c:1572:/*Must make sure there is only one entity of this function is in executing at any time,
./driver/pmu/ppset_cr5.c:1626:  if test_mode > PP_NUM, we have some special test modes, test_count limits the PP change count number*/
./driver/pmu/msa_tests.c:20:	int time_out = 0x1000000;
./driver/pmu/msa_tests.c:64:		time_out --;
./driver/pmu/msa_tests.c:65:		if(time_out == 0)
./driver/pmu/msa_tests.c:78:	int time_out = 0xFFFFFFFF;
./driver/pmu/msa_tests.c:88:		time_out --;
./driver/pmu/msa_tests.c:89:		if(time_out == 0)
./driver/pmu/msa_tests.c:91:			serial_outstr("MSA MPHY test timeout\n\r");
./driver/pmu/msa_tests.c:102:	int time_out = 0xFFFFFFFF;
./driver/pmu/msa_tests.c:116:		time_out --;
./driver/pmu/msa_tests.c:117:		if(time_out == 0)
./driver/pmu/msa_tests.c:119:			bbu_printf("MSA test timeout\n\r");
./driver/pmu/msa_tests.c:165:			bbu_printf("Read AP timer count\n\r");
./driver/pmu/reset.c:4:#include "timer_dec.h"
./driver/pmu/reset.c:22:void pmic_rtc_wake_pmic(int timeout_sec)
./driver/pmu/reset.c:41:		rtc_val += timeout_sec;	//4 seconds to expire
./driver/pmu/reset.c:61:void pmic_watchdog_timer_reset(void)
./driver/pmu/reset.c:81:	//set timer, 8s.
./driver/pmu/pmu_dec.h:129:void set_wake_src(e_wake_src wake_src, uint32_t time_sec);
./driver/pmu/pmu_dec.h:151:#define  ddr_idle_time  (*(volatile unsigned int *)(SQU_END-0x2C))
./driver/pmu/pmu_dec.h:186:#define CPU_DATA_SIZE   0x1000   //FIXME: this size may need to be optimized
./driver/pmu/wakeup_cr5.c:8:#include "timer_dec.h"
./driver/pmu/wakeup_cr5.c:28:static void sd_wk_set(uint32_t time_sec) {
./driver/pmu/wakeup_cr5.c:30:    (void)time_sec;
./driver/pmu/wakeup_cr5.c:98:    //ustica_base_write(0xE4, (reg&0xF3)|0x8); //set the debouce timer as 8ms
./driver/pmu/wakeup_cr5.c:106:static void pmic_wk_set(uint32_t time_sec) {
./driver/pmu/wakeup_cr5.c:107:    (void)time_sec;
./driver/pmu/wakeup_cr5.c:125:static void kp_wk_set(uint32_t time_sec)
./driver/pmu/wakeup_cr5.c:127:    (void)time_sec;
./driver/pmu/wakeup_cr5.c:139:#ifdef CONFIG_SMP //temp solution to wake up all cores at the same time for test
./driver/pmu/wakeup_cr5.c:187:static void pad_edge_wk_set(uint32_t time_sec)
./driver/pmu/wakeup_cr5.c:189:    (void)time_sec;
./driver/pmu/wakeup_cr5.c:213:#ifdef CONFIG_SMP //temp solution to wake up all cores at the same time for PE test
./driver/pmu/wakeup_cr5.c:222:static void timer_irq(void)
./driver/pmu/wakeup_cr5.c:224:   bbu_printf("Waked up by 32K timer\n\r");
./driver/pmu/wakeup_cr5.c:227:static void rtc_wk_set(uint32_t time_msec)
./driver/pmu/wakeup_cr5.c:234:     bbu_printf("%d msec %s alarm is set as wakeup source\r\n", time_msec,(time_msec<1000)?"Timer":"RTC");
./driver/pmu/wakeup_cr5.c:237:     if(time_msec < 1000){
./driver/pmu/wakeup_cr5.c:238:        if(time_msec < 50)
./driver/pmu/wakeup_cr5.c:239:            time_msec = 50;
./driver/pmu/wakeup_cr5.c:240:        int_id = start_timer_wakeup(time_msec, timer_irq);
./driver/pmu/wakeup_cr5.c:248:#ifdef CONFIG_SMP //temp solution to wake up all cores at the same time for PE
./driver/pmu/wakeup_cr5.c:255:static void squ_wk_set(uint32_t time_sec)
./driver/pmu/wakeup_cr5.c:257:    (void)time_sec;
./driver/pmu/wakeup_cr5.c:294:static void msa_unvote_wk_set(uint32_t time_sec)
./driver/pmu/wakeup_cr5.c:297:       ddr_idle_time = time_sec;
./driver/pmu/wakeup_cr5.c:317:static void usb3_wk_set(uint32_t time_sec)
./driver/pmu/wakeup_cr5.c:327:#ifdef CONFIG_SMP //temp solution to wake up all cores at the same time for PE
./driver/pmu/wakeup_cr5.c:342:void set_wake_src(e_wake_src wake_src, uint32_t time_sec) {
./driver/pmu/wakeup_cr5.c:351:        //kp_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:358:        pad_edge_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:365:        rtc_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:369:        sd_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:373:        pmic_wk_set(time_sec); //use time_sec to identify the PMIC sub-sources
./driver/pmu/wakeup_cr5.c:377:        squ_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:381:        msa_unvote_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:387:	  //usb_wk_set(time_sec,wake_src);
./driver/pmu/wakeup_cr5.c:390:        usb3_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:393:        //kp_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:394:        //rtc_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:395:        sd_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:396:        pmic_wk_set(time_sec);
./driver/pmu/wakeup_cr5.c:397:        //squ_wk_set(time_sec);
./driver/pmu/cr5_idle.c:21:/*TODO:Also need to save/restore the CPU local timers, global timer, SOC timer(A0 version) if used*/
Binary file ./driver/pmu/obj/arm/msa.o matches
Binary file ./driver/pmu/obj/arm/wakeup_cr5.o matches
Binary file ./driver/pmu/obj/arm/reset.o matches
Binary file ./driver/pmu/obj/arm/ppset_cr5.o matches
Binary file ./driver/pmu/obj/arm/cr5_idle.o matches
./driver/pmu/obj/arm/reset.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmu/obj/arm/reset.d:37: /home/feature_phone/crane/driver/timer/clock.h \
./driver/pmu/obj/arm/lpm_cr5.d:36: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmu/obj/arm/lpm_cr5.d:39: /home/feature_phone/crane/driver/timer/clock.h \
./driver/pmu/obj/arm/wakeup_cr5.d:34: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmu/obj/arm/wakeup_cr5.d:37: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/pmu/obj/arm/lpm_cr5.o matches
Binary file ./driver/pmu/obj/arm/msa_tests.o matches
./driver/pmu/obj/arm/pwr_init.d:42: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmu/obj/arm/pwr_init.d:45: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/pmu/obj/arm/pwr_init.o matches
./driver/pmu/obj/arm/ppset_cr5.d:38: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/pmu/obj/arm/ppset_cr5.d:41: /home/feature_phone/crane/driver/timer/clock.h \
./driver/pmu/lpm_cr5.c:14:#include "timer_dec.h"
./driver/pmu/lpm_cr5.c:32://ALL Pheriperials Power optimizations are put in AP side lpm code.
./driver/pmu/lpm_cr5.c:49:extern int ate_timer;
./driver/pmu/lpm_cr5.c:104:        timeout_mdelay(256, &msa_boot_ind, 0);
./driver/pmu/lpm_cr5.c:111:    //above make sure msa is active and loop in L2 SRAM before silent reset, in Helan LTE that will be improved
./driver/pmu/lpm_cr5.c:114:    //10000 times test shows it's safe if MSA is looping on single DDR instruction although MSA cache is not enabled.
./driver/pmu/lpm_cr5.c:136:    msa_boot_test = timeout_mdelay(256, &msa_boot_ind, 0); //make sure MSA side test have time to finish.
./driver/pmu/lpm_cr5.c:144:        bbu_printf("MSA boot fails, timeout=%dmS\r\n", msa_boot_test);
./driver/pmu/lpm_cr5.c:237:// lpmset mode <sram_off> <wake_src> <vctcxo_off> <udr> <time_sec>
./driver/pmu/lpm_cr5.c:254://           arg[6] = sleep time for scheduled type sleep(Sec), not use for async interrupt type
./driver/pmu/lpm_cr5.c:258://DDR into lpm mode at any time. SW method can shutdown DDR event at active mode.
./driver/pmu/lpm_cr5.c:307:In the future, we may fix the smp0 as the last one to enter Cx to simplify code.
./driver/pmu/lpm_cr5.c:326:    uint32_t time_sec = 5;
./driver/pmu/lpm_cr5.c:396:        //In C13, important that CPCR.STBEN bit should not be set in this mode
./driver/pmu/lpm_cr5.c:429:        stop_timer(ate_timer);
./driver/pmu/lpm_cr5.c:442:        restart_timer(ate_timer);
./driver/pmu/lpm_cr5.c:466:    uint32_t time_sec = 5;
./driver/pmu/lpm_cr5.c:571:            time_sec = XpStrToValue((char *)argv[6]);
./driver/pmu/lpm_cr5.c:572:        set_wake_src((e_wake_src)wake_src, time_sec); //for Full chip sleep wake up.
./driver/pmu/lpm_cr5.c:585:        bbu_printf(MP3_PWR_LOG"lpmset: enter mode=%d with wake_src=%d, vctcxo_off=%d, udr=%d, time_sec=%d\r\n",
./driver/pmu/lpm_cr5.c:586:                   mode, wake_src, vctcxo_off >> 19, udr >> 13, time_sec);
./driver/pmu/lpm_cr5.c:595:        //Note: we can limit only AP can change AXI freq, 
./driver/pmu/lpm_cr5.c:629:        //In C13, important that CPCR.STBEN bit should not be set in this mode
./driver/pmu/lpm_cr5.c:662:        stop_timer(ate_timer);
./driver/pmu/lpm_cr5.c:675:        restart_timer(ate_timer);
./driver/pmu/cr5_asm.S:108: FIXME: data consitency is very important.  Disable L1 Dcache means the owner core should exit SMP coherency and
./driver/pmu/cr5_asm.S:159:@Otherwise, the other core may cause the L2 swap out the content to DDR at anytime so that data in stack corrupted.
./driver/pmu/cr5_asm.S:171:        bic     r2, r2, #0x100  @enable imprecise data abort
Binary file ./driver/pmu/ate_msa.bin matches
./driver/pmu/pwr_init.c:16:#include "timer_dec.h"
./driver/pmu/pwr_init.c:24:int simple_data_test(int bCheck);
./driver/printer/print.c:8:  but WITHOUT ANY WARRANTY; without even the implied warranty of
./driver/printer/print.c:51://  USE_INTERNALS implements code for company-specific linkages
./driver/printer/print.c:146://  It is more useful when implementing a walking-string function.
./driver/printer/print.c:189:   uint64_t decimalNum = (uint64_t) ((dbl - wholeNum) * mult);
./driver/printer/print.c:200:   // printf("%.3f: whole=%s, dec=%d\n", dbl, tbfr, decimalNum) ;
./driver/printer/print.c:216:      while (decimalNum != 0) {
./driver/printer/print.c:217:         tbfr[idx++] = '0' + (decimalNum % 10) ;
./driver/printer/print.c:218:         decimalNum /= 10 ;
./driver/printer/print.c:220:      //  pad the decimal portion with 0s as necessary;
./driver/printer/print.c:225:      // printf("decimal=%s\n", tbfr) ;
./driver/printer/print.c:390:   int post_decimal ;
./driver/printer/print.c:414:         post_decimal = 0 ;
./driver/printer/print.c:420:                  post_decimal = 1 ;
./driver/printer/print.c:424:                  if (post_decimal) {
./driver/printer/print.c:434:               		if(post_decimal){
./driver/printer/print.c:637: /* This function can only print MAX_LINE_LEN length line each time.
./driver/printer/print.c:666:  // Q_ASSERT(size < MAX_LINE_LEN);  /* cannot exceed maximum line length */
Binary file ./driver/printer/obj/arm/print.o matches
./driver/Rules.mk:1:SUBDIRS := common printer uart timer i2c pmic pmu amp ddr usb camera misc dma  lcd
./driver/ddr/ddr_dec.h:104:int ddr_set_port_starv_timer(DDR_PORT port_num, uint8_t timer_count);
./driver/ddr/ddr_dec.h:105:void ddr_set_port_starv_timer_all(uint8_t timer_count[8]);
./driver/ddr/ddr_dec.h:106:void ddr_set_bq_starv_timer(uint16_t timer_count);
./driver/common/tim.h:69:#define TIMBUFFER 				4096    		//4k for a Tim structure size
./driver/common/tim.h:354: uint32_t EscSeqTimeOutMS;  				// Value is interpreted in milli secs.
./driver/common/tim.h:436:// OTA related image type
./driver/common/tim.h:439:   	PrimaryImage 	= 0,                // Primary image
./driver/common/tim.h:440:   	RecoveryImage 	= 1,               	// Recovery image
./driver/common/tim.h:441:   	CPImage 		= 2,				// CP image
./driver/common/tim.h:471: 	uint32_t ImageID;                    	// 0x54494Dxx   - secondary tim ID (TIMx)
./driver/common/tim.h:472: 	OTA_IMAGE_TYPE ImageType;          	// OTA_IMAGE_TYPE (Primary VS Recovery)
./driver/common/tim.h:481: 	uint32_t NumberOfMappedImages;       	// Number of images with mapping information
./driver/common/tim.h:482:	IMG_MAP_INFO pImgMapInfo[1];       	// First image map information struct
./driver/common/tim.h:493:	uint32_t ODBTImageList[1];    	//First image ID in new list
./driver/common/tim.h:525:    DDR_IGNORE_INST_TO = 6,		// Treat a time out waiting for a bit to set/clear
./driver/common/tim.h:538://   Delay Specified Time		DELAY				0x3				Value	n/a 			n/a
./driver/common/tim.h:539://   WaitForOperationToSetBit	WAIT_FOR_BIT_SET	0x4				Addr	Mask			TimeOut Value
./driver/common/tim.h:540://   WaitForOperationToClearBit	WAIT_FOR_BIT_CLEAR	0x5				Addr	Mask			TimeOut Value
./driver/common/tim.h:617:	TZ_IGNORE_INST_TO = 6, 		// Treat a time out waiting for a bit to set/clear
./driver/common/tim.h:643:	GPP_IGNORE_INST_TO = 6,		// Treat a time out waiting for a bit to set/clear
./driver/common/tim.h:737: uint32_t NextImageID;					// Indicate next image in the chain
./driver/common/tim.h:754: uint32_t NextImageID;				// Indicate next image in the chain
./driver/common/tim.h:767: uint32_t NextImageID;				// Indicate next image in the chain
./driver/common/tim.h:920:/* tim.c Function Proto's */
./driver/common/tim.h:922:uint32_t LoadTim(uint8_t *TIMArea, TIM *pTIM_h, uint32_t SRAMLoad);
./driver/common/tim.h:937:// Returns a pointer to the static tim in tim.c
./driver/common/tim.h:938:pTIM GetTimPointer();
./driver/common/tim.h:939:uint32_t get_image_number(TIM *pTIM_h);
./driver/common/mfp-emei.c:11:#include "timer_dec.h"
./driver/common/gpio.c:6:#include "timer_dec.h"
./driver/common/bsp.c:41:#include "timer_dec.h"
./driver/common/bsp.c:60:#define SYSTICK_COUNT           16250     //5ms@3.25MHz clock for CPU local timers and generic timers
./driver/common/bsp.c:68:static void sys_timer_handle()      //TIME1 timer0
./driver/common/bsp.c:79:    SYSTIME->ICRn[0] |= ICRN_TCLR0_MASK;      //clear timer0 irq
./driver/common/bsp.c:80:    SYSTIME->IERn[0] &= ~IERN_IE0_MASK;       //disable timer0 irq
./driver/common/bsp.c:83:    SYSTIME->Tn_Mm[0][0] = timer_get_count(0) + SYSTICK_COUNT;  //reset 5ms match value at 3.25MHz
./driver/common/bsp.c:85:    SYSTIME->IERn[0] |= IERN_IE0_MASK;            //enable timer0 irq
./driver/common/bsp.c:88:#else //default use generic timer
./driver/common/bsp.c:96:    QSTimeCtr QS_tickTime_;
./driver/common/bsp.c:97:    //QSTimeCtr QS_tickPeriod_;
./driver/common/bsp.c:109:    QS_tickTime_ += SYSTICK_COUNT;       /* account for the clock count of one tick */
./driver/common/bsp.c:119:    sys_timer_handle();
./driver/common/bsp.c:121:    QF_TICK_X(0, &l_SysTick_Handler);                             /* process all armed time events */
./driver/common/bsp.c:130:             /* Core local timer is used to driver QK scheduler in SMP mode */
./driver/common/bsp.c:132:void local_timer_handler(void)
./driver/common/bsp.c:141:void local_timer_init(void)
./driver/common/bsp.c:145:    GIC_ISR_CONNECT(GIC_INT_TMR,local_timer_handler, (void *)0);
./driver/common/bsp.c:153:void local_timer_disable(void)
./driver/common/bsp.c:226:   count = timer_get_count(0);
./driver/common/bsp.c:236:   SYSTIME->Tn_Mm[0][0] = timer_get_count(0) + (SYSTICK_COUNT*tick);
./driver/common/bsp.c:258:        SYSTIME->Tn_Mm[0][0] = timer_get_count(0) + SYSTICK_COUNT;  //first set 5ms match value at 3.25MHz
./driver/common/bsp.c:259:        SYSTIME->IERn[0] |= IERN_IE0_MASK;            //enable timer0 irq
./driver/common/bsp.c:261:#else //default use generic timer
./driver/common/bsp.c:278:        SYSTIME->IERn[0] &= ~IERN_IE0_MASK; //disable timer0 irq
./driver/common/bsp.c:279:#else //default use generic timer
./driver/common/bsp.c:293:    QTimer_register(QF_sysTickEnable, 
./driver/common/bsp.c:413:    mdelay(10); /*enough time to print it out*/
./driver/common/bsp.c:441:    QS_tickTime_ = SYSTICK_COUNT;        /* to start the timestamp at zero, ref QS_onGetTime() */
./driver/common/bsp.c:486:QSTimeCtr QS_onGetTime(void) {            /* invoked with interrupts locked */
./driver/common/bsp.c:489:        return QS_tickTime_ + (QSTimeCtr)(SYSTICK_COUNT - BU_REG_READ(MP_TMR_CNTR));
./driver/common/bsp.c:492:        return QS_tickTime_ - (QSTimeCtr)(BU_REG_READ(MP_TMR_CNTR));
./driver/common/bsp.c:497:        return QS_tickTime_ + (QSTimeCtr)(timer_get_count(0) - SYSTIME->Tn_Mm[0][0]);
./driver/common/bsp.c:500:        return QS_tickTime_ - (QSTimeCtr)(SYSTIME->Tn_Mm[0][0] - timer_get_count(0));
./driver/common/bsp.c:502:#else //default use generic timer
./driver/common/bsp.c:570:* execution time contributes to the brightness of the User LED.
./driver/common/tim.c:20:#include "tim.h"
./driver/common/tim.c:62:uint32_t get_image_number(TIM *pTIM_h)
./driver/common/tim.c:67:uint32_t get_image_size(uint32_t Image)
./driver/common/tim.c:69:    TIM tim;
./driver/common/tim.c:70:    pTIM pTIM_h = &tim;
./driver/common/tim.c:71:    int imageNum;
./driver/common/tim.c:76:    /* check if there is valid tim in SRAM */
./driver/common/tim.c:82:    imageNum = pTIM_h->pConsTIM->NumImages;
./driver/common/tim.c:84:    for(int i = 0; i < imageNum; i++){
./driver/common/tim.c:94:int load_image_from_flash(uint32_t Image, uint32_t address)
./driver/common/tim.c:96:	TIM tim;
./driver/common/tim.c:97:	pTIM pTIM_h = &tim;
./driver/common/tim.c:98:	int imageNum, imageSize, i;
./driver/common/tim.c:104:    /* check if there is valid tim in SRAM */
./driver/common/tim.c:110:    imageNum = pTIM_h->pConsTIM->NumImages;
./driver/common/tim.c:112:    for(i = 0; i < imageNum; i++){
./driver/common/tim.c:116:    		//Load image from flash to DDR
./driver/common/bbu_malloc.c:17:/* Memory pools used for bbu_malloc, everytime the pools and their length are
./driver/common/bbu_malloc.c:30:/* Memory pools used for bbu_nc_malloc, everytime the pools and their length are
./driver/common/bbu_malloc.c:76:extern uint32_t kern_image_size;
./driver/common/bbu_malloc.c:128:    bbu_malloc_buffer = ADDR_ALIGN((kern_image_size+CODE_AREA_ST),0x10000);
./driver/common/bbu_malloc.c:130:    bbu_malloc_buffer = ADDR_ALIGN((kern_image_size+CODE_AREA_ST),0x100000);
./driver/common/ate.c:7:#include "timer_dec.h"
./driver/common/ipc.c:224:   int time_out = 0x4000;
./driver/common/ipc.c:241:   while(time_out){
./driver/common/ipc.c:248:      time_out --;
./driver/common/ipc.c:250:   if(time_out == 0){
./driver/common/ipc.c:251:      bbu_printf("Test fail, can't get reply in time\n\r");
./driver/common/list.h:40: * Simple doubly linked list implementation.
./driver/common/list.h:44: * sometimes we already know the next/prev entries and we can
./driver/common/list.h:88: * This is good for implementing stacks.
./driver/common/list.h:102: * This is useful for implementing queues.
Binary file ./driver/common/obj/arm/gpio.o matches
Binary file ./driver/common/obj/arm/plist.o matches
Binary file ./driver/common/obj/arm/bbu_mfile.o matches
./driver/common/obj/arm/gpio.d:8: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/common/obj/arm/gpio.d:39: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/common/obj/arm/tim.o matches
./driver/common/obj/arm/bsp.d:38: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/common/obj/arm/bsp.d:40: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/common/obj/arm/ripc.o matches
Binary file ./driver/common/obj/arm/interrupt.o matches
./driver/common/obj/arm/mfp-emei.d:12: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/common/obj/arm/mfp-emei.d:42: /home/feature_phone/crane/driver/timer/clock.h \
./driver/common/obj/arm/tim.d:1:/home/feature_phone/crane/driver/common/obj/arm/tim.o: \
./driver/common/obj/arm/tim.d:2: /home/feature_phone/crane/driver/common/tim.c \
./driver/common/obj/arm/tim.d:3: /home/feature_phone/crane/driver/common/tim.h \
Binary file ./driver/common/obj/arm/bbu_malloc.o matches
Binary file ./driver/common/obj/arm/ipc.o matches
Binary file ./driver/common/obj/arm/bsp.o matches
Binary file ./driver/common/obj/arm/sm_malloc.o matches
./driver/common/obj/arm/ripc.d:35: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/common/obj/arm/ripc.d:38: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/common/obj/arm/mfp-emei.o matches
./driver/common/spinlock.h:165: * Unlocking is similarly hairy.  We may have multiple read locks
./driver/common/ripc.c:4:#include "timer_dec.h"
./driver/common/atomic.h:23: * strex/ldrex monitor on some implementations. The reason we can use it for
./driver/common/mfp.h:283: * bit  0.. 9 - MFP Pin Number (1024 Pins Maximum)
./driver/common/mfp.h:451: * mfp_config_run()	- configuring all run time  MFPR registers after resume
./driver/common/gic_dec.h:19://The PPIs in the range ID16-ID27 are unimplemented.
./driver/common/gic_dec.h:22:a set of 4 timers per CPU is defined   
./driver/common/gic_dec.h:23:A physical timer for use in Kernel modes/Secure Privileged modes   (CNTP_)    Banked 
./driver/common/gic_dec.h:25:-Non-secure Kernel access to this Timer controlled using a Hyp Control register   
./driver/common/gic_dec.h:26:A virtual timer for use in Kernel modes           (CNTV_)        Common 
./driver/common/gic_dec.h:27:A physical timer for use in Hyp mode              (CNTHP_)       Common  
./driver/common/gic_dec.h:29:Each CPU makes the output of each timer as an output pin to the system, and 
./driver/common/gic_dec.h:31:For each CPU the same interrupt number should be used for the same timer. 
./driver/common/gic_dec.h:111: * Number of interrupts implemented in the GIC
./driver/common/gic_dec.h:194:#define ENABLE        1 /**< Interrupt enable. Used with gic_interrupt_enable() primitive. */
./driver/common/gic_dec.h:195:#define DISABLE       0 /**< Interrupt disable. Used with gic_interrupt_enable() primitive. */
./driver/common/interrupt.c:98:  so CPU is wake up but it will not handle the interrupt. At that time, we restore
./driver/common/interrupt.c:103:  FIXME: we may fix the wake up sequence for simple in ca9_idle.c later*/
./driver/common/interrupt.c:307:  requires a fast response time, e.g. DMA specially used to move blocks of memory, timer validation
./driver/common/interrupt.c:308:  and hard real-time appliations. Thus, there are usually 1~2 FIQs enabled. If necessary, it should be handled in
./driver/common/bbu_mfile.c:796:   bbu_printf("   test  - a simple memory file test\n\r");
./driver/misc/pwm.c:5:#include "timer_dec.h"
./driver/misc/obj/arm/pwm.d:7: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/misc/obj/arm/pwm.d:38: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/misc/obj/arm/pwm.o matches
./driver/timer/wdt.c:60:    // the wdt timer seems only use 256hz
./driver/timer/wdt.c:61:    // see the emei register TimersCP section for details
./driver/timer/clock.h:15://get escaped time(usec) from BBU start.
./driver/timer/clock.h:18://get escaped time(msec) from BBU start
./driver/timer/clock.h:21://get escaped time(sec) from BBU start
./driver/timer/clock.h:24://get bbu system time
./driver/timer/clock.h:25:void bbu_get_system_time(P_BBU_TIME p_time);
./driver/timer/clock.h:28:void bbu_strftime(char *time_buffer);
./driver/timer/clock.h:31:void print_current_time(void);
./driver/timer/rtc.c:1:#include "timer_dec.h"
./driver/timer/clock.c:2:#include "timer_dec.h"
./driver/timer/clock.c:5:/* These two macros need to be defined according to different timers */
./driver/timer/clock.c:10:void print_current_time(void){
./driver/timer/clock.c:11:	uint64_t total_usec_from_start = generic_timer_read()/COUNT_PER_USEC;
./driver/timer/clock.c:24:	uint64_t total_usec_from_start = generic_timer_read();
./driver/timer/clock.c:30:	uint64_t total_usec_from_start = generic_timer_read();
./driver/timer/clock.c:37:	uint64_t total_usec_from_start = generic_timer_read();
./driver/timer/clock.c:43:void bbu_get_system_time(P_BBU_TIME p_time){
./driver/timer/clock.c:44:	if(p_time == NULL){
./driver/timer/clock.c:45:		bbu_printf("The input time point struct is invlid\r\n");
./driver/timer/clock.c:50:	uint64_t total_usec = generic_timer_read()/COUNT_PER_USEC;
./driver/timer/clock.c:58:	memcpy(p_time, &t, sizeof(BBU_TIME));
./driver/timer/clock.c:65:void bbu_strftime(char *time_buffer){
./driver/timer/clock.c:66:	uint64_t total_usec_from_start = generic_timer_read()/COUNT_PER_USEC;
./driver/timer/clock.c:72:	bbu_sprintf(time_buffer, "BBU TIME: %02d:%02d:%02d.%04d.%04d",
./driver/timer/Rules.mk:8:SRCS += timer_cr5.c
./driver/timer/timer_cr5.c:3:#include "timer_dec.h"
./driver/timer/timer_cr5.c:10:Q_DEFINE_THIS_MODULE("timer_cr5.c")
./driver/timer/timer_cr5.c:13: * In nezha3 core cr5, we use timercp unit0 as system timer.
./driver/timer/timer_cr5.c:14: * We choose the TIMER_GROUP_WAKEUP timer as wake up source in a timer table.
./driver/timer/timer_cr5.c:16://global timer array.
./driver/timer/timer_cr5.c:17:TIME_BASE *timer[TIMER_RES_CNT] = {TIME1, TIME2};
./driver/timer/timer_cr5.c:18:uint32_t timer_mmp_irq[TIMER_UNIT_NUM] = {IRQ_MMP_AP1_TIMER1, IRQ_MMP_AP1_TIMER2, IRQ_MMP_AP1_TIMER2,
./driver/timer/timer_cr5.c:21:static int get_timer_irq(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:22:	return (int)timer_mmp_irq[index*UNIT_PER_TIMER+unit];
./driver/timer/timer_cr5.c:25:static int timer_irq_inited[TIMER_UNIT_NUM] = {0};
./driver/timer/timer_cr5.c:28://static uint32_t is_system_timer(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:31:static uint32_t wakeup_timer_remain = 2;
./driver/timer/timer_cr5.c:33:static TimerAttr timer_table[] = {
./driver/timer/timer_cr5.c:42:static int timer_table_idx(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:44:	uint32_t unit_num = sizeof(timer_table)/sizeof(timer_table[0]);
./driver/timer/timer_cr5.c:47:		if( (timer_table[i].idx == index) && 
./driver/timer/timer_cr5.c:48:			( timer_table[i].unit == unit ))
./driver/timer/timer_cr5.c:55:static void timer_clock_select(uint32_t index, uint32_t unit, uint32_t clk)
./driver/timer/timer_cr5.c:65:    val = timer[index]->CCR;
./driver/timer/timer_cr5.c:69:    timer[index]->CCR = val;
./driver/timer/timer_cr5.c:87:void apb_timer_reset(void){
./driver/timer/timer_cr5.c:89:    //Timer 1
./driver/timer/timer_cr5.c:95:    //Timer 2
./driver/timer/timer_cr5.c:102:void apb_systimer_init(void){
./driver/timer/timer_cr5.c:105:	SYSTIME->CER &= ~CER_T0EN_MASK;   //disable timer0 before configure it
./driver/timer/timer_cr5.c:109:	/* timer0 3.25M */
./driver/timer/timer_cr5.c:110:	SYSTIME->CCR &= ~CCR_CS_0_MASK;   //TIME1 timer0 select configurable clock.
./driver/timer/timer_cr5.c:115:	SYSTIME->CMR |= CMR_T0MODE_MASK;  //TIME1 timer0 as free running timer mode
./driver/timer/timer_cr5.c:122:	SYSTIME->ICRn[0] |= ICRN_TCLR0_MASK;	  //clear timer0 irq
./driver/timer/timer_cr5.c:130:	/* enable the timer to kick off counter */
./driver/timer/timer_cr5.c:131:	SYSTIME->CER = 0x1;   //enable timer0 after configure
./driver/timer/timer_cr5.c:136:/*Let the TIME1_timer0 at free running, and don't enable the preload when a
./driver/timer/timer_cr5.c:137:  match occurs between TMR_Tn_Tm and Timer Count Registers.
./driver/timer/timer_cr5.c:140:void sys_timer_init(void) //This funciton is related to OS tick, Care to modify!
./driver/timer/timer_cr5.c:142:	apb_timer_reset();
./driver/timer/timer_cr5.c:143:	apb_systimer_init(); //this is the timers on APB bus
./driver/timer/timer_cr5.c:144:	generic_timer_config(); //this is the global generic timers, for delay  system timestamp,etc.
./driver/timer/timer_cr5.c:185://If the delta is within 0x10000000(about 1min, it cost time when cache is not enabled yet at boot), 
./driver/timer/timer_cr5.c:199:uint32_t timer_get_count(int id)
./driver/timer/timer_cr5.c:205:// generic timer use 26Mhz clk
./driver/timer/timer_cr5.c:206:static void timer_tick_delay(int tick){   
./driver/timer/timer_cr5.c:209:	begin = generic_timer_read();
./driver/timer/timer_cr5.c:211:		end = generic_timer_read();
./driver/timer/timer_cr5.c:219:	timer_tick_delay(us * 26);
./driver/timer/timer_cr5.c:226:uint32_t timeout_mdelay(uint32_t ms, uint32_t *ind, uint32_t expected_value){
./driver/timer/timer_cr5.c:229:	begin =(uint64_t)generic_timer_read();
./driver/timer/timer_cr5.c:231:		end =(uint64_t)generic_timer_read();
./driver/timer/timer_cr5.c:239:static void timer_tick_delay(int tick){
./driver/timer/timer_cr5.c:242:	begin = timer_get_count(0);
./driver/timer/timer_cr5.c:245:		end = timer_get_count(0);
./driver/timer/timer_cr5.c:254:	There is a limition in the below function, the returned cycle is
./driver/timer/timer_cr5.c:260:	timer_tick_delay(13*us);
./driver/timer/timer_cr5.c:268:	timer_tick_delay(tick);
./driver/timer/timer_cr5.c:276:	timer_tick_delay(tick);
./driver/timer/timer_cr5.c:282:	timer_tick_delay(ms * TIMER0_TICK_PER_MSEC);
./driver/timer/timer_cr5.c:286:uint32_t timeout_mdelay(uint32_t ms, uint32_t *ind, uint32_t expected_value){
./driver/timer/timer_cr5.c:291:	begin = timer_get_count(0);
./driver/timer/timer_cr5.c:294:		end = timer_get_count(0);
./driver/timer/timer_cr5.c:307:void generic_timer_config(void){
./driver/timer/timer_cr5.c:313:	// emei doesn't have generic timer
./driver/timer/timer_cr5.c:319:uint64_t generic_timer_read(void){
./driver/timer/timer_cr5.c:321:	uint64_t time;
./driver/timer/timer_cr5.c:324:	time = ((uint64_t)up << 32) | low;
./driver/timer/timer_cr5.c:326:	return time;
./driver/timer/timer_cr5.c:330:void generic_timer_test(){
./driver/timer/timer_cr5.c:334:	begin = generic_timer_read();
./driver/timer/timer_cr5.c:336:		end = generic_timer_read();
./driver/timer/timer_cr5.c:350:static void timer_preload_comparator(TIME_BASE* timer, uint32_t unit, uint32_t comparator){
./driver/timer/timer_cr5.c:352:	val = timer->PLCRn[unit];
./driver/timer/timer_cr5.c:355:	timer->PLCRn[unit] = val;
./driver/timer/timer_cr5.c:360:static void timer_count_enable(TIME_BASE* timer, uint32_t unit){
./driver/timer/timer_cr5.c:362:	val = timer->CER;
./driver/timer/timer_cr5.c:364:	timer->CER = val;
./driver/timer/timer_cr5.c:369:static void timer_count_disable(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:371:	int d = timer_table_idx(index, unit);
./driver/timer/timer_cr5.c:373:		bbu_printf("Error timer index or unit\r\n");
./driver/timer/timer_cr5.c:376:	if(timer_table[d].group==TIMER_GROUP_WAKEUP)
./driver/timer/timer_cr5.c:377:		wakeup_timer_remain++;
./driver/timer/timer_cr5.c:378:	if(timer_table[d].group==TIMER_GROUP_WAKEUP_CP)
./driver/timer/timer_cr5.c:379:		wakeup_timer_remain++;
./driver/timer/timer_cr5.c:380:	val = timer[index]->CER;
./driver/timer/timer_cr5.c:382:	timer[index]->CER = val;
./driver/timer/timer_cr5.c:383:	timer_table[d].stat = TIMER_FREE;
./driver/timer/timer_cr5.c:388:static void timer_count_mode_set(TIME_BASE* timer, uint32_t unit, uint32_t mode){
./driver/timer/timer_cr5.c:390:	val = timer->CMR;
./driver/timer/timer_cr5.c:393:	timer->CMR = val;
./driver/timer/timer_cr5.c:398:static void ap_timer_irq(void *irq_arg){
./driver/timer/timer_cr5.c:401:	//TimerIrqEvt *timer_irq_func_evt = Q_NEW(TimerIrqEvt, TIMER_HANDLE_SIG); 
./driver/timer/timer_cr5.c:403:	index = ((IrqArg*)irq_arg)->timer_index;
./driver/timer/timer_cr5.c:404:	unit = ((IrqArg*)irq_arg)->timer_unit;
./driver/timer/timer_cr5.c:408:	timer[index]->ICRn[unit] |= 1; // clear int
./driver/timer/timer_cr5.c:410:		timer_count_disable(index, unit);
./driver/timer/timer_cr5.c:419:static int _start_timer(int ms, irq_func irq_handler, uint32_t flag, void* irq_arg_, 
./driver/timer/timer_cr5.c:428:    d = timer_table_idx(index, unit);
./driver/timer/timer_cr5.c:430:        bbu_printf("Wrong timer, index %d, unit\r\n", index, unit);
./driver/timer/timer_cr5.c:436:    if((timer[index]->CER & (1<<unit))){
./driver/timer/timer_cr5.c:437:        bbu_printf("Timer %d unit %d is busy\r\n", index, unit);
./driver/timer/timer_cr5.c:441:    if(timer_table[d].stat == TIMER_BUSY){
./driver/timer/timer_cr5.c:442:        bbu_printf("Timer %d unit %d is SW busy\r\n", index, unit);
./driver/timer/timer_cr5.c:448:        irq_arg.timer_index = index;
./driver/timer/timer_cr5.c:449:        irq_arg.timer_unit = unit;
./driver/timer/timer_cr5.c:456:        irq = get_timer_irq(index, unit);
./driver/timer/timer_cr5.c:457:        if(!timer_table[d].irq_connected){
./driver/timer/timer_cr5.c:458:            ISR_Connect(irq, ap_timer_irq, (void *)&irq_arg_g[3*index+unit]);
./driver/timer/timer_cr5.c:459:            timer_table[d].irq_connected = 1;
./driver/timer/timer_cr5.c:465:        timer_count_disable(index, unit);
./driver/timer/timer_cr5.c:467:        timer[index]->IERn[unit] &= ~(1 << 0);
./driver/timer/timer_cr5.c:469:        timer[index]->Tn_Mm[unit][0] = count;
./driver/timer/timer_cr5.c:471:        timer[index]->PLVRn[unit] = 0;
./driver/timer/timer_cr5.c:473:        timer_clock_select(index, unit, clk);
./driver/timer/timer_cr5.c:476:        timer_preload_comparator(timer[index], unit, 1);
./driver/timer/timer_cr5.c:478:        timer_count_mode_set(timer[index], unit, flag);
./driver/timer/timer_cr5.c:480:        timer[index]->IERn[unit] |= (1 << 0);
./driver/timer/timer_cr5.c:481:        timer_count_enable(timer[index], unit);
./driver/timer/timer_cr5.c:484:    timer_table[d].stat = TIMER_BUSY;
./driver/timer/timer_cr5.c:489:static void _stop_timer(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:492:	timer_count_disable(index, unit);
./driver/timer/timer_cr5.c:494:	timer[index]->IERn[unit] &= ~(1 << 0);
./driver/timer/timer_cr5.c:495:	timer[index]->ICRn[unit] |= 1; // clear irq.
./driver/timer/timer_cr5.c:496:	irq = get_timer_irq(index, unit);
./driver/timer/timer_cr5.c:502:static int is_timer_active(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:504:	if(timer[index]->CER & (1<<unit))
./driver/timer/timer_cr5.c:510:int start_specific_timer(int ms, irq_func irq_handler, uint32_t flag, void* irq_arg_, 
./driver/timer/timer_cr5.c:511:						int timer_index, int timer_unit, TIMER_CLK clk)
./driver/timer/timer_cr5.c:513:	wakeup_timer_remain--;
./driver/timer/timer_cr5.c:514:	return _start_timer(ms, irq_handler, flag, irq_arg_, timer_index, timer_unit, clk);
./driver/timer/timer_cr5.c:517:int start_timer(int ms, irq_func irq_handler, uint32_t flag){
./driver/timer/timer_cr5.c:519:    uint32_t unit_num = sizeof(timer_table)/sizeof(timer_table[0]);
./driver/timer/timer_cr5.c:521:		if(timer_table[i].group!=TIMER_GROUP_NORMAL)
./driver/timer/timer_cr5.c:523:		index = timer_table[i].idx;
./driver/timer/timer_cr5.c:524:		unit = timer_table[i].unit;
./driver/timer/timer_cr5.c:525:		if((!(timer[index]->CER&(1<<unit)))&&(timer_table[i].stat==TIMER_FREE))
./driver/timer/timer_cr5.c:531:			if((timer_table[i].group!=TIMER_GROUP_WAKEUP)&&(timer_table[i].group==TIMER_GROUP_WAKEUP_CP))
./driver/timer/timer_cr5.c:533:			index = timer_table[i].idx;
./driver/timer/timer_cr5.c:534:			unit = timer_table[i].unit;
./driver/timer/timer_cr5.c:535:			if((!(timer[index]->CER&(1<<unit)))&&(timer_table[i].stat!=TIMER_FREE)){
./driver/timer/timer_cr5.c:536:				if(wakeup_timer_remain>1){
./driver/timer/timer_cr5.c:537:					wakeup_timer_remain--;
./driver/timer/timer_cr5.c:540:					bbu_printf("Wakeup timer can not be used as timer tick\r\n");
./driver/timer/timer_cr5.c:541:					bbu_printf("All timers are busy\r\n");
./driver/timer/timer_cr5.c:549:		bbu_printf("All timers are busy\r\n");
./driver/timer/timer_cr5.c:553:	return _start_timer(ms, irq_handler, flag, NULL, index, unit, TIMER_CLK_13M);
./driver/timer/timer_cr5.c:556:void stop_timer(int index){
./driver/timer/timer_cr5.c:557:	int timer_index, unit;
./driver/timer/timer_cr5.c:559:	timer_index = index>>2;
./driver/timer/timer_cr5.c:564:	_stop_timer(timer_index, unit);
./driver/timer/timer_cr5.c:569:void free_timer(int index){
./driver/timer/timer_cr5.c:570:	stop_timer(index);
./driver/timer/timer_cr5.c:575:void restart_timer(int index){
./driver/timer/timer_cr5.c:576:	int timer_index, unit, irq;
./driver/timer/timer_cr5.c:578:	timer_index = index>>2;
./driver/timer/timer_cr5.c:584:	timer[timer_index]->IERn[unit] |= (1 << 0);
./driver/timer/timer_cr5.c:586:	irq = get_timer_irq(timer_index, unit);
./driver/timer/timer_cr5.c:588:    //ISR_Connect(irq, ap_timer_irq, (void *)&irq_arg_g[3*timer_index+unit]);
./driver/timer/timer_cr5.c:590:	timer_count_enable(timer[timer_index], unit);
./driver/timer/timer_cr5.c:597://timer_info[index][unit][index/unit/interval]
./driver/timer/timer_cr5.c:598:static int timer_info[TIMER_RES_CNT][3][3];
./driver/timer/timer_cr5.c:599:static void timer_test_output(void* info){
./driver/timer/timer_cr5.c:603:	bbu_printf("The timer %d unit %d interval is %d\r\n", index_, unit_, interval_);
./driver/timer/timer_cr5.c:607://timer test start function.
./driver/timer/timer_cr5.c:609:void timer_test_start(uint32_t index, uint32_t unit, uint32_t run_mode, uint32_t interval){
./driver/timer/timer_cr5.c:610:	timer_info[index][unit][0] = index;
./driver/timer/timer_cr5.c:611:	timer_info[index][unit][1] = unit;
./driver/timer/timer_cr5.c:612:	timer_info[index][unit][2] = interval;
./driver/timer/timer_cr5.c:613:	_start_timer(interval, timer_test_output, run_mode, timer_info[index][unit], index, unit, TIMER_CLK_13M);
./driver/timer/timer_cr5.c:614:	//start_timer_clk(interval, timer_test_output, run_mode, index, unit, TIMER_CLK_32K);
./driver/timer/timer_cr5.c:619:void timer_test_stop(uint32_t index, uint32_t unit){
./driver/timer/timer_cr5.c:621:	status = is_timer_active(index, unit);
./driver/timer/timer_cr5.c:623:		bbu_printf("timer %d unit %d is not running\r\n", index, unit);
./driver/timer/timer_cr5.c:626:	_stop_timer(index, unit);
./driver/timer/timer_cr5.c:627:	bbu_printf("timer %d unit %d is stopped\r\n", index, unit);
./driver/timer/timer_cr5.c:632:void time_start_all(uint32_t run_mode, uint32_t interval){
./driver/timer/timer_cr5.c:634:	for(i=0; i<sizeof(timer_table)/sizeof(timer_table[0]); i++){
./driver/timer/timer_cr5.c:635:		if(timer_table[i].group==TIMER_GROUP_SYSTEM)
./driver/timer/timer_cr5.c:637:		if(timer_table[i].group==TIMER_GROUP_AP)
./driver/timer/timer_cr5.c:639:		if(timer_table[i].stat!=TIMER_FREE)
./driver/timer/timer_cr5.c:641:		index = timer_table[i].idx;
./driver/timer/timer_cr5.c:642:		unit = timer_table[i].unit;
./driver/timer/timer_cr5.c:643:		timer_test_start(index, unit, run_mode, interval);
./driver/timer/timer_cr5.c:649:void timer_stop_all(){
./driver/timer/timer_cr5.c:651:	for(i=0; i<sizeof(timer_table)/sizeof(timer_table[0]); i++){
./driver/timer/timer_cr5.c:652:		if(timer_table[i].group==TIMER_GROUP_SYSTEM)
./driver/timer/timer_cr5.c:654:		if(timer_table[i].group==TIMER_GROUP_AP)
./driver/timer/timer_cr5.c:656:		if(timer_table[i].stat!=TIMER_BUSY)
./driver/timer/timer_cr5.c:658:		index = timer_table[i].idx;
./driver/timer/timer_cr5.c:659:		unit = timer_table[i].unit;
./driver/timer/timer_cr5.c:660:		timer_test_stop(index, unit);
./driver/timer/timer_cr5.c:666:void timer_test(int argc, uint8_t **argv){
./driver/timer/timer_cr5.c:670:			bbu_timer_help();
./driver/timer/timer_cr5.c:675:				timer_stop_all();
./driver/timer/timer_cr5.c:677:				bbu_timer_help();
./driver/timer/timer_cr5.c:685:					timer_test_stop(index, unit);
./driver/timer/timer_cr5.c:687:				bbu_timer_help();
./driver/timer/timer_cr5.c:694:					time_start_all(conv_dec((char*)argv[3]), conv_dec((char*)argv[4]));
./driver/timer/timer_cr5.c:696:					bbu_timer_help();
./driver/timer/timer_cr5.c:707:				timer_test_start(index, unit, run_mode, interval);
./driver/timer/timer_cr5.c:709:				bbu_timer_help();
./driver/timer/timer_cr5.c:738:static int _start_timer_clk(int ms, irq_func irq_handler, uint32_t mode,
./driver/timer/timer_cr5.c:739:					 int timer_index, int timer_unit, TIMER_CLK clk){
./driver/timer/timer_cr5.c:740:	return _start_timer(ms, irq_handler, mode, NULL,timer_index, timer_unit, clk);
./driver/timer/timer_cr5.c:743:int start_timer_wakeup(int ms, irq_func irq_handler){
./driver/timer/timer_cr5.c:745:	for(i=0; i<sizeof(timer_table)/sizeof(timer_table[0]); i++){
./driver/timer/timer_cr5.c:746:		if(timer_table[i].group!=TIMER_GROUP_WAKEUP_CP)
./driver/timer/timer_cr5.c:748:		index = timer_table[i].idx;
./driver/timer/timer_cr5.c:749:		unit = timer_table[i].unit;
./driver/timer/timer_cr5.c:750:		if((!(timer[index]->CER&(1<<unit)))&&(timer_table[i].stat==TIMER_FREE))
./driver/timer/timer_cr5.c:753:	if(i>=sizeof(timer_table)/sizeof(timer_table[0])){
./driver/timer/timer_cr5.c:754:		bbu_printf("No timer free for wake up\r\n");
./driver/timer/timer_cr5.c:757:	_start_timer_clk(ms, irq_handler, 1, index, unit, TIMER_CLK_32K);
./driver/timer/timer_cr5.c:758:	bbu_printf("timer %d unit %d is set as wake up source\r\n", index, unit);
./driver/timer/timer_cr5.c:759:	int ret = get_timer_irq(index, unit);
./driver/timer/obj/arm/timer_cr5.d:1:/home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o: \
./driver/timer/obj/arm/timer_cr5.d:2: /home/feature_phone/crane/driver/timer/timer_cr5.c \
./driver/timer/obj/arm/timer_cr5.d:5: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/timer/obj/arm/timer_cr5.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./driver/timer/obj/arm/delay-mmp.d:1:/home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o: \
./driver/timer/obj/arm/delay-mmp.d:2: /home/feature_phone/crane/driver/timer/delay-mmp.S
./driver/timer/obj/arm/rtc.d:1:/home/feature_phone/crane/driver/timer/obj/arm/rtc.o: \
./driver/timer/obj/arm/rtc.d:2: /home/feature_phone/crane/driver/timer/rtc.c \
./driver/timer/obj/arm/rtc.d:3: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/timer/obj/arm/rtc.d:35: /home/feature_phone/crane/driver/timer/clock.h \
./driver/timer/obj/arm/rtc.d:39: /home/feature_phone/crane/driver/timer/timer_dec.h \
Binary file ./driver/timer/obj/arm/clock.o matches
Binary file ./driver/timer/obj/arm/timer_cr5.o matches
Binary file ./driver/timer/obj/arm/rtc.o matches
Binary file ./driver/timer/obj/arm/wdt.o matches
Binary file ./driver/timer/obj/arm/delay-mmp.o matches
./driver/timer/obj/arm/wdt.d:1:/home/feature_phone/crane/driver/timer/obj/arm/wdt.o: \
./driver/timer/obj/arm/wdt.d:2: /home/feature_phone/crane/driver/timer/wdt.c \
./driver/timer/obj/arm/wdt.d:36: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/timer/obj/arm/wdt.d:39: /home/feature_phone/crane/driver/timer/clock.h \
./driver/timer/obj/arm/clock.d:1:/home/feature_phone/crane/driver/timer/obj/arm/clock.o: \
./driver/timer/obj/arm/clock.d:2: /home/feature_phone/crane/driver/timer/clock.c \
./driver/timer/obj/arm/clock.d:4: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/timer/obj/arm/clock.d:35: /home/feature_phone/crane/driver/timer/clock.h \
./driver/timer/timer_dec.h:34:	int timer_index;
./driver/timer/timer_dec.h:35:	int timer_unit;
./driver/timer/timer_dec.h:37:	irq_func func;//timeout function.
./driver/timer/timer_dec.h:54:typedef struct TimerAttrTag{
./driver/timer/timer_dec.h:60:}TimerAttr;
./driver/timer/timer_dec.h:97://system timer functions.
./driver/timer/timer_dec.h:98:uint32_t timer_get_count(int id);
./driver/timer/timer_dec.h:108:void generic_timer_config(void);
./driver/timer/timer_dec.h:109:uint64_t generic_timer_read(void);
./driver/timer/timer_dec.h:111:void generic_timer_test(void);
./driver/timer/timer_dec.h:117://watch dog timer function.
./driver/timer/timer_dec.h:121:void pmic_watchdog_timer_reset(void);
./driver/timer/timer_dec.h:132:int start_timer(int ms, irq_func irq_handler, uint32_t flag);
./driver/timer/timer_dec.h:133:void stop_timer(int index);
./driver/timer/timer_dec.h:134:void free_timer(int index);
./driver/timer/timer_dec.h:137:int start_timer_wakeup(int ms, irq_func irq_handler);
./driver/timer/timer_dec.h:138:void timer_test_start(uint32_t index, uint32_t unit, uint32_t run_mode, uint32_t interval);
./driver/timer/timer_dec.h:139:void timer_test_stop(uint32_t index, uint32_t unit);
./driver/timer/timer_dec.h:140:void time_start_all(uint32_t run_mode, uint32_t interval);
./driver/timer/timer_dec.h:141:void timer_stop_all();
./driver/timer/timer_dec.h:142:void timer_test(int argc, uint8_t **argv);
./driver/timer/delay-mmp.S:2:This is start from MMP3.  used for delays. while OS tick use a different timer
./driver/camera/camera_reg.h:41: * 31:0    U0 Base Address   UBASE0          RW      0x0              U0 Base Address<p>This register is irrelevant when the image format is RGB or YUV packed.
./driver/camera/camera_reg.h:49: * 31:0    U1 Base Address   UBASE1          RW      0x0              U1 Base Address<p>This register is irrelevant when the image format is RGB or YUV packed.
./driver/camera/camera_reg.h:57: * 31:0    U2 Base Address   UBASE2          RW      0x0              U2 Base Address<p>This register is irrelevant when the image format is RGB or YUV packed.
./driver/camera/camera_reg.h:65: * 31:0    V0 Base Address   VBASE0          RW      0x0              V0 Base Address<p>This register is irrelevant when the image format is RGB or YUV packed.
./driver/camera/camera_reg.h:73: * 31:0    V1 Base Address   VBASE1          RW      0x0              V1 Base Address<p>This register is irrelevant when the image format is RGB or YUV packed.
./driver/camera/camera_reg.h:81: * 31:0    V2 Base Address   VBASE2          RW      0x0              V2 Base Address<p>This register is irrelevant when the image format is RGB or YUV packed.
./driver/camera/camera_reg.h:136: * 28:16   Image Line Offset in Scanline  VOFF			  RW      0x0 			   Image Line Offset in Scanline<p>Starts capturing external CMOS sensor image at VOFF line. <p>0 = CCIC starts capturing at line 0 for every frame
./driver/camera/camera_reg.h:138: * 13:0    Image Pixel Offset in PIXCLK	  HOFF		      RW	  0x0              Image Pixel Offset in PIXCLK<p>Starts capturing external CMOS sensor image at HOFF pixel. <p>0 = CCIC starts capturing at pixel 0 for every line in the frame
./driver/camera/camera_reg.h:161: * 31      ISIM Fix                         ISIM_HMUCSTFIX         RW      0X0              ISIM Fix<p>This field is used to enable the fix for enabling/disabling CCIC.<p>1 = Enable this fix<p>0 = Disable this fix<p>Bug description:when isim_en=1->0, isim_en_s2 toggles 1->0 before vend_csi2 comes, hardware will mis the vend_csi2 and cause internal state machine hang
./driver/camera/camera_reg.h:317: * 1 	   isim_vreset          isim_vreset         RW	    0x1				 active low
./driver/camera/camera_reg.h:652: * 26:16   TRIG_WMARK							  RW 	  0x8			   Trigger wartermark for dvp fifo recommand same as image width
./driver/camera/camera_reg.h:653: * 15:8    TAIL_LEN						    	  RW 	  0x8			   Minimun Tail time for dvp interface
./driver/camera/camera_reg.h:654: * 7:0	   HBLANK_LEN							  RW 	  0x8			   Minimun Hblank time for dvp interface
./driver/camera/dp650_fns.c:147:static void prepare_argb8888_image(uint32_t addr, uint32_t pattern,
./driver/camera/dp650_fns.c:180:    dprint("prepare_argb8888_image: %dx%d stride = 0x%x\n", width, height, *stride);
./driver/camera/dp650_fns.c:721:int32_t draw_images(uint32_t addr_p1, uint32_t *addr_p2, uint32_t *addr_p3,
./driver/camera/dp650_fns.c:729:		dprint("draw_images: not support afbc format!\n");
./driver/camera/dp650_fns.c:734:		prepare_argb8888_image(addr_p1, pattern, width, height, STRIDE_ALIGN, stride_p1);
./driver/camera/dp650_fns.c:735:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/dp650_fns.c:739:	prepare_argb8888_image(TEMP_BUFFER_ADDR, pattern, width, height, 1, &stride_temp);
./driver/camera/dp650_fns.c:740:	dprint("draw_images: temp stride = 0x%x\n", stride_temp);
./driver/camera/dp650_fns.c:744:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/dp650_fns.c:748:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/dp650_fns.c:752:		dprint("draw_images: stride = 0x%x, 0x%x\n", *stride_p1, *stride_p2);
./driver/camera/dp650_fns.c:756:		dprint("draw_images: stride = 0x%x, 0x%x, 0x%x\n", *stride_p1, *stride_p2, *stride_p3);
./driver/camera/dp650_fns.c:760:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/dp650_fns.c:764:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/dp650_fns.c:768:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/dp650_fns.c:772:		dprint("draw_images: stride = 0x%x\n", *stride_p1);
./driver/camera/buf_mgr.h:42:	uint32_t	sizeimage;
./driver/camera/buf_mgr.h:68:int buf_fill_by_img(struct offline_buf *buf);
./driver/camera/camera_test.c:15:void set_addr(uint_32 y_addr/*reg*/, uint_32 start_addr,uint_16 img_width, uint_16 img_height)
./driver/camera/camera_test.c:19:    bbu_printf("set_addr: *****start addr:0x%x,img_width = %d  img_height = %d!!************************\n\r", start_addr,img_width, img_height);
./driver/camera/camera_test.c:27:    memset((volatile uint_8 *)(SW_BASE_REG +start_addr+img_width*img_height), 0x3f, 100);
./driver/camera/camera_test.c:28:    camera_reg_write(u_addr, start_addr+img_width*img_height+HW_BASE_REG); // U Base Addr
./driver/camera/camera_test.c:30:    memset((volatile uint_8 *)(SW_BASE_REG +start_addr+img_width*img_height + img_width*img_height/4), 0x3f, 100);
./driver/camera/camera_test.c:31:    camera_reg_write(v_addr, start_addr+img_width*img_height + img_width*img_height/4+HW_BASE_REG); // V2 Base Addr
./driver/camera/camera_test.c:41:    uint_16 img_width = 0;
./driver/camera/camera_test.c:42:    uint_16 img_height = 0;
./driver/camera/camera_test.c:68:    img_width = width * 4 / scaler_ratio;
./driver/camera/camera_test.c:69:    img_height = height * 4 / scaler_ratio;
./driver/camera/camera_test.c:71:    return img_width | (img_height << 16);
./driver/camera/camera_test.c:114:    memset((volatile uint_8 *)(SW_BASE_REG +0x220000+img_width*img_height), 0x3f, 100);
./driver/camera/camera_test.c:115:    camera_reg_write(0x14, 0x220000+img_width*img_height+HW_BASE_REG); // U2 Base Addr
./driver/camera/camera_test.c:121:    memset((volatile uint_8 *)(SW_BASE_REG +0x220000+img_width*img_height + img_width*img_height/4), 0x3f, 100);
./driver/camera/camera_test.c:122:    camera_reg_write(0x20, 0x220000+img_width*img_height + img_width*img_height/4+HW_BASE_REG); // V2 Base Addr
./driver/camera/camera_test.c:133:    bbu_printf("set_isp_output_image_size: img_width = %d , img_height = %d\n\r", width, height);
./driver/camera/camera_test.c:135:    camera_reg_write(REG_ISP_IMG_SIZE, width+(height<<16));  // image size from isp
./driver/camera/camera_test.c:378:            camera_reg_write(REG_PIP0_CCIC_IMG_PITCH, scaler_output_width*2+(scaler_output_width<<16)); // Pipe 0 image pitch
./driver/camera/camera_test.c:379:            camera_reg_write(REG_IMG_SIZE_PIP0, scaler_output_width*2+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:382:            camera_reg_write(REG_PIP0_CCIC_IMG_PITCH, y_pitch+(y_pitch<<16)); // Pipe 0 image pitch   //yuv420 3planer
./driver/camera/camera_test.c:383:            camera_reg_write(REG_IMG_SIZE_PIP0, scaler_output_width+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:385:            camera_reg_write(REG_PIP0_CCIC_IMG_PITCH, y_pitch+((y_pitch/2)<<16)); // Pipe 0 image pitch   //yuv420 3planer
./driver/camera/camera_test.c:386:            camera_reg_write(REG_IMG_SIZE_PIP0, scaler_output_width+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:390:            camera_reg_write(REG_PIP1_CCIC_IMG_PITCH, scaler_output_width*2+(scaler_output_width<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:391:            camera_reg_write(REG_IMG_SIZE_PIP1, scaler_output_width*2+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:393:            camera_reg_write(REG_PIP1_CCIC_IMG_PITCH, y_pitch+(y_pitch<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:394:            camera_reg_write(REG_IMG_SIZE_PIP1, scaler_output_width+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:396:            camera_reg_write(REG_PIP1_CCIC_IMG_PITCH, y_pitch+((y_pitch/2)<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:397:            camera_reg_write(REG_IMG_SIZE_PIP1, scaler_output_width+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:401:            camera_reg_write(REG_PIP2_CCIC_IMG_PITCH, scaler_output_width*2+(scaler_output_width<<16)); // Pipe 2 image pitch
./driver/camera/camera_test.c:402:            camera_reg_write(REG_IMG_SIZE_PIP2, scaler_output_width*2+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:404:            camera_reg_write(REG_PIP2_CCIC_IMG_PITCH, y_pitch+(y_pitch<<16)); // Pipe 2 image pitch
./driver/camera/camera_test.c:405:            camera_reg_write(REG_IMG_SIZE_PIP2, scaler_output_width+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:407:            camera_reg_write(REG_PIP2_CCIC_IMG_PITCH, y_pitch+((y_pitch/2)<<16)); // Pipe 2 image pitch
./driver/camera/camera_test.c:408:            camera_reg_write(REG_IMG_SIZE_PIP2, scaler_output_width+(scaler_output_height<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:434:    bbu_printf("config_pipe: pipeline%d  img_width = %d , img_height = %d\n\r", pipe_config.pipeline_num, width, height);
./driver/camera/camera_test.c:562:		isp_reg_write(0x084, (data_tmp>>8) & 0x7); // SPI_manual_width=1280 (in bytes)) =  = image_width*2  when YUV422 mode
./driver/camera/camera_test.c:576:		isp_reg_write(0x084, (data_tmp>>8) & 0x7); // SPI_manual_width=1280 (in bytes)) =  = image_width*2  when YUV422 mode
./driver/camera/camera_test.c:791:    unsigned img_width =640;
./driver/camera/camera_test.c:792:    unsigned img_height =480;
./driver/camera/camera_test.c:798:    unsigned h_out_size = img_width;
./driver/camera/camera_test.c:799:    unsigned v_out_size = img_height;
./driver/camera/camera_test.c:821:    h_out_size = img_width;
./driver/camera/camera_test.c:822:    v_out_size = img_height;
./driver/camera/camera_test.c:841:    memset((volatile uint_8 *)(SW_BASE_REG +0x220000+img_width*img_height), 0x3f, 100);
./driver/camera/camera_test.c:842:    camera_reg_write(0x14, 0x220000+img_width*img_height+HW_BASE_REG); // U2 Base Addr
./driver/camera/camera_test.c:848:    memset((volatile uint_8 *)(SW_BASE_REG +0x220000+img_width*img_height + img_width*img_height/4), 0x3f, 100);
./driver/camera/camera_test.c:849:    camera_reg_write(0x20, 0x220000+img_width*img_height + img_width*img_height/4+HW_BASE_REG); // V2 Base Addr
./driver/camera/camera_test.c:852:    camera_reg_write(0x28c, (img_width+(img_height<<16)));  // image size from isp
./driver/camera/camera_test.c:858:    camera_reg_write(0x24, h_out_size*2+(h_out_size<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:859:    camera_reg_write(0x240, h_out_size*2+(h_out_size<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:860:    camera_reg_write(0x244, h_out_size*2+(h_out_size<<16)); // Pipe 2 image pitch
./driver/camera/camera_test.c:863:    camera_reg_write(0x34, h_out_size*2+(v_out_size<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:864:    camera_reg_write(0x284, h_out_size*2+(v_out_size<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:865:    camera_reg_write(0x288, h_out_size*2+(v_out_size<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:868:    camera_reg_write(0x248, img_width<<16); // Pipe 0 ROI X
./driver/camera/camera_test.c:869:    camera_reg_write(0x258, img_width+(img_height<<16)); // Pipe 0 SCALER IN SIZE
./driver/camera/camera_test.c:871:    camera_reg_write(0x268, img_width+(img_height<<16)); // Pipe 1 SCALER IN SIZE
./driver/camera/camera_test.c:874:    camera_reg_write(0x24c, img_height<<16); // Pipe 0 ROI Y
./driver/camera/camera_test.c:875:    camera_reg_write(0x250, img_width<<16); // Pipe 1 ROI X
./driver/camera/camera_test.c:876:    camera_reg_write(0x254, img_height<<16); // Pipe 1 ROI Y
./driver/camera/camera_test.c:882:    camera_reg_write(0x280,   (img_width<<16)+0x80008050); // [7:0] min hblank [26:16] dvp fifo trigger 
./driver/camera/camera_test.c:887:    data_tmp = img_height;
./driver/camera/camera_test.c:890:    isp_reg_write(0x3c, (img_width>>8) & 0x7); // CISCTL_win_width
./driver/camera/camera_test.c:891:    isp_reg_write(0x40, img_width & 0xff);  // CISCTL_win_width
./driver/camera/camera_test.c:898:    data_tmp = img_width *2;
./driver/camera/camera_test.c:899:    isp_reg_write(0x084, (data_tmp>>8) & 0x7); // SPI_manual_width=1280 (in bytes), = image_width*2  when YUV422 mode
./driver/camera/camera_test.c:906:    isp_reg_write(0x08c, (img_height>>8) & 0x7); // SPI_manual_height=80
./driver/camera/camera_test.c:907:    isp_reg_write(0x090, img_height & 0xff);
./driver/camera/camera_test.c:911:    isp_reg_write(0x254, (img_height>>8) & 0x7); // out window height
./driver/camera/camera_test.c:912:    isp_reg_write(0x258, img_height & 0xff);  // out window height
./driver/camera/camera_test.c:913:    isp_reg_write(0x25c, (img_width>>8) & 0x7);  // out window width
./driver/camera/camera_test.c:914:    isp_reg_write(0x260, img_width & 0xff);   // out window width
./driver/camera/camera_test.c:920:    unsigned img_width =640;
./driver/camera/camera_test.c:921:    unsigned img_height =480;
./driver/camera/camera_test.c:926:    unsigned h_out_size = img_width;
./driver/camera/camera_test.c:927:    unsigned v_out_size = img_height;
./driver/camera/camera_test.c:954:    memset((volatile uint_8 *)(SW_BASE_REG +0x220000+img_width*img_height), 0x3f, 100);
./driver/camera/camera_test.c:955:    camera_reg_write(0x14, 0x220000+img_width*img_height+HW_BASE_REG); // U2 Base Addr
./driver/camera/camera_test.c:961:    memset((volatile uint_8 *)(SW_BASE_REG +0x220000+img_width*img_height + img_width*img_height/4), 0x3f, 100);
./driver/camera/camera_test.c:962:    camera_reg_write(0x20, 0x220000+img_width*img_height + img_width*img_height/4+HW_BASE_REG); // V2 Base Addr
./driver/camera/camera_test.c:964:    camera_reg_write(0x28c,   img_width+(img_height<<16));  // image size from isp
./driver/camera/camera_test.c:969:    camera_reg_write(0x24,   y_pitch+(h_out_size<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:970:    camera_reg_write(0x240, y_pitch+(h_out_size<<16)); // Pipe 1 image pitch
./driver/camera/camera_test.c:971:    camera_reg_write(0x244, y_pitch+(h_out_size<<16)); // Pipe 2 image pitch
./driver/camera/camera_test.c:973:    camera_reg_write(0x34,   h_out_size+(v_out_size<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:974:    camera_reg_write(0x284,   h_out_size+(v_out_size<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:975:    camera_reg_write(0x288,   h_out_size+(v_out_size<<16));  // image width by bytes for wdma
./driver/camera/camera_test.c:976:    camera_reg_write(0x248,   img_width<<16); // Pipe 0 ROI X
./driver/camera/camera_test.c:977:    camera_reg_write(0x258,   img_width+(img_height<<16)); // Pipe 0 SCALER IN SIZE
./driver/camera/camera_test.c:979:    camera_reg_write(0x268,   img_width+(img_height<<16)); // Pipe 1 SCALER IN SIZE
./driver/camera/camera_test.c:981:    camera_reg_write(0x24c,   img_height<<16); // Pipe 0 ROI Y
./driver/camera/camera_test.c:982:    camera_reg_write(0x250,   img_width<<16); // Pipe 1 ROI X
./driver/camera/camera_test.c:983:    camera_reg_write(0x254,   img_height<<16); // Pipe 1 ROI Y
./driver/camera/camera_test.c:989:    camera_reg_write(0x280,   (img_width<<16)+0x8050); // [7:0] min hblank [26:16] dvp fifo trigger 
./driver/camera/camera_test.c:992:    data_tmp = img_height+6;
./driver/camera/camera_test.c:995:    isp_reg_write(0x3c,   (img_width>>8) & 0x7); // CISCTL_win_width
./driver/camera/camera_test.c:996:    isp_reg_write(0x40,   img_width & 0xff);  // CISCTL_win_width
./driver/camera/camera_test.c:1002:    data_tmp = img_width;
./driver/camera/camera_test.c:1003:    isp_reg_write(0x084,  (data_tmp>>8) & 0x7); // SPI_manual_width=1280 (in bytes),   = image_width*2  when YUV422 mode
./driver/camera/camera_test.c:1008:    isp_reg_write(0x08c,  (img_height>>8) & 0x7); // SPI_manual_height=80
./driver/camera/camera_test.c:1009:    isp_reg_write(0x090,  img_height & 0xff);
./driver/camera/camera_test.c:1012:    isp_reg_write(0x254,   (img_height>>8) & 0x7); // out window height
./driver/camera/camera_test.c:1013:    isp_reg_write(0x258,   img_height & 0xff);  // out window height
./driver/camera/camera_test.c:1014:    isp_reg_write(0x25c,   (img_width>>8) & 0x7);  // out window width
./driver/camera/camera_test.c:1015:    isp_reg_write(0x260,   img_width & 0xff);   // out window width
./driver/camera/camera_test.c:1020:	unsigned img_width = 640;
./driver/camera/camera_test.c:1021:	unsigned img_height = 480;
./driver/camera/camera_test.c:1026:	unsigned h_out_size = img_width;
./driver/camera/camera_test.c:1027:	unsigned v_out_size = img_height;
./driver/camera/camera_test.c:1053:	camera_reg_write(0x28c, img_width + (img_height << 16));  // image size from isp
./driver/camera/camera_test.c:1060:	camera_reg_write(0x24, y_pitch + (h_out_size << 16));      // Pipe 1 image pitch
./driver/camera/camera_test.c:1061:	camera_reg_write(0x240, y_pitch + (h_out_size << 16));     // Pipe 1 image pitch
./driver/camera/camera_test.c:1062:	camera_reg_write(0x244, y_pitch + (h_out_size << 16));     // Pipe 2 image pitch
./driver/camera/camera_test.c:1064:	camera_reg_write(0x34, h_out_size + (v_out_size << 16));   // image width by bytes for wdma
./driver/camera/camera_test.c:1065:	camera_reg_write(0x284, h_out_size + (v_out_size << 16));  // image width by bytes for wdma
./driver/camera/camera_test.c:1066:	camera_reg_write(0x288, h_out_size + (v_out_size << 16));  // image width by bytes for wdma
./driver/camera/camera_test.c:1067:	camera_reg_write(0x248, img_width << 16);		   // Pipe 0 ROI X
./driver/camera/camera_test.c:1068:	camera_reg_write(0x258, img_width + (img_height << 16));   // Pipe 0 SCALER IN SIZE
./driver/camera/camera_test.c:1070:	camera_reg_write(0x268, img_width + (img_height << 16));   // Pipe 1 SCALER IN SIZE
./driver/camera/camera_test.c:1072:	camera_reg_write(0x24c, img_height << 16);		   // Pipe 0 ROI Y
./driver/camera/camera_test.c:1073:	camera_reg_write(0x250, img_width << 16);		   // Pipe 1 ROI X
./driver/camera/camera_test.c:1074:	camera_reg_write(0x254, img_height << 16);		   // Pipe 1 ROI Y
./driver/camera/camera_test.c:1080:	camera_reg_write(0x280, (img_width << 16) + 0x8050);       // [7:0] min hblank [26:16] dvp fifo trigger
./driver/camera/camera_test.c:1083:	data_tmp = img_height + 6;
./driver/camera/camera_test.c:1086:	isp_reg_write(0x3c, (img_width >> 8) & 0x7);  // CISCTL_win_width
./driver/camera/camera_test.c:1087:	isp_reg_write(0x40, img_width & 0xff);	// CISCTL_win_width
./driver/camera/camera_test.c:1091:	data_tmp = img_width;
./driver/camera/camera_test.c:1093:	isp_reg_write(0x25c, (img_width >> 8) & 0x7);  // out window width
./driver/camera/camera_test.c:1094:	isp_reg_write(0x260, img_width & 0xff);	// out window width
./driver/camera/buf_mgr.c:79:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:87:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:95:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:103:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:111:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:119:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:127:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:135:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:146:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:151:		buf->plane[1].sizeimage = pitch * buf->height / 2;
./driver/camera/buf_mgr.c:160:		buf->plane[0].sizeimage = pitch * buf->height;
./driver/camera/buf_mgr.c:165:		buf->plane[1].sizeimage = pitch * buf->height / 2;
./driver/camera/buf_mgr.c:169:		buf->plane[2].sizeimage = pitch * buf->height / 2;
./driver/camera/buf_mgr.c:227:		buf->plane[1].addr = base + buf->plane[0].sizeimage;
./driver/camera/buf_mgr.c:232:		buf->plane[1].addr = base + buf->plane[0].sizeimage;
./driver/camera/buf_mgr.c:233:		buf->plane[2].addr = base + buf->plane[0].sizeimage + buf->plane[1].sizeimage;
./driver/camera/buf_mgr.c:241:	if ((base < SQU_VALID_ADDR_S) || ((buf->plane[2].addr + buf->plane[2].sizeimage) > SQU_VALID_ADDR_E)) {
./driver/camera/buf_mgr.c:248:	dprint("%s: p1 addr=0x%08x, sizeimage=0x%08x",
./driver/camera/buf_mgr.c:249:			__func__, buf->plane[0].addr, buf->plane[0].sizeimage);
./driver/camera/buf_mgr.c:250:	dprint("%s: p2 addr=0x%08x, sizeimage=0x%08x",
./driver/camera/buf_mgr.c:251:			__func__, buf->plane[1].addr, buf->plane[1].sizeimage);
./driver/camera/buf_mgr.c:252:	dprint("%s: p3 addr=0x%08x, sizeimage=0x%08x",
./driver/camera/buf_mgr.c:253:			__func__, buf->plane[2].addr, buf->plane[2].sizeimage);
./driver/camera/buf_mgr.c:259:int buf_fill_by_img(struct offline_buf *buf)
./driver/camera/buf_mgr.c:304:	dprint("before draw_image!");
./driver/camera/buf_mgr.c:305:	rc = draw_images(buf->plane[0].addr, &(buf->plane[1].addr), &(buf->plane[2].addr), fmt, IMG_PATTERN_VCB_5,
./driver/camera/buf_mgr.c:309:	dprint("after draw_image!");
./driver/camera/buf_mgr.c:328:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:332:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:336:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:340:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:344:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:348:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:352:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:356:		end_addr = start_addr + buf->plane[0].sizeimage - 1;
./driver/camera/buf_mgr.c:361:		end_addr = start_addr + buf->plane[0].sizeimage + buf->plane[1].sizeimage - 1;
./driver/camera/buf_mgr.c:366:		end_addr = start_addr + buf->plane[0].sizeimage + buf->plane[1].sizeimage - 1;
./driver/camera/buf_mgr.c:370:		end_addr = start_addr + buf->plane[0].sizeimage + buf->plane[1].sizeimage + buf->plane[1].sizeimage - 1;
./driver/camera/buf_mgr.c:374:		end_addr = start_addr + buf->plane[0].sizeimage + buf->plane[1].sizeimage + buf->plane[1].sizeimage - 1;
./driver/camera/camera_test.h:95:static uint_32 img_width = SENSOR_WIDTH;
./driver/camera/camera_test.h:96:static uint_32 img_height = SENSOR_HEIGHT;
Binary file ./driver/camera/obj/arm/dp650_fns.o matches
Binary file ./driver/camera/obj/arm/buf_mgr.o matches
Binary file ./driver/camera/obj/arm/scaler_rotation.o matches
Binary file ./driver/camera/obj/arm/camera_test.o matches
./driver/camera/scaler_rotation.c:11:		dprint("multimedia power on!");
./driver/camera/scaler_rotation.c:22:		dprint("multimedia power off!");
./driver/camera/scaler_rotation.c:500:static int ire_parse_input_fmt(uint32_t fmt, uint32_t *img_fmt, uint32_t *yuv422_edian)
./driver/camera/scaler_rotation.c:502:	uint32_t _img_fmt, _yuv422_edian;
./driver/camera/scaler_rotation.c:506:		_img_fmt = IRE_FMT_YUV422;
./driver/camera/scaler_rotation.c:510:		_img_fmt = IRE_FMT_YUV422;
./driver/camera/scaler_rotation.c:514:		_img_fmt = IRE_FMT_YUV422;
./driver/camera/scaler_rotation.c:518:		_img_fmt = IRE_FMT_YUV422;
./driver/camera/scaler_rotation.c:522:		_img_fmt = IRE_FMT_YUV400;
./driver/camera/scaler_rotation.c:529:		_img_fmt = IRE_FMT_YUV420_2PLANAR;
./driver/camera/scaler_rotation.c:534:		_img_fmt = IRE_FMT_YUV420_3PLANAR;
./driver/camera/scaler_rotation.c:538:		_img_fmt = IRE_FMT_RGB888;
./driver/camera/scaler_rotation.c:542:		_img_fmt = IRE_FMT_RGB565;
./driver/camera/scaler_rotation.c:546:		_img_fmt = IRE_FMT_ARGB;
./driver/camera/scaler_rotation.c:554:	dprint("%s: img_fmt = 0x%08x, yuv422_edian = 0x%08x",
./driver/camera/scaler_rotation.c:555:	       __func__, _img_fmt, _yuv422_edian);
./driver/camera/scaler_rotation.c:556:	if (img_fmt)
./driver/camera/scaler_rotation.c:557:		*img_fmt = _img_fmt;
./driver/camera/scaler_rotation.c:604:	uint32_t angle, img_fmt, yuv422_edian;
./driver/camera/scaler_rotation.c:628:	rc = ire_parse_input_fmt(fmt, &img_fmt, &yuv422_edian);
./driver/camera/scaler_rotation.c:634:	val = angle | img_fmt | yuv422_edian;
./driver/camera/dp650_fns.h:18:enum image_pattern
./driver/camera/dp650_fns.h:52:int32_t draw_images(uint32_t addr_p1, uint32_t *addr_p2, uint32_t *addr_p3,
./driver/usb/usb_device/usb_inc/usb_define.h:6:    The copyright notice does not imply publication.
./driver/usb/usb_device/usb_inc/usb_hsic.h:7:#include "timer_dec.h"
./driver/usb/usb_device/usb_inc/usb_hsic.h:52:#include "timer_dec.h"
./driver/usb/usb_device/usb_inc/PlatformConfig.h:39:#include "tim.h"*/
./driver/usb/usb_device/usb_inc/PlatformConfig.h:469:// PJ4 Trimming registers
./driver/usb/usb_device/usb_inc/usb_types.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_device/usb_inc/usb_types.h:10: collectively below as TransDimension, Inc.) 
./driver/usb/usb_device/usb_inc/usb_types.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./driver/usb/usb_device/usb_inc/usb_types.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./driver/usb/usb_device/usb_inc/usb_types.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./driver/usb/usb_device/usb_inc/usb_types.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_device/usb_inc/usb_types.h:41:**  The following typedefs allow us to minimize portability problems
./driver/usb/usb_device/usb_inc/usb_types.h:88:**  the defines of TRUE, FALSE and NULL may sometimes conflict, as most
./driver/usb/usb_device/usb_inc/vusbhs.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_device/usb_inc/vusbhs.h:10: collectively below as TransDimension, Inc.) 
./driver/usb/usb_device/usb_inc/vusbhs.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./driver/usb/usb_device/usb_inc/vusbhs.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./driver/usb/usb_device/usb_inc/vusbhs.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./driver/usb/usb_device/usb_inc/vusbhs.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_device/usb_inc/vusbhs.h:396:	   to reflect change in usbhs4.0  B_HOST_EN has not been used quite some time */
./driver/usb/usb_device/usb_inc/vusbhs.h:655:                                          ** bit 26-16: Maximum packet length
./driver/usb/usb_device/usb_inc/usb_devapi.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_device/usb_inc/usb_devapi.h:10: collectively below as TransDimension, Inc.) 
./driver/usb/usb_device/usb_inc/usb_devapi.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./driver/usb/usb_device/usb_inc/usb_devapi.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./driver/usb/usb_device/usb_inc/usb_devapi.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./driver/usb/usb_device/usb_inc/usb_devapi.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_device/usb_inc/usb_prv_dev.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_device/usb_inc/usb_prv_dev.h:10: collectively below as TransDimension, Inc.) 
./driver/usb/usb_device/usb_inc/usb_prv_dev.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./driver/usb/usb_device/usb_inc/usb_prv_dev.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./driver/usb/usb_device/usb_inc/usb_prv_dev.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./driver/usb/usb_device/usb_inc/usb_prv_dev.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:10: collectively below as TransDimension, Inc.) 
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_device/usb_inc/usb_dev_disk.h:39:#define  TOTAL_LOGICAL_ADDRESS_BLOCKS    20480 //  20480*512=10M ,we assign 10M space to   simulate USB device memory.
./driver/usb/usb_device/usb_inc/usb_wakeup.h:6:#include "timer_dec.h" 
./driver/usb/usb_device/usb_inc/usb_wakeup.h:26://extern void usbvbus_wk_set(uint32_t time_sec) ;
./driver/usb/usb_device/usb_inc/usb_wakeup.h:30://extern void usbID_wk_set(uint32_t time_sec);
./driver/usb/usb_device/usb_inc/usb_wakeup.h:34://extern void usblinestate_wk_set(uint32_t time_sec);
./driver/usb/usb_device/usb_inc/usb_wakeup.h:40:extern  void usb_wk_set(uint_32 time_sec, e_wake_src type);
./driver/usb/usb_device/usb_inc/usb_device.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_device/usb_inc/usb_device.h:10: collectively below as TransDimension, Inc.) 
./driver/usb/usb_device/usb_inc/usb_device.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./driver/usb/usb_device/usb_inc/usb_device.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./driver/usb/usb_device/usb_inc/usb_device.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./driver/usb/usb_device/usb_inc/usb_device.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_intr.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_intr.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_intr.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_intr.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_intr.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_intr.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_intr.c:40:extern uint_32 _usb_ehci_calculate_uframe_tr_time(uint_32, uint_8);
./driver/usb/usb_sph/src/vusbhs_host_intr.c:50:extern void reclaim_band_width(_usb_host_handle,
./driver/usb/usb_sph/src/vusbhs_host_intr.c:323:frames refer to this queue head any more. It is also important to remember
./driver/usb/usb_sph/src/vusbhs_host_intr.c:415:                    reclaim_band_width(
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_cncl.c:260:                the periodic schedule immidiately.
./driver/usb/usb_sph/src/ic_usb.c:183:        /* Process reclaimation */
./driver/usb/usb_sph/src/host_dev_list.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_dev_list.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_dev_list.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_dev_list.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_dev_list.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_dev_list.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_dev_list.c:553:    /* SGarg 09/23/2003 . Sometimes  a detach could come even before a
./driver/usb/usb_sph/src/host_dev_list.c:571:    /* SGarg 09/24/2003 . Sometimes  a detach could come even before a
./driver/usb/usb_sph/src/host_unr.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_unr.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_unr.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_unr.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_unr.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_unr.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_close.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_close.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_close.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_close.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_close.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_close.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/usb_mass_ufi.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/usb_mass_ufi.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/usb_mass_ufi.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/usb_mass_ufi.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/usb_mass_ufi.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/usb_mass_ufi.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/usb_mass_bo.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/usb_mass_bo.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/usb_mass_bo.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/usb_mass_bo.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/usb_mass_bo.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/usb_mass_bo.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/usb_mass_bo.c:190:            ** If queue was empty send CBW to USB immidiately, otherwise it will be
./driver/usb/usb_sph/src/vusbhs_host_shut.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_shut.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_shut.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_shut.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_shut.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_shut.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/usb_mass_queue.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/usb_mass_queue.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/usb_mass_queue.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/usb_mass_queue.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/usb_mass_queue.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/usb_mass_queue.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_bw.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_bw.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_bw.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:56:void reclaim_band_width(_usb_host_handle,
./driver/usb/usb_sph/src/vusbhs_host_bw.c:88:*  Function Name  : _usb_ehci_calculate_uframe_tr_time
./driver/usb/usb_sph/src/vusbhs_host_bw.c:89:*  Returned Value : bus time in nanoseconds or -1 if error
./driver/usb/usb_sph/src/vusbhs_host_bw.c:91:*        Calculate the high speed bus transaction time (USB2.0 Spec 5.11.3)
./driver/usb/usb_sph/src/vusbhs_host_bw.c:93:time is included in this and worst case bt stuffing time is take in to
./driver/usb/usb_sph/src/vusbhs_host_bw.c:97:uint_32 _usb_ehci_calculate_uframe_tr_time (
./driver/usb/usb_sph/src/vusbhs_host_bw.c:106:    uint_32  uframe_tr_time = 0;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:111:    = (55 * 8 * 2.083) + (2.083 * Floor(3.167 + BitStuffTime(Data_bc))) +
./driver/usb/usb_sph/src/vusbhs_host_bw.c:114:    = (38 * 8 * 2.083) + (2.083 * Floor(3.167 + BitStuffTime(Data_bc))) +
./driver/usb/usb_sph/src/vusbhs_host_bw.c:126:        uframe_tr_time = 38 * 8 * 2083 +
./driver/usb/usb_sph/src/vusbhs_host_bw.c:127:                         2083 * ((3167 + BitStuffTime(1000 * bytes)) / 1000) +
./driver/usb/usb_sph/src/vusbhs_host_bw.c:130:        uframe_tr_time = uframe_tr_time / 1000; /*back to nano seconds */
./driver/usb/usb_sph/src/vusbhs_host_bw.c:141:        uframe_tr_time = 55 * 8 * 2083 +
./driver/usb/usb_sph/src/vusbhs_host_bw.c:142:                         2083 * ((3167 + BitStuffTime(1000 * bytes)) / 1000) +
./driver/usb/usb_sph/src/vusbhs_host_bw.c:145:        uframe_tr_time = uframe_tr_time / 1000; /*back to nano seconds */
./driver/usb/usb_sph/src/vusbhs_host_bw.c:151:    convert the times back to micro seconds
./driver/usb/usb_sph/src/vusbhs_host_bw.c:153:    uframe_tr_time = uframe_tr_time / 1000;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:156:    if time is less than 1 micro seconds we take an assumption of 1 Micro sec.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:163:    if (uframe_tr_time < 1)  uframe_tr_time = 1;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:165:    return uframe_tr_time;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:266:    initialze witthin 1 mili second under OTG timing restrictions, this code
./driver/usb/usb_sph/src/vusbhs_host_bw.c:404:    endpoints are limited to specifying only 10 ms to 255 ms. High-speed endpoints can
./driver/usb/usb_sph/src/vusbhs_host_bw.c:467:        It is no simple game as it sounds in the code here. We should consider
./driver/usb/usb_sph/src/vusbhs_host_bw.c:468:        the time taken by the transaction and set the start split and complete
./driver/usb/usb_sph/src/vusbhs_host_bw.c:470:        rules carefully to understand the code simplifying assumptions.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:487:         all CS are scheduled within H7. Simplificationis that we don't want to
./driver/usb/usb_sph/src/vusbhs_host_bw.c:488:         cross the microframe boundry in our implementation of CS.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:509:        5)We take a simplyfying assumption that we budget the transaction
./driver/usb/usb_sph/src/vusbhs_host_bw.c:521:        7)We make a simplyfying assumption that if the trasnaction is not
./driver/usb/usb_sph/src/vusbhs_host_bw.c:584:                case because we want to minimize the number of slots when a complete
./driver/usb/usb_sph/src/vusbhs_host_bw.c:586:                for simplicity. This should be addressed if we run in bandwidth
./driver/usb/usb_sph/src/vusbhs_host_bw.c:600:            send all data (see the data limits on interrupt pipes in comments above).
./driver/usb/usb_sph/src/vusbhs_host_bw.c:601:            We still make a simplifying assumption to schedule SS in Y0-Y3.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:673:    uint_32                             status = USB_OK, time_for_action;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:688:    Here is the important note. We want to keep a record of how much bandwidth
./driver/usb/usb_sph/src/vusbhs_host_bw.c:689:    has been allocated in the periodic list. We use this two dimension array
./driver/usb/usb_sph/src/vusbhs_host_bw.c:692:    It knows how much time has been consumed in each micro frame. We look at
./driver/usb/usb_sph/src/vusbhs_host_bw.c:693:    that time and find if we can allocate this new transfer or not. When a
./driver/usb/usb_sph/src/vusbhs_host_bw.c:696:    to improve the adjusting algorithms so that this array provides the best shot
./driver/usb/usb_sph/src/vusbhs_host_bw.c:697:    for bandwidth but current code does a simple but workable solution for
./driver/usb/usb_sph/src/vusbhs_host_bw.c:721:        Calculate the time required in microseconds for a transaction on this
./driver/usb/usb_sph/src/vusbhs_host_bw.c:722:        pipe. Note that we are scheduling on high speed bus and times are
./driver/usb/usb_sph/src/vusbhs_host_bw.c:726:        time_for_action = _usb_ehci_calculate_uframe_tr_time(
./driver/usb/usb_sph/src/vusbhs_host_bw.c:746:            if ((frame_list_bw_ptr[frame + uframe] + time_for_action) > 100)
./driver/usb/usb_sph/src/vusbhs_host_bw.c:760:    The TT implements a microframe pipeline of split transactions in support of
./driver/usb/usb_sph/src/vusbhs_host_bw.c:762:    before the earliest time that their corresponding full-/lowspeed transaction
./driver/usb/usb_sph/src/vusbhs_host_bw.c:773:        If this pipe takes less than 188 bytes of time, we use lower number to
./driver/usb/usb_sph/src/vusbhs_host_bw.c:774:        save bandwidth time.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:778:            time_for_action = _usb_ehci_calculate_uframe_tr_time(
./driver/usb/usb_sph/src/vusbhs_host_bw.c:785:            time_for_action = _usb_ehci_calculate_uframe_tr_time(
./driver/usb/usb_sph/src/vusbhs_host_bw.c:810:                    if ((frame_list_bw_ptr[i + ss[j] + 1] + time_for_action) > 100)
./driver/usb/usb_sph/src/vusbhs_host_bw.c:831:                    if (((frame_list_bw_ptr[i + ss[j] + 2] + time_for_action) > 100) ||
./driver/usb/usb_sph/src/vusbhs_host_bw.c:832:                            ((frame_list_bw_ptr[i + ss[j] + 3] + time_for_action) > 100) ||
./driver/usb/usb_sph/src/vusbhs_host_bw.c:833:                            ((frame_list_bw_ptr[i + ss[j] + 4] + time_for_action) > 100))
./driver/usb/usb_sph/src/vusbhs_host_bw.c:851:                    if ((frame_list_bw_ptr[i + ss[j] + 1] + time_for_action) > 100)
./driver/usb/usb_sph/src/vusbhs_host_bw.c:868:                    if ((frame_list_bw_ptr[i + j + 1] + time_for_action) > 100)
./driver/usb/usb_sph/src/vusbhs_host_bw.c:889:    store the time for action in the pipe descriptor
./driver/usb/usb_sph/src/vusbhs_host_bw.c:892:    pipe_descr_ptr->BWIDTH = time_for_action;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1070:            frame_list_bw_ptr[frame + uframe] += time_for_action;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1100:                    frame_list_bw_ptr[i + j] += time_for_action;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1238:    time to link with previous data structure.
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1394:*  Function Name  : reclaim_band_width
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1397:*        updates the bandwidth list with released time
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1400:void reclaim_band_width(
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1420:    uint_32                                      time_for_action, uframe_index;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1441:        time_for_action =  pipe_descr_ptr->BWIDTH;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1448:                frame_list_bw_ptr[frame_number + uframe_index] -= time_for_action;
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1504:    nature of the work, this is time consuming part of the code
./driver/usb/usb_sph/src/vusbhs_host_bw.c:1508:    this code will take time when more devices are plugged in.
./driver/usb/usb_sph/src/vusbhs_host_main.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_main.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_main.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_main.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_main.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_main.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_main.c:64:#include "timer_dec.h"
./driver/usb/usb_sph/src/vusbhs_host_main.c:302:    uint_32                       /* clean warning time_for_xaction = 0, */H_bit = 0;
./driver/usb/usb_sph/src/vusbhs_host_main.c:884:        /* Queue head is already on the active list. Simply queue the transfer */
./driver/usb/usb_sph/src/vusbhs_host_main.c:978:            ** starts the timer to count 125 usecs
./driver/usb/usb_sph/src/vusbhs_host_main.c:1004:            ** stops the timer to count 125 usecs
./driver/usb/usb_sph/src/vusbhs_host_main.c:1089:            ** starts the timer to count 125 usecs
./driver/usb/usb_sph/src/vusbhs_host_main.c:1226:    to reset. We take this time to initialize the memory required
./driver/usb/usb_sph/src/vusbhs_host_main.c:1267:    ** stops the timer to count 125 usecs
./driver/usb/usb_sph/src/vusbhs_host_main.c:1434:        /* Process reclaimation */
./driver/usb/usb_sph/src/vusbhs_host_main.c:1608:static void timer_irq(void);
./driver/usb/usb_sph/src/vusbhs_host_main.c:1661:    start_timer(20000, timer_irq, TIMER_PERIODIC);
./driver/usb/usb_sph/src/vusbhs_host_main.c:1674:static void timer_irq(void)
./driver/usb/usb_sph/src/vusbhs_host_main.c:1678:    // bbu_printf("timer irq 20s \r\n ");
./driver/usb/usb_sph/src/vusbhs_host_main.c:2069:    is a two dimensional array with dimension (frame list size x 8 u frames).
./driver/usb/usb_sph/src/vusbhs_host_main.c:2355:*     routine should be improved later. It is needless to search all the lists
./driver/usb/usb_sph/src/vusbhs_host_main.c:2356:*     since interrupt will belong to only one of them at one time.
./driver/usb/usb_sph/src/vusbhs_host_main.c:2849:    /* [IN] time to wait in ms */
./driver/usb/usb_sph/src/vusbhs_host_main.c:2897:    /*On host we should use Frindex to count time.*/
./driver/usb/usb_sph/src/vusbhs_host_main.c:2900:    /* Forced to use OTG timer because no other timer available */
./driver/usb/usb_sph/src/vusbhs_host_main.c:2940:        /* Clear the timer*/
./driver/usb/usb_sph/src/vusbhs_host_main.c:3111:        /* If this ITD is done with all transactions, time to free it */
./driver/usb/usb_sph/src/vusbhs_host_main.c:3286:             Since status is Non active for this SITD, time to delete it.
Binary file ./driver/usb/usb_sph/src/obj/arm/host_ch9.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_bw.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_utl.o matches
./driver/usb/usb_sph/src/obj/arm/vusbhs_host_main.d:49: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/usb/usb_sph/src/obj/arm/vusbhs_host_main.d:58: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_cncl.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_main.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_unr.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_rcv.o matches
./driver/usb/usb_sph/src/obj/arm/ic_usb.d:50: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/usb/usb_sph/src/obj/arm/ic_usb.d:59: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/usb/usb_sph/src/obj/arm/host_common.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/usb_mass_ufi.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_snd.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_close.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_iso.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_main.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_shut.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_shut.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/usb_dev_platform.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/ic_usb.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/host_dev_list.o matches
./driver/usb/usb_sph/src/obj/arm/host_main.d:44: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/usb/usb_sph/src/obj/arm/host_main.d:54: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/usb/usb_sph/src/obj/arm/msc_commands.o matches
./driver/usb/usb_sph/src/obj/arm/msc_commands.d:52: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/usb/usb_sph/src/obj/arm/msc_commands.d:61: /home/feature_phone/crane/driver/timer/clock.h \
./driver/usb/usb_sph/src/obj/arm/msc_commands.d:83: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/usb/usb_sph/src/obj/arm/usb_mass_queue.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/usb_mass_bo.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/vusbhs_host_intr.o matches
Binary file ./driver/usb/usb_sph/src/obj/arm/usb_classes.o matches
./driver/usb/usb_sph/src/usb_classes.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/usb_classes.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/usb_classes.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/usb_classes.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/usb_classes.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/usb_classes.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_rcv.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_rcv.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_rcv.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_rcv.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_rcv.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_rcv.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_rcv.c:114:            /* For isochronous pipe, we are accepting a maximum of MAX_PACKET_SIZE
./driver/usb/usb_sph/src/host_snd.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_snd.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_snd.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_snd.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_snd.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_snd.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_snd.c:182:            /* For isochronous pipes, we transfer a mzximum of MAX_PACKET_SIZE
./driver/usb/usb_sph/src/vusbhs_host_iso.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_iso.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_iso.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_iso.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_iso.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_iso.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/vusbhs_host_iso.c:463:        or more than mutiple bandwidth factor times the Max packet size */
./driver/usb/usb_sph/src/vusbhs_host_iso.c:646:    Notice that the following could be a time consuming line if number of
./driver/usb/usb_sph/src/vusbhs_host_iso.c:672:    Full speed devices have a minimum frequency of 1 mili second so 1 SITD can
./driver/usb/usb_sph/src/vusbhs_host_iso.c:1314:                    reclaim_band_width(handle,
./driver/usb/usb_sph/src/host_ch9.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_ch9.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_ch9.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_ch9.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_ch9.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_ch9.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_ch9.c:194:        /* We can only read one config descriptor at a time */
./driver/usb/usb_sph/src/host_ch9.c:380:*     This code does minimal error checking, on the assumption
./driver/usb/usb_sph/src/host_shut.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_shut.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_shut.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_shut.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_shut.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_shut.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_main.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_main.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_main.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_main.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_main.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_main.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_main.c:59:    /* [IN] maximum number of Pipes */
./driver/usb/usb_sph/src/host_main.c:386:*  endpoint number, direction of transfer, maximum packet size, interval
./driver/usb/usb_sph/src/host_main.c:807:        For data caching it is important that we update the memory
./driver/usb/usb_sph/src/host_main.c:877:    For data caching it is important that we update the memory
./driver/usb/usb_sph/src/host_common.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/host_common.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/host_common.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/host_common.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/host_common.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/host_common.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/host_common.c:246:*        detached.  At that time, these are all freed by the system.
./driver/usb/usb_sph/src/host_common.c:476:    **    descriptor at a time.                               **
./driver/usb/usb_sph/src/vusbhs_host_utl.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/vusbhs_host_utl.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/vusbhs_host_utl.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/vusbhs_host_utl.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/vusbhs_host_utl.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/vusbhs_host_utl.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/msc_commands.c:7: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/src/msc_commands.c:8: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/src/msc_commands.c:9: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/src/msc_commands.c:14: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/src/msc_commands.c:18: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/src/msc_commands.c:22: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/src/msc_commands.c:1288:void simple_test_hsic_speed(void)
./driver/usb/usb_sph/src/msc_commands.c:1293:    uint_32 time_start = 0, time_end = 0;
./driver/usb/usb_sph/src/msc_commands.c:1318:        time_start = bbu_get_msec();
./driver/usb/usb_sph/src/msc_commands.c:1334:        time_end = bbu_get_msec();
./driver/usb/usb_sph/src/msc_commands.c:1335:        result = (64 * 1000) / (time_end - time_start);
./driver/usb/usb_sph/src/msc_commands.c:1336:        bbu_printf("time  is %d ms\r\n", (time_end - time_start));
./driver/usb/usb_sph/src/msc_commands.c:1341:        time_start = bbu_get_msec();
./driver/usb/usb_sph/src/msc_commands.c:1358:        time_end = bbu_get_msec();
./driver/usb/usb_sph/src/msc_commands.c:1359:        bbu_printf("time  is %d ms\r\n", (time_end - time_start));
./driver/usb/usb_sph/src/msc_commands.c:1361:        result = (64 * 1000) / (time_end - time_start);
./driver/usb/usb_sph/src/msc_commands.c:1741:        simple_test_hsic_speed();
./driver/usb/usb_sph/inc/host_dev_list.h:10: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/host_dev_list.h:11: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/host_dev_list.h:12: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/host_dev_list.h:17: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/host_dev_list.h:21: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/host_dev_list.h:25: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/msc_commands.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/msc_commands.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/msc_commands.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/msc_commands.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/msc_commands.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/msc_commands.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usb_desc.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usb_desc.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usb_desc.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usb_desc.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usb_desc.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usb_desc.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/vusbhs.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/vusbhs.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/vusbhs.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/vusbhs.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/vusbhs.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/vusbhs.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/vusbhs.h:395:   to reflect change in usbhs4.0  B_HOST_EN has not been used quite some time */
./driver/usb/usb_sph/inc/vusbhs.h:665:                                          ** bit 26-16: Maximum packet length
./driver/usb/usb_sph/inc/host_ch9.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/host_ch9.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/host_ch9.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/host_ch9.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/host_ch9.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/host_ch9.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usb_dec.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usb_dec.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usb_dec.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usb_dec.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usb_dec.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usb_dec.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usbprv_host.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usbprv_host.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usbprv_host.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usbprv_host.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usbprv_host.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usbprv_host.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usbprv_host.h:64:#define  BitStuffTime(x)                     (7* 8 * x / 6)
./driver/usb/usb_sph/inc/usbprv_host.h:130:    uint_16              BWIDTH;         /* time take by this pipe (for periodic pipes only */
./driver/usb/usb_sph/inc/usb_mass_version.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usb_mass_version.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usb_mass_version.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usb_mass_version.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usb_mass_version.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usb_mass_version.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usbprv.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usbprv.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usbprv.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usbprv.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usbprv.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usbprv.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usbprv.h:41:implementation of USB_memalloc routine which aligns
./driver/usb/usb_sph/inc/host_common.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/host_common.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/host_common.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/host_common.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/host_common.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/host_common.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/host_common.h:220:    uint_32     MAX_PACKET_SIZE;    /* Pipe's maximum packet size for sending or receiving.   */ \
./driver/usb/usb_sph/inc/host_common.h:221:    uint_32     NAK_COUNT;          /* The maximum number of NAK   */ \
./driver/usb/usb_sph/inc/usb_mass_bo.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usb_mass_bo.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usb_mass_bo.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usb_mass_bo.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usb_mass_bo.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usb_mass_bo.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usb_mass_bo.h:219:    uint_8                            RETRY_COUNT;   /* Number of times this commad tried  */
./driver/usb/usb_sph/inc/usb_mass_ufi.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usb_mass_ufi.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usb_mass_ufi.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usb_mass_ufi.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usb_mass_ufi.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usb_mass_ufi.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usb_mass_ufi.h:28:*** This file is a supporting header file for UFI.c which implements the UFI
./driver/usb/usb_sph/inc/hostapi.h:10: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/hostapi.h:11: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/hostapi.h:12: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/hostapi.h:17: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/hostapi.h:21: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/hostapi.h:25: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usbtypes.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./driver/usb/usb_sph/inc/usbtypes.h:10: collectively below as TransDimension, Inc.)
./driver/usb/usb_sph/inc/usbtypes.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./driver/usb/usb_sph/inc/usbtypes.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./driver/usb/usb_sph/inc/usbtypes.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./driver/usb/usb_sph/inc/usbtypes.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./driver/usb/usb_sph/inc/usbtypes.h:41:**  The following typedefs allow us to minimize portability problems
./driver/usb/usb_sph/inc/usbtypes.h:76:**  the defines of TRUE, FALSE and NULL may sometimes conflict, as most
./driver/amp/mrvl_amp.c:5:#include "timer_dec.h"
./driver/amp/mrvl_amp.c:7:#include "tim.h"
./driver/amp/mrvl_amp.c:65:       Currently, the load address of CR5 image is 0x100000,
./driver/amp/mrvl_amp.c:114:    /* When BBU is burnt to flash, check tim to decide if need to release CR5
./driver/amp/mrvl_amp.c:116:    TIM tim;
./driver/amp/mrvl_amp.c:117:    int imageNum, imageSize, i;
./driver/amp/mrvl_amp.c:128:    SetTIMPointers(0xd1000000, &tim);
./driver/amp/mrvl_amp.c:129:    imageNum = get_image_number(&tim);
./driver/amp/mrvl_amp.c:130:    if(imageNum < 4){
./driver/amp/mrvl_amp.c:131:       //BBU which contains CR5 has 4 images at least
./driver/amp/mrvl_amp.c:132:       bbu_printf("CR5 won't be release as only %d images are found\n\r"BBU_PROMPT, imageNum);
./driver/amp/mrvl_amp.c:135:    for(i = 0; i < imageNum; i++){
./driver/amp/mrvl_amp.c:136:       pImage = ReturnPImgPtr(&tim, i);
./driver/amp/mrvl_amp.c:141:    if(i == imageNum){
./driver/amp/mrvl_amp.c:142:        bbu_printf("CR5 won't be release as its image is not found\n\r"BBU_PROMPT);
./driver/amp/mrvl_amp.c:145:        imageSize = pImage->ImageSize;
./driver/amp/mrvl_amp.c:146:        if(imageSize < 0x80000){
./driver/amp/mrvl_amp.c:147:           bbu_printf("CR5 won't be release as its image is invalid\n\r"BBU_PROMPT);
./driver/amp/mrvl_amp.c:153:    uint32_t time_out = 0x4000;
./driver/amp/mrvl_amp.c:170:        while(time_out--){
./driver/amp/mrvl_amp.c:174:                start_specific_timer(0, cp_assert_ap_handler, TIMER_ONE_SHOT, 0, 0, 1, TIMER_CLK_13M);
./driver/amp/mrvl_amp.c:181:        bbu_printf("ERROR: Fail to release Seagull in time\n\r");
./driver/amp/mrvl_amp.c:194:    bbu_printf(" <load_addr> : DDR address the CP image is at, default is 0x100000\n\r");
./driver/amp/mrvl_amp.c:232:static void cp_assert_timer_handler(void *argv)
./driver/amp/mrvl_amp.c:234:    bbu_printf("\n\n\rCP: Assert, arm timer to inform AP to reset itself\n\r");
./driver/amp/mrvl_amp.c:235:    start_specific_timer(500, 0, TIMER_ONE_SHOT, 0, 0, 1, TIMER_CLK_13M);
./driver/amp/mrvl_amp.c:242:    start_timer(100, cp_assert_timer_handler, TIMER_ONE_SHOT);
./driver/amp/obj/arm/mrvl_amp.d:37: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/amp/obj/arm/mrvl_amp.d:40: /home/feature_phone/crane/driver/timer/clock.h \
./driver/amp/obj/arm/mrvl_amp.d:42: /home/feature_phone/crane/driver/common/tim.h \
Binary file ./driver/amp/obj/arm/mrvl_amp.o matches
./driver/lcd/lcd_gc9305_spi.c:3:#include "timer_dec.h"
./driver/lcd/lcd_gc9305_spi.c:322:static struct timing_spi lcd_gc9305_spi_timing = {
./driver/lcd/lcd_gc9305_spi.c:336:	.timing = &lcd_gc9305_spi_timing,
./driver/lcd/lcd_hal.c:2:#include "timer_dec.h"
./driver/lcd/lcd_drv.c:4:#include "timer_dec.h"
./driver/lcd/lcd_drv.c:319:static void lcd_config_img(struct s_lcd_ctx *lcd_ctx)
./driver/lcd/lcd_drv.c:477:	lcd_config_img(lcd_ctx);
./driver/lcd/mcu_drv.h:37:struct timing_mcu {
./driver/lcd/mcu_drv.h:51:	struct timing_mcu *timing;
./driver/lcd/lcd_reg.h:57:/*image layer*/
./driver/lcd/dummy_spi.c:30:static struct timing_spi lcd_dummy_spi_timing = {
./driver/lcd/dummy_spi.c:44:	.timing = &lcd_dummy_spi_timing,
./driver/lcd/dummy_mcu.c:30:static struct timing_mcu lcd_dummy_mcu_timing = {
./driver/lcd/dummy_mcu.c:43:	.timing = &lcd_dummy_mcu_timing,
./driver/lcd/lcd_fns.c:184:static void prepare_argb8888_image(uint32_t addr, uint32_t pattern,
./driver/lcd/lcd_fns.c:216:	bbu_printf("prepare_argb8888_image: stride = 0x%x\r\n", *stride);
./driver/lcd/lcd_fns.c:608:int32_t lcd_draw_images(uint32_t addr_p1, uint32_t *addr_p2, uint32_t *addr_p3,
./driver/lcd/lcd_fns.c:616:		prepare_argb8888_image(addr_p1, pattern, width, height, STRIDE_ALIGN, stride_p1);
./driver/lcd/lcd_fns.c:617:		bbu_printf("draw_images: stride = 0x%x\r\n", *stride_p1);
./driver/lcd/lcd_fns.c:621:	prepare_argb8888_image(TEMP_BUFFER_ADDR, pattern, width, height, 1, &stride_temp);
./driver/lcd/lcd_fns.c:622:	bbu_printf("draw_images: temp stride = 0x%x\r\n", stride_temp);
./driver/lcd/lcd_fns.c:626:		bbu_printf("draw_images: stride = 0x%x\r\n", *stride_p1);
./driver/lcd/lcd_fns.c:630:		bbu_printf("draw_images: stride = 0x%x\r\n", *stride_p1);
./driver/lcd/lcd_fns.c:634:		bbu_printf("draw_images: stride = 0x%x\r\n", *stride_p1);
./driver/lcd/lcd_fns.c:639:		bbu_printf("draw_images: stride = 0x%x, 0x%x\r\n", *stride_p1, *stride_p2);
./driver/lcd/lcd_fns.c:644:		bbu_printf("draw_images: stride = 0x%x, 0x%x, 0x%x\r\n", *stride_p1, *stride_p2, *stride_p3);
./driver/lcd/lcd_fns.c:649:		bbu_printf("draw_images: stride = 0x%x, 0x%x, 0x%x\r\n", *stride_p1, *stride_p2, *stride_p3);
./driver/lcd/lcd_fns.c:654:		bbu_printf("draw_images: stride = 0x%x\r\n", *stride_p1);
./driver/lcd/lcd_fns.c:659:		bbu_printf("draw_images: stride = 0x%x\r\n", *stride_p1);
./driver/lcd/lcd_fns.c:662:		bbu_printf("draw_images: Unsupport formate = %d\r\n", format);
./driver/lcd/spi_drv.c:4:#include "timer_dec.h"
./driver/lcd/spi_drv.c:53:	if(info == NULL || info->timing == NULL){
./driver/lcd/spi_drv.c:64:	dividor = sclk/info->timing->rclk;
./driver/lcd/spi_drv.c:66:		bbu_printf("ERROR: spi_init, Invalid read timing!\r\n");
./driver/lcd/spi_drv.c:70:	dividor = sclk/info->timing->wclk;
./driver/lcd/spi_drv.c:72:		bbu_printf("ERROR: spi_init, Invalid write timing!\r\n");
./driver/lcd/spi_drv.c:115:	/*spi need open mcu, otherwidth can't send image data*/
./driver/lcd/spi_drv.c:147:	ret = set_spi_clk(sclk, info->timing->wclk);
./driver/lcd/spi_drv.c:301:	ret = set_spi_clk(spi_ctx->sclk, spi_ctx->info.timing->rclk);
./driver/lcd/spi_drv.c:336:	ret = set_spi_clk(spi_ctx->sclk, spi_ctx->info.timing->wclk);
./driver/lcd/obj/arm/panel_drv.d:9: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/panel_drv.d:40: /home/feature_phone/crane/driver/timer/clock.h \
./driver/lcd/obj/arm/mcu_drv.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/mcu_drv.d:37: /home/feature_phone/crane/driver/timer/clock.h
./driver/lcd/obj/arm/lcd_gc9305_spi.d:7: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/lcd_gc9305_spi.d:38: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/lcd/obj/arm/dummy_mcu.o matches
Binary file ./driver/lcd/obj/arm/lcd_gc9305_mcu.o matches
./driver/lcd/obj/arm/lcd_gc9305_mcu.d:7: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/lcd_gc9305_mcu.d:38: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./driver/lcd/obj/arm/lcd_fns.o matches
Binary file ./driver/lcd/obj/arm/lcd_drv.o matches
Binary file ./driver/lcd/obj/arm/lcd_gc9305_spi.o matches
Binary file ./driver/lcd/obj/arm/panel_drv.o matches
Binary file ./driver/lcd/obj/arm/lcd_hal.o matches
./driver/lcd/obj/arm/lcd_drv.d:9: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/lcd_drv.d:40: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/lcd/obj/arm/dummy_spi.o matches
Binary file ./driver/lcd/obj/arm/spi_drv.o matches
./driver/lcd/obj/arm/spi_drv.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/spi_drv.d:37: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./driver/lcd/obj/arm/mcu_drv.o matches
./driver/lcd/obj/arm/lcd_hal.d:4: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/lcd/obj/arm/lcd_hal.d:35: /home/feature_phone/crane/driver/timer/clock.h
./driver/lcd/mcu_drv.c:4:#include "timer_dec.h"
./driver/lcd/mcu_drv.c:35:	if(info == NULL || info->timing == NULL){
./driver/lcd/mcu_drv.c:41:	rl = (info->timing->rlpw + scycle - 1) / scycle - 1;
./driver/lcd/mcu_drv.c:42:	rh = (info->timing->rhpw + scycle - 1) / scycle - 1;
./driver/lcd/mcu_drv.c:43:	wl = (info->timing->wlpw + scycle - 1) / scycle - 1;
./driver/lcd/mcu_drv.c:44:	wh = (info->timing->whpw + scycle - 1) / scycle - 1;
./driver/lcd/panel_drv.c:5:#include "timer_dec.h"
./driver/lcd/spi_drv.h:40:struct timing_spi {
./driver/lcd/spi_drv.h:55:	struct timing_spi *timing;
./driver/lcd/lcd_gc9305_mcu.c:3:#include "timer_dec.h"
./driver/lcd/lcd_gc9305_mcu.c:261:static struct timing_mcu lcd_gc9305_mcu_timing = {
./driver/lcd/lcd_gc9305_mcu.c:274:	.timing = &lcd_gc9305_mcu_timing,
./driver/lcd/lcd_fns.h:9:enum image_pattern
./driver/lcd/lcd_fns.h:27:int32_t lcd_draw_images(uint32_t addr_p1, uint32_t *addr_p2, uint32_t *addr_p3,
Binary file ./driver/i2c/obj/arm/i2c_dec.o matches
./driver/i2c/obj/arm/i2c_dec.d:34: /home/feature_phone/crane/driver/timer/timer_dec.h \
./driver/i2c/obj/arm/i2c_dec.d:37: /home/feature_phone/crane/driver/timer/clock.h \
./driver/i2c/i2c_dec.c:16:#include "timer_dec.h"
./driver/i2c/i2c_dec.c:194:   int time_out = 10;
./driver/i2c/i2c_dec.c:195:   while(time_out){
./driver/i2c/i2c_dec.c:198:         time_out -- ;
./driver/i2c/i2c_dec.c:753:   uint32_t timeout;
./driver/i2c/i2c_dec.c:761:      timeout = 0x4000;
./driver/i2c/i2c_dec.c:765:            timeout--;
./driver/i2c/i2c_dec.c:766:         if(timeout <= 0){
./driver/i2c/i2c_dec.c:768:               bbu_printf("I2C Timeout!\n\r");
./driver/i2c/i2c_dec.c:786:   timeout = 0x4000;
./driver/i2c/i2c_dec.c:790:         timeout--;
./driver/i2c/i2c_dec.c:791:      if(timeout <= 0){
./driver/i2c/i2c_dec.c:793:            bbu_printf("I2C Timeout!\n\r");
./driver/i2c/i2c_dec.c:821:   uint32_t timeout;
./driver/i2c/i2c_dec.c:841:   timeout = 0x4000;
./driver/i2c/i2c_dec.c:845:      timeout--;
./driver/i2c/i2c_dec.c:846:      if (timeout <= 0) {
./driver/i2c/i2c_dec.c:848:            bbu_printf("I2C timeout!\n\r");
./driver/i2c/i2c_dec.c:866:   uint32_t timeout;
./driver/i2c/i2c_dec.c:879:   timeout = 0x4000;
./driver/i2c/i2c_dec.c:883:         timeout--;
./driver/i2c/i2c_dec.c:884:      if(timeout <= 0){
./driver/i2c/i2c_dec.c:886:            bbu_printf("I2C Timeout!\n\r");
./driver/i2c/i2c_dec.c:906:   uint32_t timeout;
./driver/i2c/i2c_dec.c:919:   timeout = 0x4000;
./driver/i2c/i2c_dec.c:924:      timeout--;
./driver/i2c/i2c_dec.c:925:      if(timeout <= 0){
./driver/i2c/i2c_dec.c:927:            bbu_printf("I2C Timeout!\n\r");
./driver/i2c/i2c_dec.c:947:   uint32_t timeout;
./driver/i2c/i2c_dec.c:957:   timeout = 0x4000;
./driver/i2c/i2c_dec.c:961:      timeout--;
./driver/i2c/i2c_dec.c:962:      if (timeout <= 0) {
./driver/i2c/i2c_dec.c:964:            bbu_printf("I2C timeout!\n\r");
./driver/i2c/i2c_dec.c:986:   uint32_t timeout;
./driver/i2c/i2c_dec.c:998:   timeout = 0x4000;
./driver/i2c/i2c_dec.c:1003:      timeout--;
./driver/i2c/i2c_dec.c:1004:      if (timeout <= 0) {
./driver/i2c/i2c_dec.c:1006:            bbu_printf("I2C timeout!\n\r");
./driver/i2c/i2c_dec.c:1356:        volatile uint32_t timeout;
./driver/i2c/i2c_dec.c:1364:        timeout = 0x4000;
./driver/i2c/i2c_dec.c:1368:	        timeout--;
./driver/i2c/i2c_dec.c:1369:	        if(timeout <= 0){
./driver/i2c/i2c_dec.c:1393:	        bbu_printf("wi2c--> I2C bus time out. No device at address 0x%02X\n\r on I2C %d",slave_addr, i2c_index);
./driver/i2c/i2c_dec.c:1407:	        bbu_printf("ri2c--> I2C bus time out. No device at address 0x%02X on I2C %d\n\r",slave_addr, i2c_index);
./conf/bbu.conf:28:#CONFIG_DBG enable real time printing to UART, however interrupt may cause print out of order.
./conf/bbu.conf:31:#QK kernel preemption is similar to interrupt, so recommend to debug with Vanilla kernel.
./conf/bbu.conf:45:#You can enable QK kernel if necessary, in a good design, Vanilla kernel should be enough and it's simple.
./conf/bbu.conf:49:#switch the OS tick among three kind of timers
./conf/bbu.conf:50:#for now, we use APB timers, if neither is defined, it will use SOC generic timer 
./Rules.mk:13:	echo "\#define btime \"`date +%Y-%m-%d:%H:%M:%S`\"" > $(TOP)/bbuinfo.h)
./Rules.mk:188:# vim: set ft=make :
./nano/driver/uart/uart.c:121:    /* Receiver Data Available and timeout Interrupt Enable */  
./nano/driver/pmic/ustica.h:205:* Function     :    ustica_get_start_ramp_time_setting
./nano/driver/pmic/ustica.h:209:                    start ramping time
./nano/driver/pmic/ustica.h:210:* Parameters   :    ramp_time: 112 ~ 14336us
./nano/driver/pmic/ustica.h:215:uint8_t ustica_get_start_ramp_time_setting(int ramp_time);
./nano/driver/pmic/ustica_nop.c:5:#include "timer_dec.h"
./nano/driver/pmic/ustica_nop.c:315:* Function     :    ustica_get_start_ramp_time_setting
./nano/driver/pmic/ustica_nop.c:319:                    start ramping time
./nano/driver/pmic/ustica_nop.c:320:* Parameters   :    ramp_time: 112 ~ 14336us
./nano/driver/pmic/ustica_nop.c:325:uint8_t ustica_get_start_ramp_time_setting(int ramp_time)
./nano/driver/pmic/ustica_nop.c:327:   (void)ramp_time;
./nano/driver/pmic/ustica.c:4:#include "timer_dec.h"
./nano/driver/pmic/ustica.c:728:* Function     :    ustica_get_start_ramp_time_setting
./nano/driver/pmic/ustica.c:732:                    start ramping time
./nano/driver/pmic/ustica.c:733:* Parameters   :    ramp_time: 112 ~ 14336us
./nano/driver/pmic/ustica.c:738:uint8_t ustica_get_start_ramp_time_setting(int ramp_time)
./nano/driver/pmic/ustica.c:742:      if(ramp_time < 112 || ramp_time > 14336)
./nano/driver/pmic/ustica.c:744:      if(ramp_time >= 112 && ramp_time < 224)          setting = 0x0;
./nano/driver/pmic/ustica.c:745:      else if(ramp_time >= 224 && ramp_time < 448)     setting = 0x1;
./nano/driver/pmic/ustica.c:746:      else if(ramp_time >= 448 && ramp_time < 896)     setting = 0x2;
./nano/driver/pmic/ustica.c:747:      else if(ramp_time >= 896 && ramp_time < 1792)    setting = 0x3;
./nano/driver/pmic/ustica.c:748:      else if(ramp_time >= 1792 && ramp_time < 3584)   setting = 0x4;
./nano/driver/pmic/ustica.c:749:      else if(ramp_time >= 3584 && ramp_time < 7168)   setting = 0x5;
./nano/driver/pmic/ustica.c:750:      else if(ramp_time >= 7168 && ramp_time < 14336)  setting = 0x6;
./nano/driver/pmic/ustica.c:751:      else if(ramp_time >= 14336)                      setting = 0x7;
./nano/driver/pmic/ustica.c:752:      else bbu_printf("Procida: the ramp time is out of range\n\r");
./nano/driver/pmic/procida.c:5:#include "timer_dec.h"
./nano/driver/pmic/procida.h:601:* Function     :    procida_get_start_ramp_time_setting
./nano/driver/pmic/procida.h:605:                    start ramping time
./nano/driver/pmic/procida.h:606:* Parameters   :    ramp_time: 112 ~ 14336us
./nano/driver/pmic/procida.h:666:* Description  :    enable/disable the LVSW 30mA current limit
./nano/driver/pmic/procida.h:674:void procida_lvsw_30mA_limit_enable_disable(int enable_disable);
./nano/driver/pmic/procida.h:677:uint8_t procida_get_start_ramp_time_setting(int ramp_time);
./nano/driver/usb_nano/usb_define.h:6:    The copyright notice does not imply publication.
./nano/driver/usb_nano/usb_serial.c:34:#include "timer_dec.h"
./nano/driver/usb_nano/usb_serial.c:342:at compile time and boot sector array is just provided for example
./nano/driver/usb_nano/usb_serial.c:382:    before priming for the status stage.*/
./nano/driver/usb_nano/usb_serial.c:925:static uint8_t SetLine_Time = 0;
./nano/driver/usb_nano/usb_serial.c:1033:                SetLine_Time++;
./nano/driver/usb_nano/usb_serial.c:1038:            if (SetLine_Time > 1)
./nano/driver/usb_nano/usb_serial.c:1098:                SetLine_Time = 0;
./nano/driver/usb_nano/usb_serial.c:1774:    int i = 0, timeout = 0x40000;
./nano/driver/usb_nano/usb_serial.c:1787:    while (i < timeout)
./nano/driver/usb_nano/usb_types.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./nano/driver/usb_nano/usb_types.h:10: collectively below as TransDimension, Inc.) 
./nano/driver/usb_nano/usb_types.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./nano/driver/usb_nano/usb_types.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./nano/driver/usb_nano/usb_types.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./nano/driver/usb_nano/usb_types.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./nano/driver/usb_nano/usb_types.h:41:**  The following typedefs allow us to minimize portability problems
./nano/driver/usb_nano/usb_types.h:85:**  the defines of TRUE, FALSE and NULL may sometimes conflict, as most
./nano/driver/usb_nano/vusbhs.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./nano/driver/usb_nano/vusbhs.h:10: collectively below as TransDimension, Inc.)
./nano/driver/usb_nano/vusbhs.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./nano/driver/usb_nano/vusbhs.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./nano/driver/usb_nano/vusbhs.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./nano/driver/usb_nano/vusbhs.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./nano/driver/usb_nano/vusbhs.h:395:   to reflect change in usbhs4.0  B_HOST_EN has not been used quite some time */
./nano/driver/usb_nano/vusbhs.h:666:                                          ** bit 26-16: Maximum packet length
./nano/driver/usb_nano/usb_dev_main.c:2:#include "timer_dec.h"
./nano/driver/usb_nano/usb_dev_main.c:194:      // Limiting USB burst length to 8. AXI2MC module used in Wukong-Y0 does not support 16.
./nano/driver/usb_nano/usb_dev_main.c:853:    For a optimal implementation, we need to detect the fact that
./nano/driver/usb_nano/usb_dev_main.c:921:        eliminitate this approach and switch back to USB_memzero().
./nano/driver/usb_nano/usb_dev_main.c:1013:    However endpoint has not been primed yet. If list is not empty we need safter ways to add DTD to the
./nano/driver/usb_nano/usb_dev_main.c:1026:        Check the prime bit. If set goto done
./nano/driver/usb_nano/usb_dev_main.c:1056:            else we remain set to 1 and we can proceed with priming
./nano/driver/usb_nano/usb_dev_main.c:1057:            of endpoint if not already primed.
./nano/driver/usb_nano/usb_dev_main.c:1087:            /* Prime the Endpoint */
./nano/driver/usb_nano/usb_dev_main.c:1095:        /* Prime the Endpoint */
./nano/driver/usb_nano/usb_dev_main.c:1115:                /* The endpoint was not not primed so no other transfers on
./nano/driver/usb_nano/usb_dev_main.c:1131:        /* Prime the Endpoint */
./nano/driver/usb_nano/usb_dev_main.c:1144:        /* Prime the Endpoint */
./nano/driver/usb_nano/usb_dev_main.c:2155:    completed. Since 2 mili second may be a very small time window
./nano/driver/usb_nano/usb_dev_main.c:2163:    at hardware rev details for the implementation of this
./nano/driver/usb_nano/usb_dev_main.c:2235:    CR 1219. Hardware versions 2.3+ have a implementation of tripwire
./nano/driver/usb_nano/usb_dev_main.c:2360:    /* Check if the Endpoint is Primed
./nano/driver/usb_nano/bbu_usb.h:314:#define  VUSB_EP_MAX_LENGTH_TRANSFER               (0x4000) //The maximum recommended transfer size for one dTD is 16K, for 5 pages locate.
./nano/driver/usb_nano/usb_devapi.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./nano/driver/usb_nano/usb_devapi.h:10: collectively below as TransDimension, Inc.) 
./nano/driver/usb_nano/usb_devapi.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc. 
./nano/driver/usb_nano/usb_devapi.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use, 
./nano/driver/usb_nano/usb_devapi.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.  
./nano/driver/usb_nano/usb_devapi.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./nano/driver/usb_nano/usb_dev_data.c:239:            ** limit request to maxPacket
./nano/driver/usb_nano/usb_dev_data.c:440:            ** limit request to maxPacket
./nano/driver/usb_nano/usb_dev_data.c:679:                /* Prime the Endpoint */
./nano/driver/usb_nano/usb_dev_data.c:692:                        /* The endpoint was not not primed so no other transfers on
./nano/driver/usb_nano/usb_dev_data.c:707:                /* Prime the Endpoint */
./nano/driver/usb_nano/usb_prv_dev.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./nano/driver/usb_nano/usb_prv_dev.h:10: collectively below as TransDimension, Inc.)
./nano/driver/usb_nano/usb_prv_dev.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./nano/driver/usb_nano/usb_prv_dev.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./nano/driver/usb_nano/usb_prv_dev.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./nano/driver/usb_nano/usb_prv_dev.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./nano/driver/usb_nano/usb_device.h:9: (TransDimension, Inc. and SoftConnex Technologies, Inc. are referred to
./nano/driver/usb_nano/usb_device.h:10: collectively below as TransDimension, Inc.)
./nano/driver/usb_nano/usb_device.h:11: Copyright (c) 1999 - 2004 by TransDimension, Inc.
./nano/driver/usb_nano/usb_device.h:16: constituting TRADE SECRETS of TransDimension, Inc..  Any unauthorized use,
./nano/driver/usb_nano/usb_device.h:20: consent of, and license from, TransDimension, Inc. is strictly prohibited.
./nano/driver/usb_nano/usb_device.h:24: or criminal penalties, and will be prosecuted to the maximum extent of the law.
./nano/driver/pmu/ppset.c:10:#include "timer_dec.h"
./nano/driver/pmu/ppset.c:29:static uint32_t verbose_off = 0; //0: with more logs, 1: no logs to make test stress/save-time.
./nano/driver/pmu/ppset.c:74://General rules in DE's timing requirement is axi_m1=1/2pclk, axi_m0=1/4pclk
./nano/driver/pmu/ppset.c:109://Note: if we change DDR OP define, we should change gc_aclk OP define at the same time
./nano/driver/pmu/ppset.c:880:     The time gap between the write response of FCCR and the exact update of FCCR is more than six 26MHz cycles.
./nano/driver/pmu/ppset.c:915:    //BIT1 is set at T after all BIT3|BIT4|BIT5 is set. T is PMU internal mataince time after FC is done.
./nano/driver/pmu/ppset.c:939:    //+++Step9(opt):calibrate the system tick count according to new PP if the CPU local timers are used.
./nano/driver/pmu/ppset.c:1231:    //Increase the current limit of Buck1, otherwise PMIC can't survive mlucas+GC MMO6 stress.
./nano/driver/pmu/ppset.c:1237:    //According to PMIC datasheet chapter 5.2 table 24: the 32k XO Tstart = 1s typical and 10s maximum.
./nano/driver/pmu/ppset.c:1410: /*Note: we direclty do the CS change to PP0 for simple*/
./nano/driver/pmu/ppset.c:1514:3, Each DVC update need some time (DVC counter),
./nano/driver/pmu/ppset.c:1650:/*1,spinlock makes sure there is only one entity of this function is in executing at any time,
./nano/driver/pmu/ppset.c:1654:  5.!!!!!We assume AXI always use PLL1 for simple!!!
./nano/driver/pmu/ppset.c:1810:    //because we rely on the UART FIFO timeout interrupt to output log in console AO.)
./nano/driver/pmu/ppset.c:1893:/*Must make sure there is only one entity of this function is in executing at any time,
./nano/driver/pmu/ppset.c:1940:  if test_mode > PP_NUM, we have some special test modes, test_count limits the PP change count number*/
./nano/driver/pmu/reset.c:4:#include "timer_dec.h"
./nano/driver/pmu/pmu_dec.h:53:void set_wake_src(e_wake_src wake_src, uint32_t time_sec);
./nano/driver/pmu/pmu_dec.h:71:#define  ddr_idle_time  (*(volatile unsigned int *)0xD1010024)
./nano/driver/pmu/pmu_dec.h:95:#define CPU_DATA_SIZE   0x1000   //FIXME: this size may need to be optimized
./nano/driver/pmu/ppset.h:105:2,CORE  may has different maximum freq support per our Market/PE
./nano/driver/pmu/ppset.h:108:Similarly, individual unit can change to any OP as long as PLL_OP no conflict
./nano/driver/printer/print.c:8:  but WITHOUT ANY WARRANTY; without even the implied warranty of
./nano/driver/printer/print.c:54://  USE_INTERNALS implements code for company-specific linkages
./nano/driver/printer/print.c:130://  It is more useful when implementing a walking-string function.
./nano/driver/printer/print.c:173:   uint64_t decimalNum = (uint64_t) ((dbl - wholeNum) * mult);
./nano/driver/printer/print.c:184:   // printf("%.3f: whole=%s, dec=%d\n", dbl, tbfr, decimalNum) ;
./nano/driver/printer/print.c:200:      while (decimalNum != 0) {
./nano/driver/printer/print.c:201:         tbfr[idx++] = '0' + (decimalNum % 10) ;
./nano/driver/printer/print.c:202:         decimalNum /= 10 ;
./nano/driver/printer/print.c:204:      //  pad the decimal portion with 0s as necessary;
./nano/driver/printer/print.c:209:      // printf("decimal=%s\n", tbfr) ;
./nano/driver/printer/print.c:374:   int post_decimal ;
./nano/driver/printer/print.c:397:         post_decimal = 0 ;
./nano/driver/printer/print.c:403:                  post_decimal = 1 ;
./nano/driver/printer/print.c:407:                  if (post_decimal) {
./nano/driver/printer/print.c:417:               		if(post_decimal){
./nano/driver/printer/print.c:567: /* This function can only print MAX_LINE_LEN length line each time.
./nano/driver/Rules.mk:1:SUBDIRS := common printer timer uart qspi
./nano/driver/sdh/external/mmc_ops.c:10:#include "timer_dec.h"
./nano/driver/sdh/external/mmc_ops.c:150:			DEBUG_SDH_PRINT("Failed! Trim is not supported on this device!\r\n");
./nano/driver/sdh/external/mmc_ops.c:156:			/* Secute Trim step 1*/
./nano/driver/sdh/external/mmc_ops.c:159:				/* Secute Trim step 2*/
./nano/driver/sdh/external/mmc_ops.c:176:			DEBUG_SDH_PRINT("Failed! Secure Trim is not supported on this device!\r\n");
./nano/driver/sdh/external/mmc_ops.c:420:	mrvl_sdh_set_timeout(card->dev.host, 2000, (card->dev.host)->sdclk);
./nano/driver/sdh/core/sdh_device.c:11:#include "timer_dec.h"
./nano/driver/sdh/core/sdh_device.c:133: *	@retries: maximum number of retries
./nano/driver/sdh/core/sdh_device.c:317:	uint32_t timeout = 10000;
./nano/driver/sdh/core/sdh_device.c:341:		if (!timeout) {
./nano/driver/sdh/core/sdh_device.c:346:		timeout--;
./nano/driver/sdh/core/sdh_device.c:391: * for HS200/SDR104 optimal sampling poing detection
./nano/driver/sdh/core/sdh_device.c:436:	mrvl_sdh_set_timeout(dev->host, 50, dev->host->sdclk);
./nano/driver/sdh/core/Makefile:4:# that.  I prefer unresolved version and since simple $(shell pwd) looks
./nano/driver/sdh/core/mmc.c:10:#include "timer_dec.h"
./nano/driver/sdh/core/mmc.c:185:	mrvl_sdh_set_timeout(card->dev.host, 250, (card->dev.host)->sdclk);
./nano/driver/sdh/core/mmc.c:252:	mrvl_sdh_set_timeout(card->dev.host, 500, (card->dev.host)->sdclk);
./nano/driver/sdh/core/mmc.c:283:	 * is a problem.  This improves chances that the test will work.
./nano/driver/sdh/core/mmc.c:352:	mrvl_sdh_set_timeout(card->dev.host, 1000, (card->dev.host)->sdclk);
./nano/driver/sdh/core/mmc.c:436:	csd->dsr_imp = UNSTUFF_BITS(resp, 76, 1);
./nano/driver/sdh/core/mmc.c:501:	csd_ext->generic_cmd6_time = pext_csd[248];
./nano/driver/sdh/core/mmc.c:502:	csd_ext->power_off_long_tim = pext_csd[247];
./nano/driver/sdh/core/mmc.c:508:	csd_ext->ini_timeout_ap = pext_csd[241];
./nano/driver/sdh/core/mmc.c:515:	csd_ext->trim_mult = pext_csd[232];
./nano/driver/sdh/core/mmc.c:519:	csd_ext->sec_trim_mult = pext_csd[229];
./nano/driver/sdh/core/mmc.c:524:	csd_ext->erase_timeout_mult = pext_csd[223];
./nano/driver/sdh/core/mmc.c:529:	csd_ext->s_a_timeout = pext_csd[217];
./nano/driver/sdh/core/mmc.c:549:	csd_ext->partition_switch_time = pext_csd[199];
./nano/driver/sdh/core/mmc.c:550:	csd_ext->out_of_interrupt_time = pext_csd[198];
./nano/driver/sdh/core/mmc.c:559:	csd_ext->hs_timing = pext_csd[185];
./nano/driver/sdh/core/mmc.c:615:	csd_ext->ini_timeout_emu = pext_csd[60];
./nano/driver/sdh/core/mmc.c:646:uint32_t mmc_set_hs_timing(struct mmc_card *card, uint8_t timing, uint8_t driver_type)
./nano/driver/sdh/core/mmc.c:657:		value = card->csd_ext.hs_timing;
./nano/driver/sdh/core/mmc.c:665:	value = (driver_type << 4) | timing;
./nano/driver/sdh/core/mmc.c:680:	if (value != card->csd_ext.hs_timing) {
./nano/driver/sdh/core/mmc.c:682:			value, card->csd_ext.hs_timing);
./nano/driver/sdh/core/mmc.c:729:	uint8_t access_mode, edge_mode, timing;
./nano/driver/sdh/core/mmc.c:808:	/* Change to supported maximum bus width */
./nano/driver/sdh/core/mmc.c:827:		timing = MMC_TIMEING_INTERFACE_HS200;
./nano/driver/sdh/core/mmc.c:834:		timing = MMC_TIMEING_INTERFACE_HS;
./nano/driver/sdh/core/mmc.c:846:		timing = MMC_TIMEING_INTERFACE_BACKWARDS;
./nano/driver/sdh/core/mmc.c:854:	err = mmc_set_hs_timing(card, timing, MMC_DRIVER_STRENGTH_DEFAULT);
./nano/driver/sdh/core/scatterlist.c:48: *   the important bit is that @nents@ denotes the number of entries that
./nano/driver/sdh/core/scatterlist.c:110: * @max_ents:	The maximum number of entries per single scatterlist
./nano/driver/sdh/core/scatterlist.c:169: * @max_ents:	The maximum number of entries the allocator returns per call
./nano/driver/sdh/core/scatterlist.c:175: *   defined to return scatterlist chunks of maximum size @max_ents.
./nano/driver/sdh/core/scatterlist.c:240:		 * SCSI), a possible improvement here would be to pass the
./nano/driver/sdh/core/mmc.h:82:	uint8_t		dsr_imp:1;
./nano/driver/sdh/core/mmc.h:130:	uint8_t			generic_cmd6_time;
./nano/driver/sdh/core/mmc.h:131:	uint8_t			power_off_long_tim;
./nano/driver/sdh/core/mmc.h:134:	uint8_t			ini_timeout_ap;
./nano/driver/sdh/core/mmc.h:141:	uint8_t			trim_mult;
./nano/driver/sdh/core/mmc.h:145:	uint8_t			sec_trim_mult;
./nano/driver/sdh/core/mmc.h:150:	uint8_t			erase_timeout_mult;
./nano/driver/sdh/core/mmc.h:155:	uint8_t			s_a_timeout;
./nano/driver/sdh/core/mmc.h:167:	uint8_t			partition_switch_time;
./nano/driver/sdh/core/mmc.h:168:	uint8_t			out_of_interrupt_time;
./nano/driver/sdh/core/mmc.h:177:	uint8_t			hs_timing;
./nano/driver/sdh/core/mmc.h:220:	uint8_t			ini_timeout_emu;
./nano/driver/sdh/core/mmc.h:238:	uint32_t			sa_timeout;		/* Units: 100ns */
./nano/driver/sdh/core/mmc.h:243:	uint32_t			hc_erase_timeout;	/* In milliseconds */
./nano/driver/sdh/core/mmc.h:244:	uint32_t			sec_trim_mult;	/* Secure trim multiplier  */
./nano/driver/sdh/core/mmc.h:246:	uint32_t			trim_timeout;		/* In milliseconds */
./nano/driver/sdh/core/sdh_device.h:212:	//uint32_t		timeout_ns;	/* data timeout (in ns, max 80ms) */
./nano/driver/sdh/core/sdh_device.h:213:	//uint32_t		timeout_clks;	/* data timeout (in clocks) */
./nano/driver/sdh/core/scatterlist.h:78:	 * must be aligned at a 32-bit boundary as a minimum.
./nano/driver/sdh/core/scatterlist.h:203: * Maximum number of entries that will be allocated in one piece, if
./nano/driver/sdh/host/sdh_mmc.c:10:#include "timer_dec.h"
./nano/driver/sdh/host/sdh_mmc.c:125:	 * Fix the Tx Hold time problem in DS/HS mode 
./nano/driver/sdh/host/sdh_host.c:9:#include "timer_dec.h"
./nano/driver/sdh/host/sdh_host.c:55:		.def_timing_sdr50 = 0x40,
./nano/driver/sdh/host/sdh_host.c:71:		.def_timing_ddr50 = 0x7f << 16 | 0x0,
./nano/driver/sdh/host/sdh_host.c:72:		.def_timing_sdr104 =  0x7d << 16 | 0x44,
./nano/driver/sdh/host/sdh_host.c:222:		uint8_t timeout = 50;
./nano/driver/sdh/host/sdh_host.c:230:			if (!timeout) {
./nano/driver/sdh/host/sdh_host.c:236:			timeout--;
./nano/driver/sdh/host/sdh_host.c:295:					/* Fix PIO large data read timeout error */
./nano/driver/sdh/host/sdh_host.c:775:			DEBUG_SDH_PRINT("Error: CMD%d Command completion signal timeout!\r\n", 
./nano/driver/sdh/host/sdh_host.c:851:			DEBUG_SDH_PRINT("Error: CMD%d Data timeout!\r\n", 
./nano/driver/sdh/host/sdh_host.c:883:			DEBUG_SDH_PRINT("Error: CMD%d Command timeout!\r\n", 
./nano/driver/sdh/host/sdh_host.c:1010:	uint32_t time_ct = 200;
./nano/driver/sdh/host/sdh_host.c:1026:		if (!time_ct) {
./nano/driver/sdh/host/sdh_host.c:1030:		time_ct--;
./nano/driver/sdh/host/sdh_host.c:1059:uint32_t mrvl_sdh_set_timeout(struct sdhc_host *host, uint32_t time_ms, uint32_t sd_clk)
./nano/driver/sdh/host/sdh_host.c:1065:	count = time_ms * (sd_clk/4000);
./nano/driver/sdh/host/sdh_host.c:1229:static void sdh_config_def_timing(struct sdhc_host *host, uint8_t mode)
./nano/driver/sdh/host/sdh_host.c:1240:		/* Fix the Tx Hold time problem in DS/HS mode */
./nano/driver/sdh/host/sdh_host.c:1255:		if (host->def_timing_sdr104) {
./nano/driver/sdh/host/sdh_host.c:1256:			rx_cfg = SDH_GET_RX(host->def_timing_sdr104);
./nano/driver/sdh/host/sdh_host.c:1258:			tx_cfg = SDH_GET_TX(host->def_timing_sdr104);
./nano/driver/sdh/host/sdh_host.c:1262:		if (host->def_timing_ddr50) {
./nano/driver/sdh/host/sdh_host.c:1263:			rx_cfg = SDH_GET_RX(host->def_timing_ddr50);
./nano/driver/sdh/host/sdh_host.c:1265:			tx_cfg = SDH_GET_TX(host->def_timing_ddr50);
./nano/driver/sdh/host/sdh_host.c:1269:		if (host->def_timing_sdr50) {
./nano/driver/sdh/host/sdh_host.c:1270:			rx_cfg = SDH_GET_RX(host->def_timing_sdr50);
./nano/driver/sdh/host/sdh_host.c:1272:			tx_cfg = SDH_GET_TX(host->def_timing_sdr50);
./nano/driver/sdh/host/sdh_host.c:1278:	 * If user do not set tx/rx timing, will reset tx/rx config
./nano/driver/sdh/host/sdh_host.c:1339:	sdh_config_def_timing(host, mode);
./nano/driver/sdh/host/sdh_host.c:1377:	/* set data timeout couter value */
./nano/driver/sdh/host/sdh_host.c:1378:	if (mrvl_sdh_set_timeout(host, 1500, host->sdclk)) {
./nano/driver/sdh/host/sdh_host.c:1379:		DEBUG_SDH_PRINT("[SDH] Warning: Required data time out value too large\r\n");
./nano/driver/sdh/host/sdh_host.c:1771:	uint8_t time_ct = 50;
./nano/driver/sdh/host/sdh_host.c:1789:			if (!(--time_ct)) {
./nano/driver/sdh/host/sdh_host.c:1811:			if (!(--time_ct)) {
./nano/driver/sdh/host/sdh_host.c:1833:			if (!(--time_ct)) {
./nano/driver/sdh/host/sdh_host.c:1904:		DEBUG_SDH_PRINT("[Error]: SDH has reached maximum card number!\r\n");
./nano/driver/sdh/host/sdh_host.h:124:	uint32_t def_timing_ddr50;
./nano/driver/sdh/host/sdh_host.h:125:	uint32_t def_timing_sdr50;
./nano/driver/sdh/host/sdh_host.h:126:	uint32_t def_timing_sdr104;
./nano/driver/sdh/host/sdh_host.h:217:uint32_t mrvl_sdh_set_timeout(struct sdhc_host *host, uint32_t time_ms, uint32_t sd_clk);
./nano/driver/ddr/init_lpddr2.c:104:  REG32(DDRC_BASE+MC_CH0_BASE+0x180) = 0x00000200;  //DDR init timing Control 0
./nano/driver/ddr/init_lpddr2.c:105:  REG32(DDRC_BASE+MC_CH0_BASE+0x184) = 0x00000036;  //DDR init timing Control 1
./nano/driver/ddr/init_lpddr2.c:106:  REG32(DDRC_BASE+MC_CH0_BASE+0x188) = 0x09600040;  //DDR init timing Control 2
./nano/driver/ddr/init_lpddr2.c:107:  REG32(DDRC_BASE+MC_CH0_BASE+0x18c) = 0x001b0216;  //ZQC timing 0
./nano/driver/ddr/init_lpddr2.c:108:  REG32(DDRC_BASE+MC_CH0_BASE+0x190) = 0x003000c0;  //ZQC timing 1
./nano/driver/ddr/init_lpddr2.c:109:  REG32(DDRC_BASE+MC_CH0_BASE+0x194) = 0x004603cf;  //Refresh timing 
./nano/driver/ddr/init_lpddr2.c:110:  //REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x004b004b;  //SelfRefresh timing 0
./nano/driver/ddr/init_lpddr2.c:111:  REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x01000100;  //SelfRefresh timing 0
./nano/driver/ddr/init_lpddr2.c:112:  REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00200808;  //SelfRefresh timing 1
./nano/driver/ddr/init_lpddr2.c:113:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a0) = 0x01080404;  //Power down timing 0
./nano/driver/ddr/init_lpddr2.c:114:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a4) = 0x00000001;  //Power down timing 1
./nano/driver/ddr/init_lpddr2.c:115:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a8) = 0x00000205;  //MRS timing
./nano/driver/ddr/init_lpddr2.c:116:  REG32(DDRC_BASE+MC_CH0_BASE+0x1ac) = 0x1b200a17;  //ACT timing
./nano/driver/ddr/init_lpddr2.c:117:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b0) = 0x0c08040a;  //Pre-Charge timing
./nano/driver/ddr/init_lpddr2.c:118:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b4) = 0x02000400;  //CAS/RAS timing 0
./nano/driver/ddr/init_lpddr2.c:119:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b8) = 0x00010600;  //CAS/RAS timing 1
./nano/driver/ddr/init_lpddr2.c:121:  REG32(DDRC_BASE+MC_CH0_BASE+0x1bc) = 0x02020404;  //Off-spec timing 0
./nano/driver/ddr/init_lpddr2.c:122:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c0) = 0x00000002;  //Off-spec timing 1
./nano/driver/ddr/init_lpddr2.c:123:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c4) = 0x00140a03;  //DRAM_read timing
./nano/driver/ddr/init_lpddr2.c:143:  REG32(DDRC_BASE+MC_CH0_BASE+0x180) = 0x000000c0;  //DDR init timing Control 0
./nano/driver/ddr/init_lpddr2.c:144:  REG32(DDRC_BASE+MC_CH0_BASE+0x184) = 0x00000018;  //DDR init timing Control 1
./nano/driver/ddr/init_lpddr2.c:145:  REG32(DDRC_BASE+MC_CH0_BASE+0x188) = 0x09600014;  //DDR init timing Control 2
./nano/driver/ddr/init_lpddr2.c:147:  REG32(DDRC_BASE+MC_CH0_BASE+0x18c) = 0x000E010B;  //ZQC timing 0
./nano/driver/ddr/init_lpddr2.c:148:  REG32(DDRC_BASE+MC_CH0_BASE+0x190) = 0x00190061;  //ZQC timing 1
./nano/driver/ddr/init_lpddr2.c:149:  REG32(DDRC_BASE+MC_CH0_BASE+0x194) = 0x0011001A;  //Refresh timing 
./nano/driver/ddr/init_lpddr2.c:150:  //REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x001c001c;  //SelfRefresh timing 0
./nano/driver/ddr/init_lpddr2.c:151:  REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x00260026;  //SelfRefresh timing 0
./nano/driver/ddr/init_lpddr2.c:152:  //REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00000A0A;  //SelfRefresh timing 1
./nano/driver/ddr/init_lpddr2.c:153:  REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00000505;  //SelfRefresh timing 1
./nano/driver/ddr/init_lpddr2.c:154:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a0) = 0x01050303;  //Power down timing 0
./nano/driver/ddr/init_lpddr2.c:155:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a4) = 0x00000001;  //Power down timing 1
./nano/driver/ddr/init_lpddr2.c:156:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a8) = 0x00000205;  //MRS timing
./nano/driver/ddr/init_lpddr2.c:157:  REG32(DDRC_BASE+MC_CH0_BASE+0x1ac) = 0x0E11050C;  //ACT timing
./nano/driver/ddr/init_lpddr2.c:158:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b0) = 0x06050305;  //Pre-Charge timing
./nano/driver/ddr/init_lpddr2.c:159:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b4) = 0x04000300;  //CAS/RAS timing 0
./nano/driver/ddr/init_lpddr2.c:160:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b8) = 0x00000300;  //CAS/RAS timing 1
./nano/driver/ddr/init_lpddr2.c:162:  REG32(DDRC_BASE+MC_CH0_BASE+0x1bc) = 0x02020404;  //Off-spec timing 0
./nano/driver/ddr/init_lpddr2.c:163:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c0) = 0x00000002;  //Off-spec timing 1
./nano/driver/ddr/init_lpddr2.c:164:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c4) = 0x00000001;  //DRAM_read timing
./nano/driver/ddr/init_lpddr2.c:258:// remove all RDG training from table for SOC, by weima
./nano/driver/ddr/z1_ddr_init.c:109:  REG32(DDRC_BASE+MC_CH0_BASE+0x180) = 0x00000200;	//DDR init timing Control 0
./nano/driver/ddr/z1_ddr_init.c:110:  REG32(DDRC_BASE+MC_CH0_BASE+0x184) = 0x00000036;	//DDR init timing Control 1
./nano/driver/ddr/z1_ddr_init.c:111:  REG32(DDRC_BASE+MC_CH0_BASE+0x188) = 0x09600040;	//DDR init timing Control 2
./nano/driver/ddr/z1_ddr_init.c:112:  REG32(DDRC_BASE+MC_CH0_BASE+0x18c) = 0x001b0216;	//ZQC timing 0
./nano/driver/ddr/z1_ddr_init.c:113:  REG32(DDRC_BASE+MC_CH0_BASE+0x190) = 0x003000c0;	//ZQC timing 1
./nano/driver/ddr/z1_ddr_init.c:114:  REG32(DDRC_BASE+MC_CH0_BASE+0x194) = 0x004603cf;	//Refresh timing 
./nano/driver/ddr/z1_ddr_init.c:115:  //REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x004b004b;	//SelfRefresh timing 0
./nano/driver/ddr/z1_ddr_init.c:116:  REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x01000100;	//SelfRefresh timing 0
./nano/driver/ddr/z1_ddr_init.c:117:  REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00200808;	//SelfRefresh timing 1
./nano/driver/ddr/z1_ddr_init.c:118:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a0) = 0x01080404;	//Power down timing 0
./nano/driver/ddr/z1_ddr_init.c:119:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a4) = 0x00000001;	//Power down timing 1
./nano/driver/ddr/z1_ddr_init.c:120:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a8) = 0x00000205;	//MRS timing
./nano/driver/ddr/z1_ddr_init.c:121:  REG32(DDRC_BASE+MC_CH0_BASE+0x1ac) = 0x1b200a17;	//ACT timing
./nano/driver/ddr/z1_ddr_init.c:122:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b0) = 0x0c08040a;	//Pre-Charge timing
./nano/driver/ddr/z1_ddr_init.c:123:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b4) = 0x02000400;	//CAS/RAS timing 0
./nano/driver/ddr/z1_ddr_init.c:124:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b8) = 0x00010600;	//CAS/RAS timing 1
./nano/driver/ddr/z1_ddr_init.c:126:  REG32(DDRC_BASE+MC_CH0_BASE+0x1bc) = 0x02020404;	//Off-spec timing 0
./nano/driver/ddr/z1_ddr_init.c:127:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c0) = 0x00000002;	//Off-spec timing 1
./nano/driver/ddr/z1_ddr_init.c:128:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c4) = 0x00140a03;	//DRAM_read timing
./nano/driver/ddr/z1_ddr_init.c:148:  REG32(DDRC_BASE+MC_CH0_BASE+0x180) = 0x000000c0;	//DDR init timing Control 0
./nano/driver/ddr/z1_ddr_init.c:149:  REG32(DDRC_BASE+MC_CH0_BASE+0x184) = 0x00000018;	//DDR init timing Control 1
./nano/driver/ddr/z1_ddr_init.c:150:  REG32(DDRC_BASE+MC_CH0_BASE+0x188) = 0x09600014;	//DDR init timing Control 2
./nano/driver/ddr/z1_ddr_init.c:152:  REG32(DDRC_BASE+MC_CH0_BASE+0x18c) = 0x000a00c8;	//ZQC timing 0
./nano/driver/ddr/z1_ddr_init.c:153:  REG32(DDRC_BASE+MC_CH0_BASE+0x190) = 0x00120048;	//ZQC timing 1
./nano/driver/ddr/z1_ddr_init.c:154:  REG32(DDRC_BASE+MC_CH0_BASE+0x194) = 0x001a03cf;	//Refresh timing 
./nano/driver/ddr/z1_ddr_init.c:155:  //REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x001c001c;	//SelfRefresh timing 0
./nano/driver/ddr/z1_ddr_init.c:156:  REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x00960096;	//SelfRefresh timing 0
./nano/driver/ddr/z1_ddr_init.c:157:  //REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00000A0A;	//SelfRefresh timing 1
./nano/driver/ddr/z1_ddr_init.c:158:  REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00200303;	//SelfRefresh timing 1
./nano/driver/ddr/z1_ddr_init.c:159:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a0) = 0x01030202;	//Power down timing 0
./nano/driver/ddr/z1_ddr_init.c:160:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a4) = 0x00000001;	//Power down timing 1
./nano/driver/ddr/z1_ddr_init.c:161:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a8) = 0x00000205;	//MRS timing
./nano/driver/ddr/z1_ddr_init.c:162:  REG32(DDRC_BASE+MC_CH0_BASE+0x1ac) = 0x0a0c0409;	//ACT timing
./nano/driver/ddr/z1_ddr_init.c:163:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b0) = 0x05030204;	//Pre-Charge timing
./nano/driver/ddr/z1_ddr_init.c:164:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b4) = 0x02000300;	//CAS/RAS timing 0
./nano/driver/ddr/z1_ddr_init.c:165:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b8) = 0x00010200;	//CAS/RAS timing 1
./nano/driver/ddr/z1_ddr_init.c:167:  REG32(DDRC_BASE+MC_CH0_BASE+0x1bc) = 0x02020404;	//Off-spec timing 0
./nano/driver/ddr/z1_ddr_init.c:168:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c0) = 0x00000002;	//Off-spec timing 1
./nano/driver/ddr/z1_ddr_init.c:169:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c4) = 0x00140a01;	//DRAM_read timing
./nano/driver/ddr/z1_ddr_init.c:264:// remove all RDG training from table for SOC, by weima
./nano/driver/ddr/lpddr2_haps.c:104:  REG32(DDRC_BASE+MC_CH0_BASE+0x180) = 0x00000200;	//DDR init timing Control 0
./nano/driver/ddr/lpddr2_haps.c:105:  REG32(DDRC_BASE+MC_CH0_BASE+0x184) = 0x00000036;	//DDR init timing Control 1
./nano/driver/ddr/lpddr2_haps.c:106:  REG32(DDRC_BASE+MC_CH0_BASE+0x188) = 0x09600040;	//DDR init timing Control 2
./nano/driver/ddr/lpddr2_haps.c:107:  REG32(DDRC_BASE+MC_CH0_BASE+0x18c) = 0x001b0216;	//ZQC timing 0
./nano/driver/ddr/lpddr2_haps.c:108:  REG32(DDRC_BASE+MC_CH0_BASE+0x190) = 0x003000c0;	//ZQC timing 1
./nano/driver/ddr/lpddr2_haps.c:109:  REG32(DDRC_BASE+MC_CH0_BASE+0x194) = 0x004603cf;	//Refresh timing 
./nano/driver/ddr/lpddr2_haps.c:110:  //REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x004b004b;	//SelfRefresh timing 0
./nano/driver/ddr/lpddr2_haps.c:111:  REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x01000100;	//SelfRefresh timing 0
./nano/driver/ddr/lpddr2_haps.c:112:  REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00200808;	//SelfRefresh timing 1
./nano/driver/ddr/lpddr2_haps.c:113:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a0) = 0x01080404;	//Power down timing 0
./nano/driver/ddr/lpddr2_haps.c:114:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a4) = 0x00000001;	//Power down timing 1
./nano/driver/ddr/lpddr2_haps.c:115:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a8) = 0x00000205;	//MRS timing
./nano/driver/ddr/lpddr2_haps.c:116:  REG32(DDRC_BASE+MC_CH0_BASE+0x1ac) = 0x1b200a17;	//ACT timing
./nano/driver/ddr/lpddr2_haps.c:117:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b0) = 0x0c08040a;	//Pre-Charge timing
./nano/driver/ddr/lpddr2_haps.c:118:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b4) = 0x02000400;	//CAS/RAS timing 0
./nano/driver/ddr/lpddr2_haps.c:119:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b8) = 0x00010600;	//CAS/RAS timing 1
./nano/driver/ddr/lpddr2_haps.c:121:  REG32(DDRC_BASE+MC_CH0_BASE+0x1bc) = 0x02020404;	//Off-spec timing 0
./nano/driver/ddr/lpddr2_haps.c:122:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c0) = 0x00000002;	//Off-spec timing 1
./nano/driver/ddr/lpddr2_haps.c:123:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c4) = 0x00140a03;	//DRAM_read timing
./nano/driver/ddr/lpddr2_haps.c:143:  REG32(DDRC_BASE+MC_CH0_BASE+0x180) = 0x000000c0;	//DDR init timing Control 0
./nano/driver/ddr/lpddr2_haps.c:144:  REG32(DDRC_BASE+MC_CH0_BASE+0x184) = 0x00000018;	//DDR init timing Control 1
./nano/driver/ddr/lpddr2_haps.c:145:  REG32(DDRC_BASE+MC_CH0_BASE+0x188) = 0x09600014;	//DDR init timing Control 2
./nano/driver/ddr/lpddr2_haps.c:147:  REG32(DDRC_BASE+MC_CH0_BASE+0x18c) = 0x000a00c8;	//ZQC timing 0
./nano/driver/ddr/lpddr2_haps.c:148:  REG32(DDRC_BASE+MC_CH0_BASE+0x190) = 0x00120048;	//ZQC timing 1
./nano/driver/ddr/lpddr2_haps.c:149:  REG32(DDRC_BASE+MC_CH0_BASE+0x194) = 0x001a03cf;	//Refresh timing 
./nano/driver/ddr/lpddr2_haps.c:150:  //REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x001c001c;	//SelfRefresh timing 0
./nano/driver/ddr/lpddr2_haps.c:151:  REG32(DDRC_BASE+MC_CH0_BASE+0x198) = 0x00960096;	//SelfRefresh timing 0
./nano/driver/ddr/lpddr2_haps.c:152:  //REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00000A0A;	//SelfRefresh timing 1
./nano/driver/ddr/lpddr2_haps.c:153:  REG32(DDRC_BASE+MC_CH0_BASE+0x19c) = 0x00200303;	//SelfRefresh timing 1
./nano/driver/ddr/lpddr2_haps.c:154:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a0) = 0x01030202;	//Power down timing 0
./nano/driver/ddr/lpddr2_haps.c:155:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a4) = 0x00000001;	//Power down timing 1
./nano/driver/ddr/lpddr2_haps.c:156:  REG32(DDRC_BASE+MC_CH0_BASE+0x1a8) = 0x00000205;	//MRS timing
./nano/driver/ddr/lpddr2_haps.c:157:  REG32(DDRC_BASE+MC_CH0_BASE+0x1ac) = 0x0a0c0409;	//ACT timing
./nano/driver/ddr/lpddr2_haps.c:158:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b0) = 0x05030204;	//Pre-Charge timing
./nano/driver/ddr/lpddr2_haps.c:159:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b4) = 0x02000300;	//CAS/RAS timing 0
./nano/driver/ddr/lpddr2_haps.c:160:  REG32(DDRC_BASE+MC_CH0_BASE+0x1b8) = 0x00010200;	//CAS/RAS timing 1
./nano/driver/ddr/lpddr2_haps.c:162:  REG32(DDRC_BASE+MC_CH0_BASE+0x1bc) = 0x02020404;	//Off-spec timing 0
./nano/driver/ddr/lpddr2_haps.c:163:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c0) = 0x00000002;	//Off-spec timing 1
./nano/driver/ddr/lpddr2_haps.c:164:  REG32(DDRC_BASE+MC_CH0_BASE+0x1c4) = 0x00140a01;	//DRAM_read timing
./nano/driver/ddr/lpddr2_haps.c:259:// remove all RDG training from table for SOC, by weima
./nano/driver/qspi/qspi_host.c:2:#include "timer_dec.h"
./nano/driver/qspi/spi_nor.c:365: *   Since it is writing the data to cache, there is no tPROG time.
./nano/driver/qspi/spi_nand.c:288: *   Since it is writing the data to cache, there is no tPROG time.
./nano/driver/qspi/spi_nand.c:316: *   Need to wait for tPROG time to finish the transaction.
./nano/driver/qspi/qspi_common.h:134:#define	ETIMEDOUT	110	/* Connection timed out */
./nano/driver/common/tim.h:69:#define TIMBUFFER 				4096    		//4k for a Tim structure size
./nano/driver/common/tim.h:354: uint32_t EscSeqTimeOutMS;  				// Value is interpreted in milli secs.
./nano/driver/common/tim.h:436:// OTA related image type
./nano/driver/common/tim.h:439:   	PrimaryImage 	= 0,                // Primary image
./nano/driver/common/tim.h:440:   	RecoveryImage 	= 1,               	// Recovery image
./nano/driver/common/tim.h:441:   	CPImage 		= 2,				// CP image
./nano/driver/common/tim.h:471: 	uint32_t ImageID;                    	// 0x54494Dxx   - secondary tim ID (TIMx)
./nano/driver/common/tim.h:472: 	OTA_IMAGE_TYPE ImageType;          	// OTA_IMAGE_TYPE (Primary VS Recovery)
./nano/driver/common/tim.h:481: 	uint32_t NumberOfMappedImages;       	// Number of images with mapping information
./nano/driver/common/tim.h:482:	IMG_MAP_INFO pImgMapInfo[1];       	// First image map information struct
./nano/driver/common/tim.h:493:	uint32_t ODBTImageList[1];    	//First image ID in new list
./nano/driver/common/tim.h:525:    DDR_IGNORE_INST_TO = 6,		// Treat a time out waiting for a bit to set/clear
./nano/driver/common/tim.h:538://   Delay Specified Time		DELAY				0x3				Value	n/a 			n/a
./nano/driver/common/tim.h:539://   WaitForOperationToSetBit	WAIT_FOR_BIT_SET	0x4				Addr	Mask			TimeOut Value
./nano/driver/common/tim.h:540://   WaitForOperationToClearBit	WAIT_FOR_BIT_CLEAR	0x5				Addr	Mask			TimeOut Value
./nano/driver/common/tim.h:617:	TZ_IGNORE_INST_TO = 6, 		// Treat a time out waiting for a bit to set/clear
./nano/driver/common/tim.h:643:	GPP_IGNORE_INST_TO = 6,		// Treat a time out waiting for a bit to set/clear
./nano/driver/common/tim.h:737: uint32_t NextImageID;					// Indicate next image in the chain
./nano/driver/common/tim.h:754: uint32_t NextImageID;				// Indicate next image in the chain
./nano/driver/common/tim.h:767: uint32_t NextImageID;				// Indicate next image in the chain
./nano/driver/common/tim.h:920:/* tim.c Function Proto's */
./nano/driver/common/tim.h:922:uint32_t LoadTim(uint8_t *TIMArea, TIM *pTIM_h, uint32_t SRAMLoad);
./nano/driver/common/tim.h:937:// Returns a pointer to the static tim in tim.c
./nano/driver/common/tim.h:938:pTIM GetTimPointer();
./nano/driver/common/tim.h:939:uint32_t get_image_number(TIM *pTIM_h);
./nano/driver/common/gpio.c:6:#include "timer_dec.h"
./nano/driver/common/bsp.c:39:#include "timer_dec.h"
./nano/driver/common/tim.c:20:#include "tim.h"
./nano/driver/common/tim.c:62:uint32_t get_image_number(TIM *pTIM_h)
./nano/driver/common/tim.c:67:uint32_t get_image_size(uint32_t Image)
./nano/driver/common/tim.c:69:    TIM tim;
./nano/driver/common/tim.c:70:    pTIM pTIM_h = &tim;
./nano/driver/common/tim.c:71:    int imageNum;
./nano/driver/common/tim.c:76:    /* check if there is valid tim in SRAM */
./nano/driver/common/tim.c:82:    imageNum = pTIM_h->pConsTIM->NumImages;
./nano/driver/common/tim.c:84:    for(int i = 0; i < imageNum; i++){
./nano/driver/common/tim.c:94:int load_image_from_flash(uint32_t Image, uint32_t address)
./nano/driver/common/tim.c:96:	TIM tim;
./nano/driver/common/tim.c:97:	pTIM pTIM_h = &tim;
./nano/driver/common/tim.c:98:	int imageNum, imageSize, i;
./nano/driver/common/tim.c:104:    /* check if there is valid tim in SRAM */
./nano/driver/common/tim.c:110:    imageNum = pTIM_h->pConsTIM->NumImages;
./nano/driver/common/tim.c:112:    for(i = 0; i < imageNum; i++){
./nano/driver/common/tim.c:116:    		//Load image from flash to DDR
./nano/driver/common/Rules.mk:2:SRCS_EXCLUDES := tim.c
./nano/driver/common/gic_dec.h:19://The PPIs in the range ID16-ID27 are unimplemented.
./nano/driver/common/gic_dec.h:22:a set of 4 timers per CPU is defined   
./nano/driver/common/gic_dec.h:23:A physical timer for use in Kernel modes/Secure Privileged modes   (CNTP_)    Banked 
./nano/driver/common/gic_dec.h:25:-Non-secure Kernel access to this Timer controlled using a Hyp Control register   
./nano/driver/common/gic_dec.h:26:A virtual timer for use in Kernel modes           (CNTV_)        Common 
./nano/driver/common/gic_dec.h:27:A physical timer for use in Hyp mode              (CNTHP_)       Common  
./nano/driver/common/gic_dec.h:29:Each CPU makes the output of each timer as an output pin to the system, and 
./nano/driver/common/gic_dec.h:31:For each CPU the same interrupt number should be used for the same timer. 
./nano/driver/common/gic_dec.h:110: * Number of interrupts implemented in the GIC
./nano/driver/common/gic_dec.h:193:#define ENABLE        1 /**< Interrupt enable. Used with gic_interrupt_enable() primitive. */
./nano/driver/common/gic_dec.h:194:#define DISABLE       0 /**< Interrupt disable. Used with gic_interrupt_enable() primitive. */
./nano/driver/common/interrupt.c:57:  so CPU is wake up but it will not handle the interrupt. At that time, we restore
./nano/driver/common/interrupt.c:62:  FIXME: we may fix the wake up sequence for simple in ca9_idle.c later*/
./nano/driver/common/interrupt.c:94:  requires a fast response time, e.g. DMA specially used to move blocks of memory, timer validation
./nano/driver/common/interrupt.c:95:  and hard real-time appliations. Thus, there are usually 1~2 FIQs enabled. If necessary, it should be handled in
./nano/driver/timer/wdt.c:1:#include "timer_dec.h"
./nano/driver/timer/wdt.c:39:        /* timer clock on and timer reset (0x5) */
./nano/driver/timer/wdt.c:44:    /*  select timer1 clock 13MHz, release reset */
./nano/driver/timer/wdt.c:63:    // the wdt timer seems only use 256hz
./nano/driver/timer/wdt.c:64:    // see the emei register TimersCP section for details
./nano/driver/timer/clock.h:12:}bbu_time_t;
./nano/driver/timer/clock.h:14:/*.................. get escaped time(msec) from BBU start .................*/
./nano/driver/timer/clock.h:17:/*.................. get escaped time(sec) from BBU start ..................*/
./nano/driver/timer/clock.h:21:void bbu_strftime(char *time_buffer);
./nano/driver/timer/clock.h:24:void print_current_time(void);
./nano/driver/timer/timer_ca7.c:3:#include "timer_dec.h"
./nano/driver/timer/timer_ca7.c:9:TIME_BASE *timer[2] = {TIME1, TIME2};
./nano/driver/timer/timer_ca7.c:11:void apb_timer_reset(void){
./nano/driver/timer/timer_ca7.c:13:    /* timer clock on and timer reset (0x5) */
./nano/driver/timer/timer_ca7.c:18:    /*  select timer0 clock 3.25MHz, release reset */
./nano/driver/timer/timer_ca7.c:23:    /* timer clock on and timer reset (0x5) */
./nano/driver/timer/timer_ca7.c:28:    /*  select timer1 clock 3.25MHz, release reset */
./nano/driver/timer/timer_ca7.c:36:static void _apb_systimer_init(TIME_BASE *timer_p){
./nano/driver/timer/timer_ca7.c:39:    timer_p->CER &= ~CER_T0EN_MASK;   //disable timer0 before configure it
./nano/driver/timer/timer_ca7.c:43:    /* timer0 3.25M */
./nano/driver/timer/timer_ca7.c:44:    timer_p->CCR &= ~CCR_CS_0_MASK;   //TIME1 timer0 select configurable clock.
./nano/driver/timer/timer_ca7.c:49:    timer_p->CMR |= CMR_T0MODE_MASK;  //TIME1 timer0 as free running timer mode
./nano/driver/timer/timer_ca7.c:52:    timer_p->PLVRn[0] = 0;    
./nano/driver/timer/timer_ca7.c:54:    timer_p->PLCRn[0] = 0;
./nano/driver/timer/timer_ca7.c:56:    timer_p->ICRn[0] |= ICRN_TCLR0_MASK;      //clear timer0 irq
./nano/driver/timer/timer_ca7.c:59:    timer_p->IERn[0] = 0x0;
./nano/driver/timer/timer_ca7.c:64:    /* enable the timer to kick off counter */
./nano/driver/timer/timer_ca7.c:65:    timer_p->CER = 0x1;   //enable timer0 after configure
./nano/driver/timer/timer_ca7.c:70:void apb_systimer_init(void){
./nano/driver/timer/timer_ca7.c:73:        _apb_systimer_init(timer[i]);
./nano/driver/timer/timer_ca7.c:79:/*Let the TIME1_timer0 at free running, and don't enable the preload when a
./nano/driver/timer/timer_ca7.c:80:  match occurs between TMR_Tn_Tm and Timer Count Registers.
./nano/driver/timer/timer_ca7.c:83:void sys_timer_init(void) //This funciton is related to OS tick, Care to modify!
./nano/driver/timer/timer_ca7.c:85:    apb_timer_reset();
./nano/driver/timer/timer_ca7.c:86:    apb_systimer_init(); //this is the timers on APB bus
./nano/driver/timer/timer_ca7.c:88:    generic_timer_config(); //this is the global generic timers, for delay functions,etc.
./nano/driver/timer/timer_ca7.c:102://If the delta is within 0x10000000(about 1min, it cost time when cache is not enabled yet at boot), 
./nano/driver/timer/timer_ca7.c:114:uint32_t timer_get_count(int id) //This funciton is related to OS tick, Care to modify!
./nano/driver/timer/timer_ca7.c:116:        /* read twice, this is ok as long as timer runs at slow clock, i.e. 32KHz.
./nano/driver/timer/timer_ca7.c:120:         * However, it needs to wait 3 functinal(the timer functional clock selected)  clock cycles 
./nano/driver/timer/timer_ca7.c:134:    //if Timer is slow, e.g. configured as 32K TIMER, read twice can get same.
./nano/driver/timer/timer_ca7.c:137:    //Note: timer can be 13M at MAX, so we may need adjust the numbers according to the timer functional clock selected.
./nano/driver/timer/timer_ca7.c:161:// generic timer use 26Mhz clk
./nano/driver/timer/timer_ca7.c:162:static void timer_tick_delay(int tick){   
./nano/driver/timer/timer_ca7.c:165:    begin = generic_timer_read();
./nano/driver/timer/timer_ca7.c:167:        end = generic_timer_read();
./nano/driver/timer/timer_ca7.c:173:    timer_tick_delay(us * 26);
./nano/driver/timer/timer_ca7.c:180:uint32_t timeout_mdelay(uint32_t ms, uint32_t *ind, uint32_t expected_value){
./nano/driver/timer/timer_ca7.c:183:    begin =(uint64_t)generic_timer_read();
./nano/driver/timer/timer_ca7.c:185:        end =(uint64_t)generic_timer_read();
./nano/driver/timer/timer_ca7.c:193:static void timer_tick_delay(int tick){
./nano/driver/timer/timer_ca7.c:196:    begin = timer_get_count(0);
./nano/driver/timer/timer_ca7.c:199:        end = timer_get_count(0);
./nano/driver/timer/timer_ca7.c:206:    There is a limition in the below function, the returned cycle is
./nano/driver/timer/timer_ca7.c:212:    timer_tick_delay(13*us);
./nano/driver/timer/timer_ca7.c:220:    timer_tick_delay(tick);
./nano/driver/timer/timer_ca7.c:228:    timer_tick_delay(tick);
./nano/driver/timer/timer_ca7.c:234:    timer_tick_delay(ms * 3250);
./nano/driver/timer/timer_ca7.c:239:uint32_t timeout_mdelay(uint32_t ms, uint32_t *ind, uint32_t expected_value){
./nano/driver/timer/timer_ca7.c:242:    begin = timer_get_count(0);
./nano/driver/timer/timer_ca7.c:245:        end = timer_get_count(0);
./nano/driver/timer/timer_ca7.c:261:void generic_timer_config(void){
./nano/driver/timer/timer_ca7.c:267:    // emei doesn't have generic timer
./nano/driver/timer/timer_ca7.c:273:uint64_t generic_timer_read(void){
./nano/driver/timer/timer_ca7.c:275:    uint64_t time;
./nano/driver/timer/timer_ca7.c:278:    time = ((uint64_t)up << 32) | low;
./nano/driver/timer/timer_ca7.c:280:    return time;
./nano/driver/timer/timer_ca7.c:283:void generic_timer_test(){
./nano/driver/timer/timer_ca7.c:287:    begin = generic_timer_read();
./nano/driver/timer/timer_ca7.c:289:        end = generic_timer_read();
./nano/driver/timer/Rules.mk:6:SRCS += timer_ca7.c
./nano/driver/timer/Rules.mk:9:SRCS += wdt.c timer_cr5.c
./nano/driver/timer/timer_cr5.c:3:#include "timer_dec.h"
./nano/driver/timer/timer_cr5.c:10:void apb_timer_reset(void){
./nano/driver/timer/timer_cr5.c:14:void apb_systimer_init(void){
./nano/driver/timer/timer_cr5.c:18:/*Let the TIME1_timer0 at free running, and don't enable the preload when a
./nano/driver/timer/timer_cr5.c:19:  match occurs between TMR_Tn_Tm and Timer Count Registers.
./nano/driver/timer/timer_cr5.c:22:void sys_timer_init(void) //This funciton is related to OS tick, Care to modify!
./nano/driver/timer/timer_cr5.c:24:    apb_timer_reset();
./nano/driver/timer/timer_cr5.c:25:    apb_systimer_init(); //this is the timers on APB bus
./nano/driver/timer/timer_cr5.c:27:    generic_timer_config(); //this is the global generic timers, for delay functions,etc.
./nano/driver/timer/timer_cr5.c:41://If the delta is within 0x10000000(about 1min, it cost time when cache is not enabled yet at boot), 
./nano/driver/timer/timer_cr5.c:53:uint32_t timer_get_count(int id) //This funciton is related to OS tick, Care to modify!
./nano/driver/timer/timer_cr5.c:55:        /* read twice, this is ok as long as timer runs at slow clock, i.e. 32KHz.
./nano/driver/timer/timer_cr5.c:59:         * However, it needs to wait 3 functinal(the timer functional clock selected)  clock cycles 
./nano/driver/timer/timer_cr5.c:73:    //if Timer is slow, e.g. configured as 32K TIMER, read twice can get same.
./nano/driver/timer/timer_cr5.c:76:    //Note: timer can be 13M at MAX, so we may need adjust the numbers according to the timer functional clock selected.
./nano/driver/timer/timer_cr5.c:100:// generic timer use 26Mhz clk
./nano/driver/timer/timer_cr5.c:101:static void timer_tick_delay(int tick){   
./nano/driver/timer/timer_cr5.c:104:    begin = generic_timer_read();
./nano/driver/timer/timer_cr5.c:106:        end = generic_timer_read();
./nano/driver/timer/timer_cr5.c:112:    timer_tick_delay(us * 26);
./nano/driver/timer/timer_cr5.c:119:uint32_t timeout_mdelay(uint32_t ms, uint32_t *ind, uint32_t expected_value){
./nano/driver/timer/timer_cr5.c:122:    begin =(uint64_t)generic_timer_read();
./nano/driver/timer/timer_cr5.c:124:        end =(uint64_t)generic_timer_read();
./nano/driver/timer/timer_cr5.c:132:static void timer_tick_delay(int tick){
./nano/driver/timer/timer_cr5.c:135:    begin = timer_get_count(0);
./nano/driver/timer/timer_cr5.c:138:        end = timer_get_count(0);
./nano/driver/timer/timer_cr5.c:145:    There is a limition in the below function, the returned cycle is
./nano/driver/timer/timer_cr5.c:151:    timer_tick_delay(13*us);
./nano/driver/timer/timer_cr5.c:159:    timer_tick_delay(tick);
./nano/driver/timer/timer_cr5.c:167:    timer_tick_delay(tick);
./nano/driver/timer/timer_cr5.c:173:    timer_tick_delay(ms * 3250);
./nano/driver/timer/timer_cr5.c:178:uint32_t timeout_mdelay(uint32_t ms, uint32_t *ind, uint32_t expected_value){
./nano/driver/timer/timer_cr5.c:181:    begin = timer_get_count(0);
./nano/driver/timer/timer_cr5.c:184:        end = timer_get_count(0);
./nano/driver/timer/timer_cr5.c:200:void generic_timer_config(void){
./nano/driver/timer/timer_cr5.c:206:    // emei doesn't have generic timer
./nano/driver/timer/timer_cr5.c:212:uint64_t generic_timer_read(void){
./nano/driver/timer/timer_cr5.c:214:    uint64_t time;
./nano/driver/timer/timer_cr5.c:217:    time = ((uint64_t)up << 32) | low;
./nano/driver/timer/timer_cr5.c:219:    return time;
./nano/driver/timer/timer_cr5.c:222:void generic_timer_test(){
./nano/driver/timer/timer_cr5.c:226:    begin = generic_timer_read();
./nano/driver/timer/timer_cr5.c:228:        end = generic_timer_read();
./nano/driver/timer/timer_cr5.c:263:    bbu_timer_help();
./nano/driver/timer/timer_dec.h:63://system timer functions.
./nano/driver/timer/timer_dec.h:64:uint32_t timer_get_count(int id);
./nano/driver/timer/timer_dec.h:68:void generic_timer_config(void);
./nano/driver/timer/timer_dec.h:69:unsigned long long generic_timer_read(void);
./nano/driver/timer/timer_dec.h:70:void generic_timer_test(void);
./nano/driver/timer/timer_dec.h:73://watch dog timer function.
./nano/driver/timer/timer_dec.h:77:void pmic_watchdog_timer_reset(void);
./nano/driver/geu/geu_fuse.h:22://iSampleSize<0x200 ;need buffer for test; if test ==1,  we will test many times ,else test =2 or 0 ,we test one time
./nano/driver/geu/fuse.c:7:#include "timer_dec.h"
./nano/driver/geu/fuse.c:48:        if (uiDRO_SVT == 0) //parts were improperly fused
./nano/driver/amp/mrvl_amp.c:9:    int time_out = 0x10000;
./nano/driver/amp/mrvl_amp.c:36:    while(time_out--){
./nano/driver/amp/mrvl_amp.c:66:    bbu_printf("****    Timings based on tCK speed: 400 MHz. Check SoC PLL setup to verify DCLK frequency. \n\r");
./nano/driver/i2c/i2c_dec.c:16:#include "timer_dec.h"
./nano/driver/i2c/i2c_dec.c:193:   int time_out = 10;
./nano/driver/i2c/i2c_dec.c:194:   while(time_out){
./nano/driver/i2c/i2c_dec.c:197:         time_out -- ;
./nano/driver/i2c/i2c_dec.c:357:   bbu_printf("I2C Timeout!\n\r");
./nano/driver/i2c/i2c_dec.c:422:   bbu_printf("I2C Timeout!\n\r");
./nano/driver/i2c/i2c_dec.c:433:   uint32_t timeout;
./nano/driver/i2c/i2c_dec.c:441:      timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:445:            timeout--;
./nano/driver/i2c/i2c_dec.c:446:         if(timeout <= 0){
./nano/driver/i2c/i2c_dec.c:464:   timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:468:         timeout--;
./nano/driver/i2c/i2c_dec.c:469:      if(timeout <= 0){
./nano/driver/i2c/i2c_dec.c:495:   uint32_t timeout;
./nano/driver/i2c/i2c_dec.c:515:   timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:519:      timeout--;
./nano/driver/i2c/i2c_dec.c:520:      if (timeout <= 0) {
./nano/driver/i2c/i2c_dec.c:538:   uint32_t timeout;
./nano/driver/i2c/i2c_dec.c:551:   timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:555:         timeout--;
./nano/driver/i2c/i2c_dec.c:556:      if(timeout <= 0){
./nano/driver/i2c/i2c_dec.c:576:   uint32_t timeout;
./nano/driver/i2c/i2c_dec.c:589:   timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:594:      timeout--;
./nano/driver/i2c/i2c_dec.c:595:      if(timeout <= 0){
./nano/driver/i2c/i2c_dec.c:615:   uint32_t timeout;
./nano/driver/i2c/i2c_dec.c:625:   timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:629:      timeout--;
./nano/driver/i2c/i2c_dec.c:630:      if (timeout <= 0) {
./nano/driver/i2c/i2c_dec.c:652:   uint32_t timeout;
./nano/driver/i2c/i2c_dec.c:664:   timeout = 0x4000;
./nano/driver/i2c/i2c_dec.c:669:      timeout--;
./nano/driver/i2c/i2c_dec.c:670:      if (timeout <= 0) {
./nano/arch/system_mrvl.h:5: * system_nevo.c will call pin-mux, timer initialization functions from related unit driver
./nano/arch/system_mrvl.h:84:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/system_mrvl.h:100:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/system_mrvl.h:126:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/system_mrvl.h:148:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/system_mrvl.h:181:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/system_mrvl.h:212:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/system_mrvl.h:262:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./nano/arch/cr5/cp15.h:9:#define cp15_read(opcode1,primary_reg, secondary_reg, opcode2, value) \
./nano/arch/cr5/cp15.h:10:	__asm__ __volatile__("mrc	p15, " #opcode1 ", %0, " #primary_reg ", \
./nano/arch/cr5/cp15.h:14:#define cp15_write(opcode1, primary_reg, secondary_reg, opcode2, value) \
./nano/arch/cr5/cp15.h:15:	__asm__ __volatile__("mcr	p15, " #opcode1 ", %0, " #primary_reg ", \
./nano/arch/cr5/cp15.h:23:#define cp15_reg_read(primary_reg, secondary_reg, opcode, value) \
./nano/arch/cr5/cp15.h:24:	__asm__ __volatile__("mrc	p15, 0, %0, " #primary_reg ", " #secondary_reg ",\
./nano/arch/cr5/cp15.h:27:#define cp15_reg_write(primary_reg, secondary_reg, opcode, value) \
./nano/arch/cr5/cp15.h:28:	__asm__ __volatile__("mcr	p15, 0, %0, " #primary_reg ", " #secondary_reg ", \
./nano/arch/cr5/cp15.h:35:#define cp15_reg_read2(primary_reg, secondary_reg, opcode, value) \
./nano/arch/cr5/cp15.h:36:	__asm__ __volatile__("mrc	p15, 0, %0, c" #primary_reg ", c" #secondary_reg ",\
./nano/arch/cr5/cp15.h:39:#define cp15_reg_write2(primary_reg, secondary_reg, opcode, value) \
./nano/arch/cr5/cp15.h:40:	__asm__ __volatile__("mcr	p15, 0, %0, c" #primary_reg ", c" #secondary_reg ",\
./nano/arch/cr5/cp15.h:47:#define cp15_reg_read3(primary_reg, secondary_reg, opcode, value) \
./nano/arch/cr5/cp15.h:48:	__asm__ __volatile__("mrc	p15, 0, %0, " primary_reg ", " secondary_reg",\
./nano/arch/cr5/cp15.h:51:#define cp15_reg_write3(primary_reg, secondary_reg, opcode, value) \
./nano/arch/cr5/cp15.h:52:	__asm__ __volatile__("mcr	p15, 0, %0, " primary_reg ", " secondary_reg",\
./nano/arch/cr5/config_s.h:5:@ ---   Unless otherwise specified, CPU1 is the primary CPU
./nano/arch/cr5/startup_mrvl.S:127:    .globl kern_image_size
./nano/arch/cr5/startup_mrvl.S:128:    kern_image_size:   .word (__kern_size__ - _entry)
./nano/arch/cr5/startup_mrvl.S:165:@ //CSWCR(0xd02500AC), CR5 is exiting D2 or not (in NZ3 design, CR5 and MSA are power down/up at the same time)
./nano/arch/cr5/startup_mrvl.S:473:    @NOP                         /* can't access banked reg immediately *//*not access two banked register continuously now*/
./nano/arch/cr5/startup_mrvl.S:588:   @ NOP                         /* can't access banked reg immediately */ /*not access two banked register continuously now*/
./nano/arch/cr5/cache/cache_l2c310.c:312:    the first time. SW must not rely on the default value of these registers. These values 
./nano/arch/cr5/cache/cache_l2c310.c:313:    may also require asjustment when core frequency is changing, similar to Vcc_main.    
./nano/arch/cr5/cache/cache_l2c310.c:316:   //We don't have solution on PP change sync yet. simply set 2 cycles and don't change it
./nano/arch/system_mrvl.c:15:#include "timer_dec.h"
./nano/arch/system_mrvl.c:30:extern void sys_timer_init(void);
./nano/arch/system_mrvl.c:87:    sys_timer_init();
./nano/arch/system_mrvl.c:146:    sys_timer_init();
./nano/arch/system_mrvl.c:154:    //init all I2C unit after init timer, need delay when init i2c
./nano/app/memory/core_tests.c:10:#include "timer_dec.h"
./nano/app/memory/core_tests.c:1782:   tmsec = timer_get_count(0);
./nano/app/memory/core_tests.c:1803:   count = timer_get_count(0);
./nano/app/memory/core_tests.c:1805://   tmsec = (timer_get_count(0) - tmsec)/TIMER0_TICK_PER_MSEC;
./nano/app/memory/core_tests.c:1806:   bbu_printf("\n\r  Elapsed time: %d msec\n\r", tmsec);
./nano/app/memory/core_tests.c:1841:   uint32_t  startAddr, test_times;
./nano/app/memory/core_tests.c:1842:   test_times = 1;
./nano/app/memory/core_tests.c:1857:         test_times = conv_dec((char *)argv[4]);
./nano/app/memory/core_tests.c:1862:         for(uint32_t i = 0; i < test_times; i++){
./nano/app/memory/mem_tests.c:5:#include "timer_dec.h"
./nano/app/memory/mem_tests.c:274:   uint32_t timer_count = 0;
./nano/app/memory/mem_tests.c:282:   /* It's better to use Timer 2(1.0KHZ) */
./nano/app/memory/mem_tests.c:283:   timer_count = timer_get_count(0);
./nano/app/memory/mem_tests.c:376:   timer_count = timer_get_count(0) - timer_count;
./nano/app/memory/mem_tests.c:377:   msec = count_2_msec(timer_count);
./nano/app/memory/mem_tests.c:380:   bbu_printf("\n\rmemt--> Elapsed test time = %d.%d seconds \n\r", sec, msec);
./nano/app/main/bl_main.c:4:#include "tim.h"
./nano/app/main/bl_main.c:16:static void load_images(void)
./nano/app/main/bl_main.c:18:    TIM tim;
./nano/app/main/bl_main.c:19:    int imageNum, imageSize, i;
./nano/app/main/bl_main.c:21:    SetTIMPointers((uint8_t *)0xd1000000, &tim);
./nano/app/main/bl_main.c:22:    imageNum = get_image_number(&tim);
./nano/app/main/bl_main.c:24:    for(i = 0; i < imageNum; i++){
./nano/app/main/bl_main.c:25:        pImage = ReturnPImgPtr(&tim, i);
./nano/app/main/bl_main.c:47:        load_images();
./nano/app/main/cr5_nano_sec.lds:42:        *timer.o(.text*)
./nano/app/main/bbu.h:32://#define BBU_TEST_TIMEOUT    (1<<3)    /* Do not receive ack from test owner in time */
./nano/app/main/bbu.h:38:#define BBU_TEST_TIMEOUT    4    /* Do not receive ack from test owner in time */
./nano/app/main/cr5_nano.lds:42:        *timer.o(.text*)
./nano/app/common/dma_nano_test.c:3:#include "timer_dec.h"
./nano/app/common/dma_nano_test.c:79:        bbu_printf("DMA: transfer data timeout!\r\n");
./nano/app/common/ddr_sweep.c:5:#include "timer_dec.h"
./nano/app/common/bbu_help.c:47:   bbu_printf(" Usage: mtsp <address> <size> <tests> [<test times>]\n\r");
./nano/app/common/bbu_help.c:54:   bbu_printf("  test times = number for repeating tests. default: 1\n\r");
./nano/app/common/bbu_help.c:112:void bbu_timer_help(void){
./nano/app/common/bbu_help.c:114:   bbu_printf("\n\rdelay - Command to test timers.");
./nano/app/common/common_tests.c:5:#include "timer_dec.h"
./nano/app/common/read_write.c:8:#include "timer_dec.h"
./nano/app/common/mcu_generate_pattern.c:32:#include "timer_dec.h"
./nano/app/common/utils.c:3:#include "timer_dec.h"
./nano/app/common/utils.c:89:uint32_t XpStrToDecimal(char * pStr)
./nano/app/common/utils.c:99:            DEBUGMSG(DBG_LEVEL,("Xp err: invalid decimal value\r\n"));
./nano/app/common/utils.c:112:        return XpStrToDecimal(pStr);
./nano/app/common/utils.c:122:   uint32_t time, cycle, freq;
./nano/app/common/utils.c:128:   time = timer_get_count(0);
./nano/app/common/utils.c:141:   time = timer_get_count(0) - time;
./nano/app/common/utils.c:149:   freq = freq/time;
./nano/app/common/utils.c:153:      bbu_printf("mcps--> Elapse timer count is %d\n\r", time);
./nano/app/common/utils.c:157:   freq = freq/time;
./nano/app/common/utils.c:337:	 * Macros: loop-t-times; and loop-t-times, t>0
./nano/app/common/ddr_sweep_driver.c:5:#include "timer_dec.h"
./nano/app/common/ddr_sweep_driver.c:867:int dqs_swp_test(uint32_t phsel_test_bytes,uint32_t phsel_test_bytes1, int dqs_map, int is_simu)
./nano/app/common/ddr_sweep_driver.c:913:		if(is_simu&&(dqs0 == dqs1)&&(dqs1==dqs2)&&(dqs2==dqs3))
./nano/app/common/ddr_sweep_driver.c:915:		else if(!is_simu)
./nano/app/cli/cli.c:71:   {"immc",   bbu_mmc_init, "eMMC init cmd"},
./nano/app/cli/cli.c:279:    //the Rx timeout interrupt indicates there are trailing bytes, need to follow the steps in manual
./nano/app/cli/cli.c:286:    if ((uart_iir & IIR_IID10_MSK)==SHIFT1(0x2)) {//If Rx FIFO/timeout interrupt 
./nano/app/cli/cli.c:287:        if (uart_iir & IIR_TOD) { //timeout interrupt
./nano/app/cli/cli.c:288:            //step2: disable the Rx timeout interrupt
./nano/app/cli/cli.c:307:            //step5: no more data in FIFO,re-enable Receive Timeout
./nano/app/cli/cli.c:410:    /* Loop, executing commands everytime the user presses <ENTER> */
Binary file ./obj/arm/cr5.elf matches
./obj/arm/.objlibfile:1:/home/feature_phone/crane/app/cli/obj/arm/cli.o /home/feature_phone/crane/app/cli/obj/arm/cli_comp.o /home/feature_phone/crane/app/console/obj/arm/console.o /home/feature_phone/crane/app/main/obj/arm/main.o /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o /home/feature_phone/crane/app/i2c/obj/arm/i2c_ao.o /home/feature_phone/crane/app/i2c/obj/arm/i2c_comp.o /home/feature_phone/crane/app/common/obj/arm/ao_info.o /home/feature_phone/crane/app/common/obj/arm/bbu_curm.o /home/feature_phone/crane/app/common/obj/arm/bbu_help.o /home/feature_phone/crane/app/common/obj/arm/bbu_setv.o /home/feature_phone/crane/app/common/obj/arm/common_ao.o /home/feature_phone/crane/app/common/obj/arm/common_tests.o /home/feature_phone/crane/app/common/obj/arm/cpu_pat.o /home/feature_phone/crane/app/common/obj/arm/ddr_sweep.o /home/feature_phone/crane/app/common/obj/arm/ddr_sweep_driver.o /home/feature_phone/crane/app/common/obj/arm/dma_nano_test.o /home/feature_phone/crane/app/common/obj/arm/dtc.o /home/feature_phone/crane/app/common/obj/arm/lcd_test.o /home/feature_phone/crane/app/common/obj/arm/mcu_generate_pattern.o /home/feature_phone/crane/app/common/obj/arm/md5.o /home/feature_phone/crane/app/common/obj/arm/mfp_tests.o /home/feature_phone/crane/app/common/obj/arm/offline_test.o /home/feature_phone/crane/app/common/obj/arm/utils.o /home/feature_phone/crane/app/memory/obj/arm/bbu_memt.o /home/feature_phone/crane/app/memory/obj/arm/cacheI.o /home/feature_phone/crane/app/memory/obj/arm/cacheI_data.o /home/feature_phone/crane/app/memory/obj/arm/cache-test.o /home/feature_phone/crane/app/memory/obj/arm/core_tests.o /home/feature_phone/crane/app/memory/obj/arm/dcache_test.o /home/feature_phone/crane/app/memory/obj/arm/mem_hotplug.o /home/feature_phone/crane/app/memory/obj/arm/mem_tests.o /home/feature_phone/crane/app/memory/obj/arm/vm_manager.o /home/feature_phone/crane/app/memory/obj/arm/cacheI_asm.o /home/feature_phone/crane/app/memory/obj/arm/ddr_burst.o /home/feature_phone/crane/app/stress/obj/arm/sched_ao.o /home/feature_phone/crane/app/stress/obj/arm/stress_ao.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/core_list_join.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/core_main.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/core_matrix.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/core_portme.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/core_state.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/core_util.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/cvt.o /home/feature_phone/crane/app/benchmark/coremark/obj/arm/ee_printf.o /home/feature_phone/crane/app/benchmark/linpack/obj/arm/linpack.o /home/feature_phone/crane/app/benchmark/superpi/obj/arm/fftsg_h.o /home/feature_phone/crane/app/benchmark/superpi/obj/arm/pi_fftcs.o /home/feature_phone/crane/app/benchmark/dhrystone/obj/arm/drys_1.o /home/feature_phone/crane/app/benchmark/dhrystone/obj/arm/drys_2.o /home/feature_phone/crane/app/benchmark/llcbench/obj/arm/flushall.o /home/feature_phone/crane/app/benchmark/whetstone/obj/arm/whetstone.o /home/feature_phone/crane/app/ipc/obj/arm/ipc_app.o /home/feature_phone/crane/app/ipc/obj/arm/ipc_common.o /home/feature_phone/crane/app/pmu/obj/arm/pmu_ao.o /home/feature_phone/crane/app/test/obj/arm/test_ao.o /home/feature_phone/crane/app/usb_test/obj/arm/usb_test_app.o /home/feature_phone/crane/app/dma/obj/arm/dma_ao.o /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o /home/feature_phone/crane/app/benchmark/llcbench/cachebench/obj/arm/cachebench.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/load.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/memcpy_32k.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/memcpy_feroceon.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/memcpy-only-patch.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/memcpyv5.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/memory_profile_arm_gcc.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/mrvl_fast.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/mrvl_memcpy_v2.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/mrvl_memcpy_v3-2.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/mrvl_memcpy_v3.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/mrvl_memcpy_v4.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/mrvl_memcpy_v7.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/store.o /home/feature_phone/crane/app/benchmark/tmark/src/common/obj/arm/wmemcpy.o /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/pmu_routines.o /home/feature_phone/crane/app/test/common/obj/arm/bbu_test.o /home/feature_phone/crane/arch/asr/obj/arm/system_mrvl.o /home/feature_phone/crane/arch/asr/trace/obj/arm/fault.o /home/feature_phone/crane/arch/asr/trace/obj/arm/ptrace.o /home/feature_phone/crane/arch/asr/cr5/obj/arm/startup_mrvl.o /home/feature_phone/crane/arch/asr/cr5/cache/obj/arm/cache_l2c310.o /home/feature_phone/crane/arch/asr/cr5/cache/obj/arm/cache_ops.o /home/feature_phone/crane/arch/asr/cr5/cache/obj/arm/cache_ops-r5.o /home/feature_phone/crane/arch/asr/cr5/counter/obj/arm/perf_counter.o /home/feature_phone/crane/arch/asr/cr5/mpu/obj/arm/mpu.o /home/feature_phone/crane/arch/asr/cr5/mpu/obj/arm/set_mmu.o /home/feature_phone/crane/arch/asr/cr5/mpu/obj/arm/mpu-asm.o /home/feature_phone/crane/driver/common/obj/arm/ate.o /home/feature_phone/crane/driver/common/obj/arm/bbu_malloc.o /home/feature_phone/crane/driver/common/obj/arm/bbu_mfile.o /home/feature_phone/crane/driver/common/obj/arm/bsp.o /home/feature_phone/crane/driver/common/obj/arm/gpio.o /home/feature_phone/crane/driver/common/obj/arm/interrupt.o /home/feature_phone/crane/driver/common/obj/arm/ipc.o /home/feature_phone/crane/driver/common/obj/arm/mfp.o /home/feature_phone/crane/driver/common/obj/arm/mfp-emei.o /home/feature_phone/crane/driver/common/obj/arm/plist.o /home/feature_phone/crane/driver/common/obj/arm/ripc.o /home/feature_phone/crane/driver/common/obj/arm/sm_malloc.o /home/feature_phone/crane/driver/common/obj/arm/tim.o /home/feature_phone/crane/driver/printer/obj/arm/print.o /home/feature_phone/crane/driver/uart/obj/arm/uart.o /home/feature_phone/crane/driver/timer/obj/arm/rtc.o /home/feature_phone/crane/driver/timer/obj/arm/wdt.o /home/feature_phone/crane/driver/timer/obj/arm/clock.o /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o /home/feature_phone/crane/driver/i2c/obj/arm/i2c_dec.o /home/feature_phone/crane/driver/pmic/obj/arm/dummy.o /home/feature_phone/crane/driver/pmic/obj/arm/pm8xx_lib.o /home/feature_phone/crane/driver/pmic/obj/arm/pmic.o /home/feature_phone/crane/driver/pmic/obj/arm/procida.o /home/feature_phone/crane/driver/pmic/obj/arm/ustica.o /home/feature_phone/crane/driver/pmu/obj/arm/cr5_idle.o /home/feature_phone/crane/driver/pmu/obj/arm/lpm_cr5.o /home/feature_phone/crane/driver/pmu/obj/arm/msa.o /home/feature_phone/crane/driver/pmu/obj/arm/msa_tests.o /home/feature_phone/crane/driver/pmu/obj/arm/ppset_cr5.o /home/feature_phone/crane/driver/pmu/obj/arm/pwr_init.o /home/feature_phone/crane/driver/pmu/obj/arm/reset.o /home/feature_phone/crane/driver/pmu/obj/arm/retention.o /home/feature_phone/crane/driver/pmu/obj/arm/wakeup_cr5.o /home/feature_phone/crane/driver/pmu/obj/arm/cr5_asm.o /home/feature_phone/crane/driver/amp/obj/arm/mrvl_amp.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_ch9.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_close.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_common.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_dev_list.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_main.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_rcv.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_shut.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_snd.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/host_unr.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/ic_usb.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/msc_commands.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/usb_classes.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/usb_dev_platform.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/usb_mass_bo.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/usb_mass_queue.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/usb_mass_ufi.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_bw.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_cncl.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_intr.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_iso.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_main.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_shut.o /home/feature_phone/crane/driver/usb/usb_sph/src/obj/arm/vusbhs_host_utl.o /home/feature_phone/crane/driver/camera/obj/arm/buf_mgr.o /home/feature_phone/crane/driver/camera/obj/arm/camera_spi_gc032a_test.o /home/feature_phone/crane/driver/camera/obj/arm/camera_test.o /home/feature_phone/crane/driver/camera/obj/arm/dp650_fns.o /home/feature_phone/crane/driver/camera/obj/arm/scaler_rotation.o /home/feature_phone/crane/driver/misc/obj/arm/pwm.o /home/feature_phone/crane/driver/dma/obj/arm/dma.o /home/feature_phone/crane/driver/dma/obj/arm/squ_dma.o /home/feature_phone/crane/driver/lcd/obj/arm/dummy_mcu.o /home/feature_phone/crane/driver/lcd/obj/arm/dummy_spi.o /home/feature_phone/crane/driver/lcd/obj/arm/lcd_drv.o /home/feature_phone/crane/driver/lcd/obj/arm/lcd_fns.o /home/feature_phone/crane/driver/lcd/obj/arm/lcd_gc9305_mcu.o /home/feature_phone/crane/driver/lcd/obj/arm/lcd_gc9305_spi.o /home/feature_phone/crane/driver/lcd/obj/arm/lcd_hal.o /home/feature_phone/crane/driver/lcd/obj/arm/mcu_drv.o /home/feature_phone/crane/driver/lcd/obj/arm/panel_drv.o /home/feature_phone/crane/driver/lcd/obj/arm/spi_drv.o /home/feature_phone/crane/app/benchmark/tmark/obj/arm/tmark.a -L/home/feature_phone/crane/extlib -lqpc_cr5
Binary file ./obj/arm/cr5.bin matches
./obj/arm/cr5.map:48:                              /home/feature_phone/crane/driver/common/obj/arm/bsp.o (QTimer_register)
./obj/arm/cr5.map:56:                              /home/feature_phone/crane/app/i2c/obj/arm/i2c_ao.o (QTimeEvt_armX)
./obj/arm/cr5.map:58:                              /home/feature_phone/crane/app/i2c/obj/arm/i2c_ao.o (QTimeEvt_ctorX)
./obj/arm/cr5.map:60:                              /home/feature_phone/crane/app/i2c/obj/arm/i2c_ao.o (QTimeEvt_disarm)
./obj/arm/cr5.map:72:                              /home/feature_phone/crane/extlib/libqpc_cr5.a(qf_tick.o) (QTimeEvt_yell)
./obj/arm/cr5.map:102:                              /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o (__aeabi_ldivmod)
./obj/arm/cr5.map:112:                              /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o (__assert_func)
./obj/arm/cr5.map:123:/home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:124:                              /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-exit.o) (_global_impure_ptr)
./obj/arm/cr5.map:292:                              /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o (ceil)
./obj/arm/cr5.map:338:lowinv              0x8               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:346:b                   0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:349:highinv             0x8               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:352:User_Time           0x8               /home/feature_phone/crane/app/benchmark/dhrystone/obj/arm/drys_1.o
./obj/arm/cr5.map:355:Begin_Time          0x4               /home/feature_phone/crane/app/benchmark/dhrystone/obj/arm/drys_1.o
./obj/arm/cr5.map:356:two_to_phi          0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:362:sn                  0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:378:End_Time            0x4               /home/feature_phone/crane/app/benchmark/dhrystone/obj/arm/drys_1.o
./obj/arm/cr5.map:381:permute             0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:390:cn                  0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:391:high                0x8               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:395:c                   0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:396:low                 0x8               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:419:int_dummy           0x4               /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:421:two_to_minusphi     0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:430:scrambled           0x4               /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:436:QF_timer_           0x28              /home/feature_phone/crane/extlib/libqpc_cr5.a(qf_tick.o)
./obj/arm/cr5.map:439:QF_timeEvtHead_     0x30              /home/feature_phone/crane/extlib/libqpc_cr5.a(qf_tick.o)
./obj/arm/cr5.map:508: .text          0x0000000000000000        0x0 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:509: .data          0x0000000000000000        0x0 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:510: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:512:                0x0000000000000000       0x2f /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:801: .text.vm_minimum_free_area_init
./obj/arm/cr5.map:1032: .text          0x0000000000000000        0x0 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:1033: .data          0x0000000000000000        0x0 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:1034: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:1036:                0x0000000000000000       0xa0 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:1037: .text.RINT     0x0000000000000000       0x28 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:1038: .text          0x0000000000000000        0x0 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:1039: .data          0x0000000000000000        0x0 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:1040: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:1104: .text          0x0000000000000000        0x0 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1105: .data          0x0000000000000000        0x0 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1106: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1107: .init_array    0x0000000000000000        0x4 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1108: .fini_array    0x0000000000000000        0x4 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1110:                0x0000000000000000      0x24c /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1112:                0x0000000000000000      0x45d /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:1461: .text          0x0000000000000000        0x0 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1462: .data          0x0000000000000000        0x0 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1463: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1465:                0x0000000000000000      0x1d8 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1467:                0x0000000000000000       0xc8 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1468: .text.get_image_number
./obj/arm/cr5.map:1469:                0x0000000000000000       0x2c /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1470: .text.get_image_size
./obj/arm/cr5.map:1471:                0x0000000000000000       0xc8 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1472: .text.load_image_from_flash
./obj/arm/cr5.map:1473:                0x0000000000000000      0x164 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1474: .debug_info    0x0000000000000000      0x977 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1475: .debug_abbrev  0x0000000000000000      0x1c0 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1477:                0x0000000000000000       0x40 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1478: .debug_ranges  0x0000000000000000       0x30 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1479: .debug_line    0x0000000000000000      0x204 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1480: .debug_str     0x0000000000000000      0x767 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1481: .comment       0x0000000000000000       0x7f /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1482: .debug_frame   0x0000000000000000       0xc4 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1484:                0x0000000000000000       0x35 /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:1497: .text          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:1498: .data          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:1499: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:1501:                0x0000000000000000       0x50 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:1503:                0x0000000000000000       0xcc /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:1505:                0x0000000000000000       0xcc /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:1506: .text          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:1507: .data          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:1508: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:1509: .text          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:1510: .data          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:1511: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:1513:                0x0000000000000000       0x60 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:1514: .text.bbu_get_system_time
./obj/arm/cr5.map:1515:                0x0000000000000000      0x1b0 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:1516: .text.bbu_strftime
./obj/arm/cr5.map:1517:                0x0000000000000000      0x158 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:1518: .text          0x0000000000000000       0x30 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1519: .data          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1520: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1521: .debug_line    0x0000000000000000       0x6d /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1522: .debug_info    0x0000000000000000       0x26 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1523: .debug_abbrev  0x0000000000000000       0x14 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1525:                0x0000000000000000       0x20 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1526: .debug_str     0x0000000000000000       0x5c /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1528:                0x0000000000000000       0x25 /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:1529: .text          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1530: .data          0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1531: .bss           0x0000000000000000        0x0 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1532: .bss.timer_irq_inited
./obj/arm/cr5.map:1533:                0x0000000000000000       0x18 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1534: .text.start_specific_timer
./obj/arm/cr5.map:1535:                0x0000000000000000       0x78 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1536: .text.restart_timer
./obj/arm/cr5.map:1537:                0x0000000000000000       0xf8 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1539:                0x0000000000000000       0x44 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1541:                0x0000000000000000       0x34 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1543:                0x0000000000000000       0x44 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1545:                0x0000000000000000        0xe /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:1673: .text.procida_get_start_ramp_time_setting
./obj/arm/cr5.map:1704: .text.ustica_get_start_ramp_time_setting
./obj/arm/cr5.map:1775: .text.pmic_watchdog_timer_reset
./obj/arm/cr5.map:1808: .text.cp_assert_timer_handler
./obj/arm/cr5.map:1902: .text.simple_test_hsic_speed
./obj/arm/cr5.map:1952: .text.timer_irq
./obj/arm/cr5.map:2457: .text          0x0000000000000000        0x0 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:2458: .data          0x0000000000000000        0x0 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:2459: .bss           0x0000000000000000        0x0 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:2460: .rodata._global_impure_ptr
./obj/arm/cr5.map:2461:                0x0000000000000000        0x4 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:2712: .text._reclaim_reent
./obj/arm/cr5.map:3013:LOAD /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:3067:LOAD /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:3068:LOAD /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:3084:LOAD /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:3110:LOAD /home/feature_phone/crane/driver/common/obj/arm/tim.o
./obj/arm/cr5.map:3113:LOAD /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:3114:LOAD /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:3115:LOAD /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:3116:LOAD /home/feature_phone/crane/driver/timer/obj/arm/delay-mmp.o
./obj/arm/cr5.map:3117:LOAD /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:3202:                0x0000000000000090                kern_image_size
./obj/arm/cr5.map:3488: .text.Timer_ctor
./obj/arm/cr5.map:3489:                0x00000000d100b9f0       0x3c /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:3490:                0x00000000d100b9f0                Timer_ctor
./obj/arm/cr5.map:3491: .text.Timer_initial
./obj/arm/cr5.map:3492:                0x00000000d100ba2c       0x38 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:3493: .text.Timer_process
./obj/arm/cr5.map:3494:                0x00000000d100ba64      0x108 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:3516: .text.disarm_i2c_time_evt
./obj/arm/cr5.map:3518:                0x00000000d100cdb8                disarm_i2c_time_evt
./obj/arm/cr5.map:3648: .text.bbu_timer_help
./obj/arm/cr5.map:3650:                0x00000000d1010034                bbu_timer_help
./obj/arm/cr5.map:3919: .text.XpStrToDecimal
./obj/arm/cr5.map:3921:                0x00000000d1023e70                XpStrToDecimal
./obj/arm/cr5.map:4299: .text.start_time
./obj/arm/cr5.map:4301:                0x00000000d10336b4                start_time
./obj/arm/cr5.map:4302: .text.stop_time
./obj/arm/cr5.map:4304:                0x00000000d10336d8                stop_time
./obj/arm/cr5.map:4305: .text.get_time
./obj/arm/cr5.map:4307:                0x00000000d10336fc                get_time
./obj/arm/cr5.map:4308: .text.time_in_secs
./obj/arm/cr5.map:4310:                0x00000000d1033724                time_in_secs
./obj/arm/cr5.map:4342: .text.print_time
./obj/arm/cr5.map:4344:                0x00000000d1034194                print_time
./obj/arm/cr5.map:4426: .text.mp_unsgn_imul
./obj/arm/cr5.map:4428:                0x00000000d1042824                mp_unsgn_imul
./obj/arm/cr5.map:4429: .text.mp_imul  0x00000000d1042ae8       0xb0 /home/feature_phone/crane/app/benchmark/superpi/obj/arm/pi_fftcs.o
./obj/arm/cr5.map:4430:                0x00000000d1042ae8                mp_imul
./obj/arm/cr5.map:4626:                0x00000000d104cad0       0x98 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4629:                0x00000000d104cb68       0xf0 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4632:                0x00000000d104cc58      0x6bc /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4635:                0x00000000d104d314      0x7bc /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4638:                0x00000000d104dad0       0xd8 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4640: .text.squareg  0x00000000d104dba8       0x38 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4643:                0x00000000d104dbe0      0x1dc /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4646:                0x00000000d104ddbc      0x3b8 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4648: .text.patch    0x00000000d104e174      0x744 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4651:                0x00000000d104e8b8      0x158 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4654:                0x00000000d104ea10      0x12c /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4656: .text.isszero  0x00000000d104eb3c       0x6c /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4659:                0x00000000d104eba8      0x160 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4662:                0x00000000d104ed08      0x184 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4665:                0x00000000d104ee8c       0x74 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4668:                0x00000000d104ef00      0x25c /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:4670: .text.g        0x00000000d104f15c      0x270 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:4671: .text.calc_print_biggest_prime
./obj/arm/cr5.map:4672:                0x00000000d104f3cc      0x39c /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:4673:                0x00000000d104f3cc                calc_print_biggest_prime
./obj/arm/cr5.map:4727:                0x00000000d1051200       0x34 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:4730:                0x00000000d1051238       0x1c /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:4732: .text.mrvl_times
./obj/arm/cr5.map:4733:                0x00000000d1051258      0x138 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:4734:                0x00000000d1051258                mrvl_times
./obj/arm/cr5.map:5009: .text.sys_timer_handle
./obj/arm/cr5.map:5240: .text.rtc_irq  0x00000000d1059f14       0x84 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:5242:                0x00000000d1059f98      0x11c /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:5245:                0x00000000d105a0b4       0x6c /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:5248:                0x00000000d105a120       0x60 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:5251:                0x00000000d105a180       0x34 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5253:                0x00000000d105a1b4       0x3c /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5255:                0x00000000d105a1f0       0x38 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5257:                0x00000000d105a228       0x28 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5258: .text.wdt_irq  0x00000000d105a250       0x98 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5260:                0x00000000d105a2e8       0xd4 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5263:                0x00000000d105a3bc       0x20 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:5266: .text.print_current_time
./obj/arm/cr5.map:5267:                0x00000000d105a3e0      0x150 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:5268:                0x00000000d105a3e0                print_current_time
./obj/arm/cr5.map:5270:                0x00000000d105a530       0x40 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:5273:                0x00000000d105a570       0x54 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:5275: .text.get_timer_irq
./obj/arm/cr5.map:5276:                0x00000000d105a5c4       0x48 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5277: .text.timer_table_idx
./obj/arm/cr5.map:5278:                0x00000000d105a60c       0xc4 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5279: .text.timer_clock_select
./obj/arm/cr5.map:5280:                0x00000000d105a6d0      0x134 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5281: .text.apb_timer_reset
./obj/arm/cr5.map:5282:                0x00000000d105a804       0x64 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5283:                0x00000000d105a804                apb_timer_reset
./obj/arm/cr5.map:5284: .text.apb_systimer_init
./obj/arm/cr5.map:5285:                0x00000000d105a868      0x12c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5286:                0x00000000d105a868                apb_systimer_init
./obj/arm/cr5.map:5287: .text.sys_timer_init
./obj/arm/cr5.map:5288:                0x00000000d105a994       0x24 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5289:                0x00000000d105a994                sys_timer_init
./obj/arm/cr5.map:5291:                0x00000000d105a9b8       0x50 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5293:                0x00000000d105aa08       0x6c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5295:                0x00000000d105aa74       0x40 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5297:                0x00000000d105aab4       0x40 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5299:                0x00000000d105aaf4       0xa8 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5301: .text.timer_get_count
./obj/arm/cr5.map:5302:                0x00000000d105ab9c       0x34 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5303:                0x00000000d105ab9c                timer_get_count
./obj/arm/cr5.map:5304: .text.timer_tick_delay
./obj/arm/cr5.map:5305:                0x00000000d105abd0       0x6c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5306: .text.udelay   0x00000000d105ac3c       0x74 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5308: .text.mdelay   0x00000000d105acb0       0x34 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5310: .text.timeout_mdelay
./obj/arm/cr5.map:5311:                0x00000000d105ace4       0x98 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5312:                0x00000000d105ace4                timeout_mdelay
./obj/arm/cr5.map:5313: .text.delay    0x00000000d105ad7c       0x44 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5315: .text.generic_timer_config
./obj/arm/cr5.map:5316:                0x00000000d105adc0       0x68 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5317:                0x00000000d105adc0                generic_timer_config
./obj/arm/cr5.map:5318: .text.generic_timer_read
./obj/arm/cr5.map:5319:                0x00000000d105ae28       0x78 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5320:                0x00000000d105ae28                generic_timer_read
./obj/arm/cr5.map:5321: .text.timer_preload_comparator
./obj/arm/cr5.map:5322:                0x00000000d105aea0       0x6c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5323: .text.timer_count_enable
./obj/arm/cr5.map:5324:                0x00000000d105af0c       0x58 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5325: .text.timer_count_disable
./obj/arm/cr5.map:5326:                0x00000000d105af64      0x164 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5327: .text.timer_count_mode_set
./obj/arm/cr5.map:5328:                0x00000000d105b0c8       0x78 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5329: .text.ap_timer_irq
./obj/arm/cr5.map:5330:                0x00000000d105b140       0xd0 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5331: .text._start_timer
./obj/arm/cr5.map:5332:                0x00000000d105b210      0x408 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5333: .text._stop_timer
./obj/arm/cr5.map:5334:                0x00000000d105b618       0xc4 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5335: .text.is_timer_active
./obj/arm/cr5.map:5336:                0x00000000d105b6dc       0x64 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5337: .text.start_timer
./obj/arm/cr5.map:5338:                0x00000000d105b740      0x344 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5339:                0x00000000d105b740                start_timer
./obj/arm/cr5.map:5340: .text.stop_timer
./obj/arm/cr5.map:5341:                0x00000000d105ba84       0x84 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5342:                0x00000000d105ba84                stop_timer
./obj/arm/cr5.map:5343: .text.free_timer
./obj/arm/cr5.map:5344:                0x00000000d105bb08       0x28 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5345:                0x00000000d105bb08                free_timer
./obj/arm/cr5.map:5346: .text.timer_test_output
./obj/arm/cr5.map:5347:                0x00000000d105bb30       0x5c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5348: .text.timer_test_start
./obj/arm/cr5.map:5349:                0x00000000d105bb8c      0x16c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5350:                0x00000000d105bb8c                timer_test_start
./obj/arm/cr5.map:5351: .text.timer_test_stop
./obj/arm/cr5.map:5352:                0x00000000d105bcf8       0x78 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5353:                0x00000000d105bcf8                timer_test_stop
./obj/arm/cr5.map:5354: .text.time_start_all
./obj/arm/cr5.map:5355:                0x00000000d105bd70      0x160 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5356:                0x00000000d105bd70                time_start_all
./obj/arm/cr5.map:5357: .text.timer_stop_all
./obj/arm/cr5.map:5358:                0x00000000d105bed0      0x150 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5359:                0x00000000d105bed0                timer_stop_all
./obj/arm/cr5.map:5360: .text.timer_test
./obj/arm/cr5.map:5361:                0x00000000d105c020      0x244 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5362:                0x00000000d105c020                timer_test
./obj/arm/cr5.map:5364:                0x00000000d105c264       0x34 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5366: .text._start_timer_clk
./obj/arm/cr5.map:5367:                0x00000000d105c298       0x5c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5368: .text.start_timer_wakeup
./obj/arm/cr5.map:5369:                0x00000000d105c2f4      0x1b8 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:5370:                0x00000000d105c2f4                start_timer_wakeup
./obj/arm/cr5.map:5799: .text.timer_irq
./obj/arm/cr5.map:6050: .text._usb_ehci_calculate_uframe_tr_time
./obj/arm/cr5.map:6052:                0x00000000d106e610                _usb_ehci_calculate_uframe_tr_time
./obj/arm/cr5.map:6066: .text.reclaim_band_width
./obj/arm/cr5.map:6068:                0x00000000d106fd84                reclaim_band_width
./obj/arm/cr5.map:6193: .text.buf_fill_by_img
./obj/arm/cr5.map:6195:                0x00000000d1076000                buf_fill_by_img
./obj/arm/cr5.map:6341: .text.prepare_argb8888_image
./obj/arm/cr5.map:6361: .text.draw_images
./obj/arm/cr5.map:6363:                0x00000000d107bc50                draw_images
./obj/arm/cr5.map:6580: .text.lcd_config_img
./obj/arm/cr5.map:6615: .text.prepare_argb8888_image
./obj/arm/cr5.map:6626: .text.lcd_draw_images
./obj/arm/cr5.map:6628:                0x00000000d10831e8                lcd_draw_images
./obj/arm/cr5.map:6848: .text.QTimer_register
./obj/arm/cr5.map:6850:                0x00000000d108cd8c                QTimer_register
./obj/arm/cr5.map:6856: .text.QF_noTimeEvtsActiveX
./obj/arm/cr5.map:6858:                0x00000000d108d678                QF_noTimeEvtsActiveX
./obj/arm/cr5.map:6868: .text.QTimeEvt_armODT_
./obj/arm/cr5.map:6870: .text.QTimeEvt_armX
./obj/arm/cr5.map:6872:                0x00000000d108debc                QTimeEvt_armX
./obj/arm/cr5.map:6873: .text.QTimeEvt_ctorX
./obj/arm/cr5.map:6875:                0x00000000d108df04                QTimeEvt_ctorX
./obj/arm/cr5.map:6876: .text.QTimeEvt_disarmODT_
./obj/arm/cr5.map:6878: .text.QTimeEvt_disarm
./obj/arm/cr5.map:6880:                0x00000000d108e128                QTimeEvt_disarm
./obj/arm/cr5.map:6904: .text.QTimeEvt_4LRAB
./obj/arm/cr5.map:6906:                0x00000000d108ed9c                QTimeEvt_4LRAB
./obj/arm/cr5.map:6910: .text.QTimeEvt_yell
./obj/arm/cr5.map:6912:                0x00000000d108eebc                QTimeEvt_yell
./obj/arm/cr5.map:6913: .text.QTimeEvt_isAlarm
./obj/arm/cr5.map:6915:                0x00000000d108ef00                QTimeEvt_isAlarm
./obj/arm/cr5.map:7050: .text._malloc_trim_r
./obj/arm/cr5.map:7052:                0x00000000d10927cc                _malloc_trim_r
./obj/arm/cr5.map:7426: .rodata        0x00000000d10ab644       0x64 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:7427: .rodata        0x00000000d10ab6a8       0x27 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:7429: .rodata        0x00000000d10ab6d0       0x77 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:7431: .rodata        0x00000000d10ab748      0x1c0 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:7503: .rodata.AO_Timer
./obj/arm/cr5.map:7504:                0x00000000d10b1750        0x4 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:7505:                0x00000000d10b1750                AO_Timer
./obj/arm/cr5.map:7612: .rodata.print_time.str1.4
./obj/arm/cr5.map:7654:                0x00000000d10b27ac        0xf /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:7657:                0x00000000d10b27bc       0x58 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:7659:                0x00000000d10b2814       0x20 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:7662:                0x00000000d10b2834        0x3 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:7666:                0x00000000d10b2838      0x115 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:7668: .rodata.calc_print_biggest_prime.str1.4
./obj/arm/cr5.map:7669:                0x00000000d10b2950       0xe3 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:7690:                0x00000000d10b2f64        0x8 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:7692:                0x00000000d10b2f6c        0xc /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:7694:                0x00000000d10b2f78        0xb /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8175: .data.N        0x00000000d10b58c8        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8176: .data.U        0x00000000d10b58cc        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8177: .data.e        0x00000000d10b58d0        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8178: .data.m        0x00000000d10b58d4        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8212: .data.timer    0x00000000d10b59f4        0x8 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8213:                0x00000000d10b59f4                timer
./obj/arm/cr5.map:8214: .data.timer_mmp_irq
./obj/arm/cr5.map:8215:                0x00000000d10b59fc       0x18 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8216:                0x00000000d10b59fc                timer_mmp_irq
./obj/arm/cr5.map:8217: .data.wakeup_timer_remain
./obj/arm/cr5.map:8218:                0x00000000d10b5a14        0x4 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8219: .data.timer_table
./obj/arm/cr5.map:8220:                0x00000000d10b5a18       0x78 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8297: .data.lcd_dummy_mcu_timing
./obj/arm/cr5.map:8306: .data.lcd_dummy_spi_timing
./obj/arm/cr5.map:8321: .data.lcd_gc9305_mcu_timing
./obj/arm/cr5.map:8330: .data.lcd_gc9305_spi_timing
./obj/arm/cr5.map:8357: .data._impure_ptr
./obj/arm/cr5.map:8358:                0x00000000d10b88b4        0x4 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:8359:                0x00000000d10b88b4                _impure_ptr
./obj/arm/cr5.map:8360: .data.impure_data
./obj/arm/cr5.map:8361:                0x00000000d10b88b8      0x428 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:8371: .data.__malloc_trim_threshold
./obj/arm/cr5.map:8373:                0x00000000d10b9258                __malloc_trim_threshold
./obj/arm/cr5.map:8406: .bss.l_timerQSto
./obj/arm/cr5.map:8432: .bss.l_timer   0x00000000d1123adc       0x34 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:8535: .bss.start_time_val
./obj/arm/cr5.map:8537: .bss.stop_time_val
./obj/arm/cr5.map:8553: .bss.ntimes.7390
./obj/arm/cr5.map:8556: .bss.time      0x00000000d11c3350      0x288 /home/feature_phone/crane/app/benchmark/linpack/obj/arm/linpack.o
./obj/arm/cr5.map:8572: .bss.a         0x00000000d11c3d34        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8573: .bss.c         0x00000000d11c3d38        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8574: .bss.i         0x00000000d11c3d3c        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8575: .bss.p         0x00000000d11c3d40        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8576: .bss.s         0x00000000d11c3d44        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8577: .bss.t         0x00000000d11c3d48        0x4 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:8582: .bss.timer_used
./obj/arm/cr5.map:8584: .bss.timeslots
./obj/arm/cr5.map:8586: .bss.ccnt      0x00000000d11c3d5c        0x8 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8587: .bss.counter0  0x00000000d11c3d64        0x8 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8588: .bss.counter1  0x00000000d11c3d6c        0x8 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8589: .bss.counter2  0x00000000d11c3d74        0x8 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8590: .bss.counter3  0x00000000d11c3d7c        0x8 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8591: .bss.ut        0x00000000d11c3d84        0x8 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8592: .bss.uti       0x00000000d11c3d8c        0x4 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8637:                0x00000000d11c40f4       0x78 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8638: .bss.timer_info
./obj/arm/cr5.map:8639:                0x00000000d11c416c       0x48 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:8772:                0x00000000d11c56d8                User_Time
./obj/arm/cr5.map:8773:                0x00000000d11c56e0                Begin_Time
./obj/arm/cr5.map:8775:                0x00000000d11c7df4                End_Time
./obj/arm/cr5.map:8796: COMMON         0x00000000d11c8190       0x48 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:8809: COMMON         0x00000000d11c81d8        0x4 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:8870:                0x00000000d11cad50                QF_timer_
./obj/arm/cr5.map:8871:                0x00000000d11cad78                QF_timeEvtHead_
./obj/arm/cr5.map:8925:                0x00000000000000ed       0x35 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:9021:                0x0000000000000acd       0x35 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:9023:                0x0000000000000b02       0x35 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:9049:                0x0000000000000d03       0x35 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:9097:                0x00000000000011bb       0x35 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:9099:                0x00000000000011f0       0x35 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:9101:                0x0000000000001225       0x35 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:9103:                0x000000000000125a       0x35 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:9331:                0x0000000000002808       0x29 /home/shsw/opt/gcc-arm-none-eabi-7-2017-q4-major/bin/../lib/gcc/arm-none-eabi/7.2.1/../../../../arm-none-eabi/lib/thumb/v7-ar/libg.a(lib_a-impure.o)
./obj/arm/cr5.map:9491: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:9538: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:9539: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:9541: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:9561: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:9562: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:9563: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:9564: .comment       0x000000000000007e       0x7f /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:9663: .debug_info    0x0000000000006c14     0x1c8f /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:9711: .debug_info    0x0000000000053a65     0x2409 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:9712: .debug_info    0x0000000000055e6e     0x14fa /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:9725: .debug_info    0x000000000005a0fc      0x3fc /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:9749: .debug_info    0x00000000000722ce     0x161a /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:9750: .debug_info    0x00000000000738e8     0x176d /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:9751: .debug_info    0x0000000000075055     0x1505 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:9752: .debug_info    0x000000000007655a     0x2aa2 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:9851: .debug_abbrev  0x0000000000000a65      0x2be /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:9899: .debug_abbrev  0x0000000000008ec9      0x4c4 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:9900: .debug_abbrev  0x000000000000938d      0x2a7 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:9913: .debug_abbrev  0x0000000000009b87      0x1b5 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:9937: .debug_abbrev  0x000000000000ce42      0x297 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:9938: .debug_abbrev  0x000000000000d0d9      0x298 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:9939: .debug_abbrev  0x000000000000d371      0x26b /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:9940: .debug_abbrev  0x000000000000d5dc      0x494 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:10044:                0x00000000000000f8       0x30 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:10140:                0x0000000000001688       0xa8 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:10142:                0x0000000000001730       0x28 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:10168:                0x0000000000001970       0x30 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:10216:                0x00000000000023f8       0x50 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:10218:                0x0000000000002448       0x50 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:10220:                0x0000000000002498       0x48 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:10222:                0x00000000000024e0      0x178 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:10409: .debug_ranges  0x00000000000000d0       0x20 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:10455: .debug_ranges  0x0000000000001da8       0xd8 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:10456: .debug_ranges  0x0000000000001e80       0x18 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:10458: .debug_ranges  0x0000000000001f40       0x68 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:10478: .debug_ranges  0x0000000000002870       0x40 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:10479: .debug_ranges  0x00000000000028b0       0x40 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:10480: .debug_ranges  0x00000000000028f0       0x38 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:10481: .debug_ranges  0x0000000000002928      0x168 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:10576: .debug_line    0x0000000000000fe7      0x302 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:10624: .debug_line    0x00000000000147bd      0xcc5 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:10625: .debug_line    0x0000000000015482      0x469 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:10638: .debug_line    0x0000000000017446      0x12f /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:10662: .debug_line    0x000000000001caea      0x37e /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:10663: .debug_line    0x000000000001ce68      0x354 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:10664: .debug_line    0x000000000001d1bc      0x34f /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:10665: .debug_line    0x000000000001d50b      0x85d /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:10768: .debug_str     0x00000000000020fb       0xa3 /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:10864: .debug_str     0x0000000000008945      0x230 /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:10866: .debug_str     0x0000000000008b75       0x76 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:10892: .debug_str     0x0000000000009187      0x397 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:10940: .debug_str     0x000000000000b9a2       0xb2 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:10942: .debug_str     0x000000000000ba54       0xa7 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:10944: .debug_str     0x000000000000bafb       0xac /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:10946: .debug_str     0x000000000000bba7      0x856 /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:11138: .debug_frame   0x00000000000002ec       0x7c /home/feature_phone/crane/app/timer/obj/arm/timer_ao.o
./obj/arm/cr5.map:11184: .debug_frame   0x00000000000058a0      0x3cc /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:11185: .debug_frame   0x0000000000005c6c       0x84 /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:11187: .debug_frame   0x000000000000610c       0x88 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./obj/arm/cr5.map:11207: .debug_frame   0x0000000000008678      0x108 /home/feature_phone/crane/driver/timer/obj/arm/rtc.o
./obj/arm/cr5.map:11208: .debug_frame   0x0000000000008780      0x100 /home/feature_phone/crane/driver/timer/obj/arm/wdt.o
./obj/arm/cr5.map:11209: .debug_frame   0x0000000000008880       0xe8 /home/feature_phone/crane/driver/timer/obj/arm/clock.o
./obj/arm/cr5.map:11210: .debug_frame   0x0000000000008968      0x63c /home/feature_phone/crane/driver/timer/obj/arm/timer_cr5.o
./obj/arm/cr5.map:11406: .debug_loc     0x0000000000015973     0x235c /home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o
./obj/arm/cr5.map:11407: .debug_loc     0x0000000000017ccf       0x3e /home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o
./obj/arm/cr5.map:11409: .debug_loc     0x0000000000019754      0x128 /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o
./arch/asr/system_mrvl.h:5: * system_nevo.c will call pin-mux, timer initialization functions from related unit driver
./arch/asr/system_mrvl.h:84:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/system_mrvl.h:100:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/system_mrvl.h:126:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/system_mrvl.h:148:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/system_mrvl.h:181:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/system_mrvl.h:212:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/system_mrvl.h:262:/*	Need to COMPLY with test_start.s or test_start_sim.s		*/
./arch/asr/trace/fault.c:14: *			current translation regime.
Binary file ./arch/asr/trace/obj/arm/ptrace.o matches
Binary file ./arch/asr/trace/obj/arm/fault.o matches
./arch/asr/trace/obj/arm/ptrace.d:34: /home/feature_phone/crane/driver/timer/timer_dec.h \
./arch/asr/trace/obj/arm/ptrace.d:37: /home/feature_phone/crane/driver/timer/clock.h
./arch/asr/trace/ptrace.c:13:#include "timer_dec.h"
./arch/asr/trace/ptrace.c:193: * Before each funtion go ahead, should have following similar code to save related register.
./arch/asr/cr5/cp15.h:9:#define cp15_read(opcode1,primary_reg, secondary_reg, opcode2, value) \
./arch/asr/cr5/cp15.h:10:	__asm__ __volatile__("mrc	p15, " #opcode1 ", %0, " #primary_reg ", \
./arch/asr/cr5/cp15.h:14:#define cp15_write(opcode1, primary_reg, secondary_reg, opcode2, value) \
./arch/asr/cr5/cp15.h:15:	__asm__ __volatile__("mcr	p15, " #opcode1 ", %0, " #primary_reg ", \
./arch/asr/cr5/cp15.h:23:#define cp15_reg_read(primary_reg, secondary_reg, opcode, value) \
./arch/asr/cr5/cp15.h:24:	__asm__ __volatile__("mrc	p15, 0, %0, " #primary_reg ", " #secondary_reg ",\
./arch/asr/cr5/cp15.h:27:#define cp15_reg_write(primary_reg, secondary_reg, opcode, value) \
./arch/asr/cr5/cp15.h:28:	__asm__ __volatile__("mcr	p15, 0, %0, " #primary_reg ", " #secondary_reg ", \
./arch/asr/cr5/cp15.h:35:#define cp15_reg_read2(primary_reg, secondary_reg, opcode, value) \
./arch/asr/cr5/cp15.h:36:	__asm__ __volatile__("mrc	p15, 0, %0, c" #primary_reg ", c" #secondary_reg ",\
./arch/asr/cr5/cp15.h:39:#define cp15_reg_write2(primary_reg, secondary_reg, opcode, value) \
./arch/asr/cr5/cp15.h:40:	__asm__ __volatile__("mcr	p15, 0, %0, c" #primary_reg ", c" #secondary_reg ",\
./arch/asr/cr5/cp15.h:47:#define cp15_reg_read3(primary_reg, secondary_reg, opcode, value) \
./arch/asr/cr5/cp15.h:48:	__asm__ __volatile__("mrc	p15, 0, %0, " primary_reg ", " secondary_reg",\
./arch/asr/cr5/cp15.h:51:#define cp15_reg_write3(primary_reg, secondary_reg, opcode, value) \
./arch/asr/cr5/cp15.h:52:	__asm__ __volatile__("mcr	p15, 0, %0, " primary_reg ", " secondary_reg",\
./arch/asr/cr5/config_s.h:5:@ ---   Unless otherwise specified, CPU1 is the primary CPU
./arch/asr/cr5/startup_mrvl.S:153:    .globl kern_image_size
./arch/asr/cr5/startup_mrvl.S:154:    kern_image_size:   .word (__kern_size__ - CR5_AREA_ST)
./arch/asr/cr5/startup_mrvl.S:320:@ //CSWCR(0xd02500AC), CR5 is exiting D2 or not (in NZ3 design, CR5 and MSA are power down/up at the same time)
./arch/asr/cr5/startup_mrvl.S:618:    @NOP                         /* can't access banked reg immediately *//*not access two banked register continuously now*/
./arch/asr/cr5/startup_mrvl.S:731:   @ NOP                         /* can't access banked reg immediately */ /*not access two banked register continuously now*/
Binary file ./arch/asr/cr5/cache/obj/arm/cache_l2c310.o matches
./arch/asr/cr5/cache/cache_l2c310.c:317:    the first time. SW must not rely on the default value of these registers. These values 
./arch/asr/cr5/cache/cache_l2c310.c:318:    may also require asjustment when core frequency is changing, similar to Vcc_main.    
./arch/asr/cr5/cache/cache_l2c310.c:321:   //We don't have solution on PP change sync yet. simply set 2 cycles and don't change it
Binary file ./arch/asr/cr5/obj/arm/startup_mrvl.o matches
./arch/asr/cr5/counter/perf_counter.h:140:      bbu_printf("Read Hit Time: %d\n\r", read_hit);   \
./arch/asr/cr5/counter/perf_counter.h:141:      bbu_printf("Read Miss Time: %d\n\r", read_miss);  \
./arch/asr/cr5/counter/perf_counter.h:142:      bbu_printf("Write Hit Time: %d\n\r", write_hit);   \
./arch/asr/cr5/counter/perf_counter.h:143:      bbu_printf("Write Miss Time: %d\n\r", write_miss);   \
./arch/asr/cr5/counter/perf_counter.h:172:      bbu_printf("L2 Cache Access Time: %d\n\r", l2_access);   \
./arch/asr/cr5/counter/perf_counter.h:173:      bbu_printf("L2 Cache Refill Time: %d\n\r", l2_refill);  \
Binary file ./arch/asr/cr5/counter/obj/arm/perf_counter.o matches
Binary file ./arch/asr/cr5/mpu/obj/arm/mpu.o matches
Binary file ./arch/asr/cr5/mpu/obj/arm/set_mmu.o matches
./arch/asr/cr5/mpu/set_mmu.h:9:extern uint32_t kern_image_size;
./arch/asr/cr5/mpu/mpu.c:102:extern uint32_t kern_image_size;
./arch/asr/cr5/mpu/mpu.c:112:   uint32_t addr = ADDR_ALIGN((kern_image_size+CR5_AREA_ST),0x100000) + CR5_MALLOC_CB_LEN;
./arch/asr/cr5/mpu/mpu.c:120:   /* Configure the NCNB buffer in the image area which is used for global variables */
./arch/asr/obj/arm/system_mrvl.d:13: /home/feature_phone/crane/driver/timer/timer_dec.h \
./arch/asr/obj/arm/system_mrvl.d:43: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./arch/asr/obj/arm/system_mrvl.o matches
./arch/asr/include/AXI.h:49:/*	FAB_TIMEOUT				0x0220	AXI Fabric Time-Out Register */
./arch/asr/include/AXI.h:51:#define	FAB_TIMEOUT_BIT_SAMPL_MSK		SHIFT0(0xffff)	/* Time-out Value */
./arch/asr/include/AXI.h:54:/*	FAB_TIMOUT_STATUS		0x0240	AXI Fabric Time-Out Status Register */
./arch/asr/include/USBSPH.h:432:#define	USB_OTGSC_1MSE			BIT_29	/* 1 millisecond timer Interrupt Enable */
./arch/asr/include/USBSPH.h:440:#define	USB_OTGSC_1MSS			BIT_21	/* 1 millisecond timer Interrupt Status */
./arch/asr/include/USBSPH.h:448:#define	USB_OTGSC_1MST			BIT_13	/* 1 millisecond timer toggle */
./arch/asr/include/SDH.h:30:    __IO uint16_t TIMEOUT_CTRL_SW_RESET          ; /* 0x002E Timeout Control/Software Reset Register */ 
./arch/asr/include/SDH.h:43:    __IO uint16_t MAX_CURRENT_1                  ; /* 0x0048 Maximum Current Register 1 */              
./arch/asr/include/SDH.h:44:    __IO uint16_t MAX_CURRENT_2                  ; /* 0x004A Maximum Current Register 2 */              
./arch/asr/include/SDH.h:45:    __IO uint16_t MAX_CURRENT_3                  ; /* 0x004C Maximum Current Register 3 */              
./arch/asr/include/SDH.h:46:    __IO uint16_t MAX_CURRENT_4                  ; /* 0x004E Maximum Current Register 4 */              
./arch/asr/include/SDH.h:309:/*	SD_TIMEOUT_CTRL_SW_RESET		0x002E	Timeout Control/Software Reset
./arch/asr/include/SDH.h:320:/* Timeout Value */
./arch/asr/include/SDH.h:347:/* Command Completion Signal Timeout Error */
./arch/asr/include/SDH.h:358:/* Current Limit Error */
./arch/asr/include/SDH.h:364:/* Data Timeout Error */
./arch/asr/include/SDH.h:372:/* Command Timeout Error */
./arch/asr/include/SDH.h:407:/* CPL Timeout Error Enable */
./arch/asr/include/SDH.h:419:/* Current Limit Error Enable */
./arch/asr/include/SDH.h:425:/* Data Timeout Error Enable */
./arch/asr/include/SDH.h:433:/* Command Timeout Error Enable */
./arch/asr/include/SDH.h:470:/* CPL Timeout Error Interrupt Enable */
./arch/asr/include/SDH.h:482:/* Current Limit Error Interrupt Enable */
./arch/asr/include/SDH.h:488:/* Data Timeout Error Interrupt Enable */
./arch/asr/include/SDH.h:496:/* Command Timeout Error Interrupt Enable */
./arch/asr/include/SDH.h:510:/* Auto CMD12 Timeout Error */
./arch/asr/include/SDH.h:531:#define	CAPABILITIES_1_TIMEOUT_UNIT			BIT_7			/* Timeout Unit */
./arch/asr/include/SDH.h:533:/* Timeout Frequency */
./arch/asr/include/SDH.h:561:/* Maximum Block Length */
./arch/asr/include/SDH.h:585:/*	MAX_CURRENT_1				0x0048	Maximum Current Register 1 */
./arch/asr/include/SDH.h:586:/* Maximum Current for 3.0V */
./arch/asr/include/SDH.h:589:/* Maximum Current for 3.3V */
./arch/asr/include/SDH.h:593:/*	MAX_CURRENT_2				0x004A	Maximum Current Register 2 */
./arch/asr/include/SDH.h:595:/* Maximum Current for 1.8V */
./arch/asr/include/SDH.h:599:/*	MAX_CURRENT_3				0x004C	Maximum Current Register 3 */
./arch/asr/include/SDH.h:602:/*	MAX_CURRENT_4				0x004E	Maximum Current Register 4 */
./arch/asr/include/SDH.h:618:/* Force Event for Auto Cmd12 Timeout Error */
./arch/asr/include/SDH.h:628:/* Force Event for CPL Timeout Error */
./arch/asr/include/SDH.h:639:/* Force Event for Current Limit Error */
./arch/asr/include/SDH.h:645:/* Force Event for Data Timeout Error */
./arch/asr/include/SDH.h:653:/* Force Event for Command Timeout Error */
./arch/asr/include/SDH.h:842:/* Command Completion Signal Timeout Value */
./arch/asr/include/CCIC.h:372:#define CCIC_CSI2_reset_isim_vreset           BIT_1
./arch/asr/include/MCU.h:652:#define	MC_CONTROL_2_BQ_STARV_TIME_MSK			SHIFT0(0xffff)	/* Initial value for BQ starvation timer */
./arch/asr/include/MCU.h:658:#define	MC_CONTROL_3_PHY_OUT_FF_BYPASS_MSK		SHIFT8(0xff)	/* PHY output interface timing control */
./arch/asr/include/MCU.h:660:#define	MC_CONTROL_3_PHY_IN_FF_BYPASS_MSK		SHIFT0(0xff)	/* PHY input interface timing control */
./arch/asr/include/MCU.h:753:/*	DDR_INIT_TIMING_CONTROL_0		0x0380	MCU DRAM Initialization Timing
./arch/asr/include/MCU.h:759:/*	DDR_INIT_TIMING_CONTROL_1		0x0384	MCU DRAM Initialization Timing
./arch/asr/include/MCU.h:767:/*	ZQC_TIMING_0					0x0388	MCU DRAM ZQC Timing Register 0 */
./arch/asr/include/MCU.h:768:#define	ZQC_TIMING_0_TZQCR_MSK			SHIFT16(0x7f)	/* ZQ calibration reset time */
./arch/asr/include/MCU.h:770:#define	ZQC_TIMING_0_TZQINIT_MSK		SHIFT0(0x7ff)	/* ZQ power-up  and reset calibration time */
./arch/asr/include/MCU.h:773:/*	ZQC_TIMING_1					0x038C	MCU DRAM ZQC Timing Register 1 */
./arch/asr/include/MCU.h:774:#define	ZQC_TIMING_1_TZQCS_MSK			SHIFT16(0xff)	/* ZQ Normal operation short calibration time */
./arch/asr/include/MCU.h:776:#define	ZQC_TIMING_1_TZQOPER_MSK		SHIFT0(0x3ff)	/* ZQ Normal operation full calibration time */
./arch/asr/include/MCU.h:779:/*	REFRESH_TIMING					0x0390	MCU DRAM Refresh Timing Register */
./arch/asr/include/MCU.h:780:#define	REFRESH_TIMING_TRFC_MSK			SHIFT16(0x7ff)	/* REFRESH-to-ACTIVE or REFRESH-to-REFRESH time */
./arch/asr/include/MCU.h:782:#define	REFRESH_TIMING_TREFI_MSK		SHIFT0(0x3fff)	/* AUTO-REFRESH interval time */
./arch/asr/include/MCU.h:785:/*	SELFREFRESH_TIMING				0x0394	MCU DRAM Self-refresh Timing
./arch/asr/include/MCU.h:797:/*	POWERDOWN_TIMING				0x0398	MCU DRAM Power-down Timing Register */
./arch/asr/include/MCU.h:807:/*	MRS_TIMING						0x039C	MCU DRAM MRS Timing Register */
./arch/asr/include/MCU.h:810:#define	MRS_TIMING_TMRD_MSK			SHIFT0(0xf)		/* Mode Register Set command cycle time */
./arch/asr/include/MCU.h:813:/*	ACT_TIMING						0x03A0	MCU DRAM Activate Timing Register */
./arch/asr/include/MCU.h:823:/*	PRECHARGE_TIMING				0x03A4	MCU DRAM Precharge Timing Register */
./arch/asr/include/MCU.h:833:/*	CAS_RAS_TIMING					0x03A8	MCU DRAM CAS/RAS Timing Register */
./arch/asr/include/MCU.h:841:/*	OFF_SPEC_TIMING					0x03AC	MCU DRAM Off-spec timing Register */
./arch/asr/include/MCU.h:853:/*	DRAM_READ_TIMING				0x03B0	MCU DRAM read timing control
./arch/asr/include/MCU.h:859:/*	DRAM_CA_TRAIN_TIMING			0x03B4	MCU DRAM CA Train timing Register */
./arch/asr/include/PMUA.h:802:/*  PMUA_PWR_STBL_TIMER         0x0084  Power Stable Timer Register */
./arch/asr/include/PMUA.h:807:/* Power up Stable Timer */
./arch/asr/include/PMUA.h:810:/* Power Down Stable Timer */
./arch/asr/include/APBCLK.h:147://0x0034 offset Clock/Reset Control Register for Timer 0 
./arch/asr/include/APBCLK.h:179://0x0044 offset Clock/Reset Control Register for Timer 1
./arch/asr/include/SDH_v3_1.h:29:    __IO uint16_t TIMEOUT_CTRL_SW_RESET          ; /* 0x002E Timeout Control/Software Reset Register */ 
./arch/asr/include/SDH_v3_1.h:42:    __IO uint16_t MAX_CURRENT_1                  ; /* 0x0048 Maximum Current Register 1 */              
./arch/asr/include/SDH_v3_1.h:43:    __IO uint16_t MAX_CURRENT_2                  ; /* 0x004A Maximum Current Register 2 */              
./arch/asr/include/SDH_v3_1.h:44:    __IO uint16_t MAX_CURRENT_3                  ; /* 0x004C Maximum Current Register 3 */              
./arch/asr/include/SDH_v3_1.h:45:    __IO uint16_t MAX_CURRENT_4                  ; /* 0x004E Maximum Current Register 4 */              
./arch/asr/include/SDH_v3_1.h:105:    __IO uint32_t EMMC_PHY_TIMING_ADJUST         ; /* 0x0160 eMMC PHY Timing Adjust */
./arch/asr/include/SDH_v3_1.h:110:    __IO uint32_t EMMC_LOGIC_TIMING_ADJUST       ; /* 0x0174 eMMC Logic Timing Adjust */
./arch/asr/include/SDH_v3_1.h:305:/*	SD_TIMEOUT_CTRL_SW_RESET		0x002E	Timeout Control/Software Reset
./arch/asr/include/SDH_v3_1.h:316:/* Timeout Value */
./arch/asr/include/SDH_v3_1.h:343:/* Command Completion Signal Timeout Error */
./arch/asr/include/SDH_v3_1.h:354:/* Current Limit Error */
./arch/asr/include/SDH_v3_1.h:360:/* Data Timeout Error */
./arch/asr/include/SDH_v3_1.h:368:/* Command Timeout Error */
./arch/asr/include/SDH_v3_1.h:403:/* CPL Timeout Error Enable */
./arch/asr/include/SDH_v3_1.h:415:/* Current Limit Error Enable */
./arch/asr/include/SDH_v3_1.h:421:/* Data Timeout Error Enable */
./arch/asr/include/SDH_v3_1.h:429:/* Command Timeout Error Enable */
./arch/asr/include/SDH_v3_1.h:466:/* CPL Timeout Error Interrupt Enable */
./arch/asr/include/SDH_v3_1.h:478:/* Current Limit Error Interrupt Enable */
./arch/asr/include/SDH_v3_1.h:484:/* Data Timeout Error Interrupt Enable */
./arch/asr/include/SDH_v3_1.h:492:/* Command Timeout Error Interrupt Enable */
./arch/asr/include/SDH_v3_1.h:506:/* Auto CMD12 Timeout Error */
./arch/asr/include/SDH_v3_1.h:527:#define	CAPABILITIES_1_TIMEOUT_UNIT			BIT_7			/* Timeout Unit */
./arch/asr/include/SDH_v3_1.h:529:/* Timeout Frequency */
./arch/asr/include/SDH_v3_1.h:557:/* Maximum Block Length */
./arch/asr/include/SDH_v3_1.h:581:/*	MAX_CURRENT_1				0x0048	Maximum Current Register 1 */
./arch/asr/include/SDH_v3_1.h:582:/* Maximum Current for 3.0V */
./arch/asr/include/SDH_v3_1.h:585:/* Maximum Current for 3.3V */
./arch/asr/include/SDH_v3_1.h:589:/*	MAX_CURRENT_2				0x004A	Maximum Current Register 2 */
./arch/asr/include/SDH_v3_1.h:591:/* Maximum Current for 1.8V */
./arch/asr/include/SDH_v3_1.h:595:/*	MAX_CURRENT_3				0x004C	Maximum Current Register 3 */
./arch/asr/include/SDH_v3_1.h:598:/*	MAX_CURRENT_4				0x004E	Maximum Current Register 4 */
./arch/asr/include/SDH_v3_1.h:614:/* Force Event for Auto Cmd12 Timeout Error */
./arch/asr/include/SDH_v3_1.h:624:/* Force Event for CPL Timeout Error */
./arch/asr/include/SDH_v3_1.h:635:/* Force Event for Current Limit Error */
./arch/asr/include/SDH_v3_1.h:641:/* Force Event for Data Timeout Error */
./arch/asr/include/SDH_v3_1.h:649:/* Force Event for Command Timeout Error */
./arch/asr/include/SDH_v3_1.h:954:/* Consecutive Tuning Success Times */
./arch/asr/include/SDH_v3_1.h:997: *                                              PHY Timing Adjust
./arch/asr/include/SDH_v3_1.h:1111: *                                              Logic Timing Adjust
./arch/asr/include/PCIE_PHY.h:42:    __IO uint32_t   INTERFACE_REG1;         //0x94, Sync Mask and Maximal Generation Setting
./arch/asr/include/PCIE_PHY.h:65:    __IO uint32_t   DFE_REG10;              //0x1AC, DFE Timer
./arch/asr/include/PCIE_PHY.h:90:    __IO uint32_t   TX_REG7;                //0x29C, tx amplitude index limit
./arch/asr/include/PCIE_PHY.h:144:    __IO uint32_t   GLOB_CLKREQ_CTRL;       //0x71C, CLKREQ# Timing Control
./arch/asr/include/PCIE_PHY.h:147:    __IO uint32_t   GLOB_PM_CFG0;           //0x740, Power Management Timing Parameter 1
./arch/asr/include/SSP.h:13:    __IO uint32_t SSTO;     /* 0x0028 SSP Time Out Register */                    
./arch/asr/include/SSP.h:15:    __IO uint32_t SSTSA;    /* 0x0030 SSP TX Time Slot Active Register */         
./arch/asr/include/SSP.h:16:    __IO uint32_t SSRSA;    /* 0x0034 SSP RX Time Slot Active Register */         
./arch/asr/include/SSP.h:17:    __I  uint32_t SSTSS;    /* 0x0038 SSP Time Slot Status Register */    
./arch/asr/include/SSP.h:89:/* Receiver Time-out Interrupt Enable */
./arch/asr/include/SSP.h:119:/* Receiver Time-out Interrupt */
./arch/asr/include/SSP.h:155:/* Frame Sync Relative Timing Bit */
./arch/asr/include/SSP.h:173:/* SSP Time Out Registers (SSTO_X) */
./arch/asr/include/SSP.h:177:/*	SSP_SSTSA			0x0030	SSP TX Time Slot Active Register */
./arch/asr/include/SSP.h:179:#define	SSP_SSTSA_TTSA_MSK				SHIFT0(0xff)		/* TX Time Slot Active */
./arch/asr/include/SSP.h:182:/*	SSP_SSRSA			0x0034	SSP RX Time Slot Active Register */
./arch/asr/include/SSP.h:184:#define	SSP_SSRSA_RTSA_MSK				SHIFT0(0xff)		/* RX Time Slot Active */
./arch/asr/include/SSP.h:187:/*	SSP_SSTSS			0x0038	SSP Time Slot Status Register */
./arch/asr/include/SSP.h:190:#define	SSP_SSTSS_TSS_MSK				SHIFT0(0x7)			/* Time Slot Status */
./arch/asr/include/CIU.h:180:												 *			Timing
./arch/asr/include/CIU.h:215:												 *			Timing
./arch/asr/include/CIU.h:649:/* page arbitration timeout enable */
./arch/asr/include/CIU.h:653:/* read channel page timeout value */
./arch/asr/include/CIU.h:656:/* write channel page timeout value */
./arch/asr/include/CIU.h:680:/* RAM Read Timing Control */
./arch/asr/include/CIU.h:683:/* RAM Write Timing Control */
./arch/asr/include/CIU.h:689:/* page arbitration timeout enable */
./arch/asr/include/CIU.h:693:/* read channel page timeout value */
./arch/asr/include/CIU.h:696:/* write channel page timeout value */
./arch/asr/include/CIU.h:720:/* RAM Read Timing Control */
./arch/asr/include/CIU.h:723:/* RAM Write Timing Control */
./arch/asr/include/CIU.h:910: *											Timing Configuration Register
./arch/asr/include/CIU.h:912:/* L1 icache TAG sram read timing */
./arch/asr/include/CIU.h:915:/* L1 icache TAG sram write timing */
./arch/asr/include/CIU.h:918:/* L1 icache DATA read timing */
./arch/asr/include/CIU.h:921:/* L1 icache DATA write timing */
./arch/asr/include/CIU.h:924:/* L1 dcache dirty read timing */
./arch/asr/include/CIU.h:927:/* L1 dcache dirty write timing */
./arch/asr/include/CIU.h:930:/* L1 dcache tag sram read timing */
./arch/asr/include/CIU.h:933:/* L1 dcache tag sram write timing */
./arch/asr/include/CIU.h:936:/* L1 dcache data sram read timing */
./arch/asr/include/CIU.h:939:/* L1 dcache data sram write timing */
./arch/asr/include/CIU.h:942:/* BTCM sram read timing */
./arch/asr/include/CIU.h:998: *											Timing Configuration Register
./arch/asr/include/CIU.h:1001:/* L2 tag sram read timing */
./arch/asr/include/CIU.h:1004:/* L2 tag sram write timing */
./arch/asr/include/CIU.h:1007:/* L2 data sram read timing */
./arch/asr/include/CIU.h:1010:/* L2 data sram write timing */
./arch/asr/include/CIU.h:1042:/* TLB sram read timing */
./arch/asr/include/CIU.h:1045:/* TLB sram write timing */
./arch/asr/include/CIU.h:1048:/* L1 Dcache dirty sram read timing */
./arch/asr/include/CIU.h:1051:/* L1 Dcache dirty sram write timing */
./arch/asr/include/CIU.h:1054:/* L1 Dcache tag sram read timing */
./arch/asr/include/CIU.h:1057:/* L1 Dcache tag sram write timing */
./arch/asr/include/CIU.h:1060:/* L1 Dcache data sram read timing */
./arch/asr/include/CIU.h:1063:/* L1 Dcache data sram write timing */
./arch/asr/include/CIU.h:1066:/* L1 Icache tag sram read timing */
./arch/asr/include/CIU.h:1069:/* L1 Icache tag sram write timing */
./arch/asr/include/CIU.h:1072:/* L1 Icache data sram read timing */
./arch/asr/include/CIU.h:1075:/* L1 Icache data sram write timing */
./arch/asr/include/CIU.h:1083:/* scu sram read timing */
./arch/asr/include/CIU.h:1086:/* scu sram write timing */
./arch/asr/include/CIU.h:1090:/* L2 Tag sram read timing */
./arch/asr/include/CIU.h:1093:/* L2 Tag sram write timing */
./arch/asr/include/CIU.h:1096:/* L2 Data sram read timing */
./arch/asr/include/CIU.h:1099:/* L2 Data sram write timing */
./arch/asr/include/predefines.h:168:#define MV_TIMEOUT          (0x0E)  /* Time Out                              */
./arch/asr/include/predefines.h:171:#define MV_NOT_IMPLEMENTED  (0x11)  /* Request supported but not implemented */
./arch/asr/include/USB.h:18:    __IO uint32_t U2XGPTIMER0LD         ; /* 0x080 General Purpose Timer #0 Load Register */        
./arch/asr/include/USB.h:19:    __IO uint32_t U2XGPTIMER0CTRL       ; /* 0x084 General Purpose Timer #0 Control Register */     
./arch/asr/include/USB.h:20:    __IO uint32_t U2XGPTIMER1LD         ; /* 0x088 General Purpose Timer #1 Load Register */        
./arch/asr/include/USB.h:21:    __IO uint32_t U2XGPTIMER1CTRL       ; /* 0x08C General Purpose Timer #1 Control Register */     
./arch/asr/include/USB.h:176://General Purpose Timer #0 /#1 Load Register (U2XGPTIMERYLD) EMEI C0
./arch/asr/include/USB.h:181://General Purpose Timer #0 / #1 Control Register (U2XGPTIMERYCTRL)  EMEI C0
./arch/asr/include/USB.h:508:#define	USB_OTGSC_1MSE			BIT_29	/* 1 millisecond timer Interrupt Enable */
./arch/asr/include/USB.h:516:#define	USB_OTGSC_1MSS			BIT_21	/* 1 millisecond timer Interrupt Status */
./arch/asr/include/USB.h:524:#define	USB_OTGSC_1MST			BIT_13	/* 1 millisecond timer toggle */
./arch/asr/include/USB.h:558:/* Prime Endpoint Transmit Buffer */
./arch/asr/include/USB.h:562:/* Prime Endpoint Receive Buffer */
./arch/asr/include/SQU.h:440:/* Burst Limit in each DMA Access */
./arch/asr/include/SQU.h:465:/* Burst Limit in each DMA Access */
./arch/asr/include/DSI.h:463://DPHY Timing Control Register 0
./arch/asr/include/DSI.h:473://DPHY Timing Control Register 1
./arch/asr/include/DSI.h:481://DPHY Timing Control Register 2
./arch/asr/include/DSI.h:492://DPHY Timing Control Register 3
./arch/asr/include/DSI.h:510://DSI Memory Timing Control Register
./arch/asr/include/USIM.h:16:    __IO uint32_t EGTR   ; /* 0x0028 USIM Extra Guard Time Register */  
./arch/asr/include/USIM.h:17:    __IO uint32_t BGTR   ; /* 0x002C USIM Block Guard Time Register */  
./arch/asr/include/USIM.h:18:    __IO uint32_t TOR    ; /* 0x0030 USIM Time-Out Register */   
./arch/asr/include/USIM.h:22:    __IO uint32_t CWTR   ; /* 0x0040 USIM Character Waiting Time Register */  
./arch/asr/include/USIM.h:23:    __IO uint32_t BWTR   ; /* 0x0044 USIM Block Waiting Time Register */             
./arch/asr/include/USIM.h:55:/* Enable Dma Receiver Requests In Event Of Time-out Situation */
./arch/asr/include/USIM.h:64:/* Block Waiting Time Interrupt */
./arch/asr/include/USIM.h:66:/* Character Waiting Time Interrupt */
./arch/asr/include/USIM.h:68:/* Receiver Time-Out Interrupt */
./arch/asr/include/USIM.h:86:/* Block Waiting Time Interrupt */
./arch/asr/include/USIM.h:88:/* Character Waiting Time Interrupt */
./arch/asr/include/USIM.h:90:/* Receiver Time Out Interrupt */
./arch/asr/include/USIM.h:162:#define	LSR_BWT					BIT_6			/* Block Waiting Time */
./arch/asr/include/USIM.h:163:#define	LSR_CWT					BIT_5			/* Character Waiting Time */
./arch/asr/include/USIM.h:164:#define	LSR_TIMEO					BIT_4			/* Receiver Time Out */
./arch/asr/include/USIM.h:171:/*	USIM_EGTR	0x0028	USIM Extra Guard Time Register */
./arch/asr/include/USIM.h:173:/* Extra Guard Time Moments */
./arch/asr/include/USIM.h:177:/*	USIM_BGTR	0x002C	USIM Block Guard Time Register */
./arch/asr/include/USIM.h:179:#define	BGTR_BGT_MSK				SHIFT0(0xff)		/* Block Guard Time */
./arch/asr/include/USIM.h:182:/*	USIM_TOR	0x0030	USIM Time-Out Register */
./arch/asr/include/USIM.h:184:#define	TOR_TO_MSK				SHIFT0(0xff)		/* Time Out */
./arch/asr/include/USIM.h:208:/*	USIM_CWTR	0x0040	USIM Character Waiting Time Register */
./arch/asr/include/USIM.h:210:#define	CWTR_CWT_MSK				SHIFT0(0xffff)	/* Character Waiting Time */
./arch/asr/include/USIM.h:213:/*	USIM_BWTR	0x0044	USIM Block Waiting Time Register */
./arch/asr/include/USIM.h:215:#define	BWTR_BWT_MSK				SHIFT0(0xffff)	/* Block Waiting Time */
./arch/asr/include/PMR.h:35:interrupt interfaces, the Timers and Watchdog, and the MP Control Registers.  
./arch/asr/include/UART.h:85:/* Receiver Time-out Interrupt Enable */
./arch/asr/include/UART.h:102:#define	IIR_TOD				BIT_3				/* Time Out Detected */
./arch/asr/include/SDH_v3_2.h:29:    __IO uint16_t TIMEOUT_CTRL_SW_RESET          ; /* 0x002E Timeout Control/Software Reset Register */ 
./arch/asr/include/SDH_v3_2.h:42:    __IO uint16_t MAX_CURRENT_1                  ; /* 0x0048 Maximum Current Register 1 */              
./arch/asr/include/SDH_v3_2.h:43:    __IO uint16_t MAX_CURRENT_2                  ; /* 0x004A Maximum Current Register 2 */              
./arch/asr/include/SDH_v3_2.h:44:    __IO uint16_t MAX_CURRENT_3                  ; /* 0x004C Maximum Current Register 3 */              
./arch/asr/include/SDH_v3_2.h:45:    __IO uint16_t MAX_CURRENT_4                  ; /* 0x004E Maximum Current Register 4 */              
./arch/asr/include/SDH_v3_2.h:108:    __IO uint32_t EMMC_PHY_TIMING_ADJUST         ; /* 0x0170 eMMC PHY Timing Adjust */
./arch/asr/include/SDH_v3_2.h:114:    __IO uint32_t EMMC_LOGIC_TIMING_ADJUST       ; /* 0x0188 eMMC Logic Timing Adjust */
./arch/asr/include/SDH_v3_2.h:115:    __IO uint32_t EMMC_LOGIC_TIMING_ADJUST_LOW   ; /* 0x018C eMMC Logic Timing Adjust For Low Speed */
./arch/asr/include/SDH_v3_2.h:124:    __IO uint32_t TP_CONTROL                     ; /* SDHC Timing Parameter Controlling */
./arch/asr/include/SDH_v3_2.h:125:    __IO uint32_t TP_MONITOR                     ; /* SDHC Timing Parameter Monitoring */
./arch/asr/include/SDH_v3_2.h:349:/*	SD_TIMEOUT_CTRL_SW_RESET		0x002E	Timeout Control/Software Reset
./arch/asr/include/SDH_v3_2.h:360:/* Timeout Value */
./arch/asr/include/SDH_v3_2.h:387:/* Command Completion Signal Timeout Error */
./arch/asr/include/SDH_v3_2.h:398:/* Current Limit Error */
./arch/asr/include/SDH_v3_2.h:404:/* Data Timeout Error */
./arch/asr/include/SDH_v3_2.h:412:/* Command Timeout Error */
./arch/asr/include/SDH_v3_2.h:447:/* CPL Timeout Error Enable */
./arch/asr/include/SDH_v3_2.h:459:/* Current Limit Error Enable */
./arch/asr/include/SDH_v3_2.h:465:/* Data Timeout Error Enable */
./arch/asr/include/SDH_v3_2.h:473:/* Command Timeout Error Enable */
./arch/asr/include/SDH_v3_2.h:510:/* CPL Timeout Error Interrupt Enable */
./arch/asr/include/SDH_v3_2.h:522:/* Current Limit Error Interrupt Enable */
./arch/asr/include/SDH_v3_2.h:528:/* Data Timeout Error Interrupt Enable */
./arch/asr/include/SDH_v3_2.h:536:/* Command Timeout Error Interrupt Enable */
./arch/asr/include/SDH_v3_2.h:550:/* Auto CMD12 Timeout Error */
./arch/asr/include/SDH_v3_2.h:571:#define	CAPABILITIES_1_TIMEOUT_UNIT			BIT_7			/* Timeout Unit */
./arch/asr/include/SDH_v3_2.h:573:/* Timeout Frequency */
./arch/asr/include/SDH_v3_2.h:601:/* Maximum Block Length */
./arch/asr/include/SDH_v3_2.h:625:/*	MAX_CURRENT_1				0x0048	Maximum Current Register 1 */
./arch/asr/include/SDH_v3_2.h:626:/* Maximum Current for 3.0V */
./arch/asr/include/SDH_v3_2.h:629:/* Maximum Current for 3.3V */
./arch/asr/include/SDH_v3_2.h:633:/*	MAX_CURRENT_2				0x004A	Maximum Current Register 2 */
./arch/asr/include/SDH_v3_2.h:635:/* Maximum Current for 1.8V */
./arch/asr/include/SDH_v3_2.h:639:/*	MAX_CURRENT_3				0x004C	Maximum Current Register 3 */
./arch/asr/include/SDH_v3_2.h:642:/*	MAX_CURRENT_4				0x004E	Maximum Current Register 4 */
./arch/asr/include/SDH_v3_2.h:658:/* Force Event for Auto Cmd12 Timeout Error */
./arch/asr/include/SDH_v3_2.h:668:/* Force Event for CPL Timeout Error */
./arch/asr/include/SDH_v3_2.h:679:/* Force Event for Current Limit Error */
./arch/asr/include/SDH_v3_2.h:685:/* Force Event for Data Timeout Error */
./arch/asr/include/SDH_v3_2.h:693:/* Force Event for Command Timeout Error */
./arch/asr/include/SDH_v3_2.h:1031:/* Consecutive Tuning Success Times */
./arch/asr/include/SDH_v3_2.h:1074: *                                              PHY Timing Adjust
./arch/asr/include/SDH_v3_2.h:1195: *                                              Logic Timing Adjust
./arch/asr/include/DMA.h:127:#define	CMD_SIZE_MSK				    SHIFT16(0x7)	    /* Maximum burst size */
./arch/asr/include/PCIE_APP.h:19:    __IO uint32_t INBOUND_CPL_TIMEOUT_HDR;  //0x080, Application Inbound Completion Timeout Header
./arch/asr/include/PCIE_APP.h:20:    __IO uint32_t OUTBOUND_CPL_TIMEOUT_HDR; //0x084, Application Outbound Completion Timeout Header
./arch/asr/include/PCIE_APP.h:28:    __IO uint32_t SRAM_TIMING_CTRL[2];      //0x0F0~0x0F4, Application SRAM Timing Control 0~1
./arch/asr/system_mrvl.c:17:#include "timer_dec.h"
./arch/asr/system_mrvl.c:31:extern void sys_timer_init(void);
./arch/asr/system_mrvl.c:142:    sys_timer_init(); //Initialize Seagull timers
Binary file ./app/dma/obj/arm/dma_ao.o matches
./app/dma/obj/arm/dma_ao.d:27: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/dma/obj/arm/dma_ao.d:37: /home/feature_phone/crane/driver/timer/clock.h \
./app/memory/vm_manager.c:7:#include "timer_dec.h"
./app/memory/vm_manager.c:193:	if(mm->size_minimum_free_vma >=len)
./app/memory/vm_manager.c:194:		return mm->minimum_free_vma;
./app/memory/vm_manager.c:213:	 * simple, it hopefully works in most obvious cases.. Easy to
./app/memory/vm_manager.c:873:void vm_minimum_free_area_init(struct mm_struct *mm)
./app/memory/vm_manager.c:896:	bbu_mem_ranges[MEM_RANGE_CODE_AREA].addr_len   	= (((kern_image_size >>20)+1)<<20);	
./app/memory/vm_manager.c:950:	mm->minimum_free_vma = NULL;
./app/memory/vm_manager.c:965:	vm_minimum_free_area_init(mm);
./app/memory/vm_manager.c:971:	mm->minimum_free_vma = NULL;
./app/memory/vm_manager.c:986:	vm_minimum_free_area_init(mm);
./app/memory/vm_manager.h:73:	struct vm_area_struct *minimum_free_vma;	/* last find_vma result */
./app/memory/vm_manager.h:74:	unsigned long size_minimum_free_vma;
./app/memory/core_tests.c:222:   //Simulate error
./app/memory/core_tests.c:1833:      bbu_printf("  Elapsed time: %d msec\n\r", tmsec);
./app/memory/core_tests.c:1951:   uint32_t  startAddr, test_times;
./app/memory/core_tests.c:1953:   test_times = 1;
./app/memory/core_tests.c:1968:         test_times = conv_dec((char *)argv[4]);
./app/memory/core_tests.c:2004:         for(uint32_t i = 0; i < test_times; i++){
./app/memory/cacheI.c:162:         so seccond round is 4 times better*/
./app/memory/mem_tests.c:6:#include "timer_dec.h"
./app/memory/mem_tests.c:273:   uint32_t timer_count = 0;
./app/memory/mem_tests.c:281:   /* It's better to use Timer 2(1.0KHZ) */
./app/memory/mem_tests.c:282:   timer_count = timer_get_count(0);
./app/memory/mem_tests.c:375:   timer_count = timer_get_count(0) - timer_count;
./app/memory/mem_tests.c:376:   msec = count_2_msec(timer_count);
./app/memory/mem_tests.c:379:   bbu_printf("\n\rmemt--> Elapsed test time = %d.%d seconds \n\r", sec, msec);
./app/memory/mem_tests.c:701:   begin = timer_get_count(0);
./app/memory/mem_tests.c:703:   end = timer_get_count(0);
./app/memory/mem_tests.c:706:   bbu_printf("Costed timer count: %d\n\r", end);
./app/memory/mem_tests.c:716:   begin = timer_get_count(0);
./app/memory/mem_tests.c:718:   end = timer_get_count(0);
./app/memory/mem_tests.c:721:   bbu_printf("Costed timer count: %d\n\r", end);
./app/memory/mem_hotplug.c:10:#include "timer_dec.h"
./app/memory/mem_hotplug.c:63:	//bbu_printf("kernel image size is %x %dM",kern_image_size,(kern_image_size >> 20));	
./app/memory/mem_hotplug.c:134:	bbu_mem_ranges[1].addr_len = (((kern_image_size >>20)+1)<<20);	
Binary file ./app/memory/obj/arm/core_tests.o matches
Binary file ./app/memory/obj/arm/mem_tests.o matches
./app/memory/obj/arm/cache-test.d:36: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/memory/obj/arm/cache-test.d:39: /home/feature_phone/crane/driver/timer/clock.h \
./app/memory/obj/arm/vm_manager.d:9: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/memory/obj/arm/vm_manager.d:38: /home/feature_phone/crane/driver/timer/clock.h \
./app/memory/obj/arm/core_tests.d:8: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/memory/obj/arm/vm_manager.o matches
./app/memory/obj/arm/mem_hotplug.d:35: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/memory/obj/arm/mem_hotplug.d:38: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/memory/obj/arm/dcache_test.o matches
Binary file ./app/memory/obj/arm/cache-test.o matches
Binary file ./app/memory/obj/arm/mem_hotplug.o matches
./app/memory/obj/arm/mem_tests.d:9: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/memory/obj/arm/mem_tests.d:39: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/memory/obj/arm/cacheI.o matches
./app/memory/cache-test.c:7:#include "timer_dec.h"
./app/memory/cache-test.c:41:   int timeout = 0x40000;
./app/memory/cache-test.c:48:      while(timeout--);
./app/memory/cache-test.c:77:   int timeout = 0x40000;
./app/memory/cache-test.c:82:      while(timeout--);
./app/memory/cache-test.c:474:      bbu_printf("Average D read  time from L1   = %.8f\n\r",
./app/memory/cache-test.c:499:      bbu_printf("Average D read  time from L2   = %.8f\n\r",
./app/memory/cache-test.c:519:      bbu_printf("Average D read  time from DDR  = %.8f\n\r",
./app/memory/cache-test.c:543:      bbu_printf("Average I fetch time from L1   = %.8f\n\r",
./app/memory/cache-test.c:564:      bbu_printf("Average I fetch time from L2   = %.8f\n\r",
./app/memory/cache-test.c:583:      bbu_printf("Average I fetch time from DDR  = %.8f\n\r",
./app/memory/cache-test.c:624:   bbu_printf("Average D write time to L1   = %.8f\n\r",(float)sum/(float)i);
./app/memory/cache-test.c:644:   bbu_printf("Average D write time to L2   = %.8f\n\r",(float)sum / (float)i);
./app/memory/cache-test.c:661:   bbu_printf("Average D write time to DDR  = %.8f\n\r",(float)sum/(float)i);
./app/benchmark/whetstone/obj/arm/whetstone.d:3: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/benchmark/whetstone/obj/arm/whetstone.d:35: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./app/benchmark/whetstone/obj/arm/whetstone.o matches
./app/benchmark/whetstone/whetstone.c:10: *		includes this entire comment block and limited
./app/benchmark/whetstone/whetstone.c:22: * variable indices changes.  The array element E1[0] is simply never
./app/benchmark/whetstone/whetstone.c:25: * The major FORTRAN comment blocks were retained to minimize
./app/benchmark/whetstone/whetstone.c:27: * FORTRAN version, have been eliminated here.
./app/benchmark/whetstone/whetstone.c:33: * outputs at various stages.  Final timing measurements should be
./app/benchmark/whetstone/whetstone.c:60:#include "timer_dec.h"
./app/benchmark/whetstone/whetstone.c:119:C	Start benchmark timing at this point.
./app/benchmark/whetstone/whetstone.c:122:	startsec = timer_get_count(0);
./app/benchmark/whetstone/whetstone.c:158:C	Module 1: Simple identifiers
./app/benchmark/whetstone/whetstone.c:354:C      Stop benchmark timing at this point.
./app/benchmark/whetstone/whetstone.c:357:	finisec = timer_get_count(0);
./app/benchmark/ffts/neon_static_f.S:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/neon_static_f.S:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts.h:70:__INLINE float W_im(float N, float k) { return sin(-2.0f * PI * k / N); }
./app/benchmark/ffts/ffts.h:129:	 * Used in multidimensional Code ??
./app/benchmark/ffts/ffts.h:158:	// multi-dimensional stuff:
./app/benchmark/ffts/ffts.h:169:	 * (differs for real and multi dimension transforms
./app/benchmark/ffts/ffts.h:186:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_static.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_static.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_static.c:102:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts.c:48:  #include <limits.h>	   /* for PAGESIZE */
./app/benchmark/ffts/ffts.c:240:					w0[j][1]	= W_im(n,j);
./app/benchmark/ffts/ffts.c:253:							V re, im;
./app/benchmark/ffts/ffts.c:255:							im = VDUPIM(temp0);
./app/benchmark/ffts/ffts.c:257:								im = VXOR(im, MULI_SIGN);
./app/benchmark/ffts/ffts.c:258:								//im = IMULI(sign>0, im);
./app/benchmark/ffts/ffts.c:260:								im = MULI(sign>0, im);
./app/benchmark/ffts/ffts.c:263:							VST(fw + j*4+4, im);
./app/benchmark/ffts/ffts.c:291:						V re, im;
./app/benchmark/ffts/ffts.c:293:						im = VDUPIM(temp0);
./app/benchmark/ffts/ffts.c:294:						im = VXOR(im, MULI_SIGN);
./app/benchmark/ffts/ffts.c:296:						VST(fw + j*4+4, im);
./app/benchmark/ffts/ffts.c:311:					w0[j][1]	= W_im(n,j*2);
./app/benchmark/ffts/ffts.c:313:					w1[j][1]	= W_im(n,j);
./app/benchmark/ffts/ffts.c:315:					w2[j][1]	= W_im(n,j + (n/8));
./app/benchmark/ffts/ffts.c:352:					V temp0, temp1, temp2, re, im;
./app/benchmark/ffts/ffts.c:356:						im = VDUPIM(temp0);
./app/benchmark/ffts/ffts.c:357:						im = VXOR(im, MULI_SIGN);
./app/benchmark/ffts/ffts.c:359:						VST(fw + j*2*6+4, im);
./app/benchmark/ffts/ffts.c:363:						im = VDUPIM(temp1);
./app/benchmark/ffts/ffts.c:364:						im = VXOR(im, MULI_SIGN);
./app/benchmark/ffts/ffts.c:366:						VST(fw + j*2*6+12, im);
./app/benchmark/ffts/ffts.c:370:						im = VDUPIM(temp2);
./app/benchmark/ffts/ffts.c:371:						im = VXOR(im, MULI_SIGN);
./app/benchmark/ffts/ffts.c:373:						VST(fw + j*2*6+20, im);
./app/benchmark/ffts/ffts.c:416:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/patterns.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/patterns.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/patterns.c:209:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/neon.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/neon.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/neon.h:66:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_real_nd.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_real_nd.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_real_nd.h:54:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/macros-alpha.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/macros-alpha.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/macros-alpha.h:153:static inline V IMUL(V d, V re, V im)
./app/benchmark/ffts/macros-alpha.h:156:    im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-alpha.h:157:    return VSUB(re, im);  
./app/benchmark/ffts/macros-alpha.h:161:static inline V IMULJ(V d, V re, V im)
./app/benchmark/ffts/macros-alpha.h:164:    im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-alpha.h:165:    return VADD(re, im);
./app/benchmark/ffts/macros-alpha.h:207:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/macros-neon.h:12: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/macros-neon.h:14: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/macros-neon.h:84:__INLINE V IMUL(V d, V re, V im) {
./app/benchmark/ffts/macros-neon.h:86:  im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-neon.h:87:  return VSUB(re, im);  
./app/benchmark/ffts/macros-neon.h:90:__INLINE V IMULJ(V d, V re, V im) {
./app/benchmark/ffts/macros-neon.h:92:  im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-neon.h:93:  return VADD(re, im);  
./app/benchmark/ffts/macros-neon.h:97:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_nd.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_nd.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_nd.c:283:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_static.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_static.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_static.h:47:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_small.h:14:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/test.c:11: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/test.c:13: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/test.c:59:float impulse_error(int N, int sign, float *data) {
./app/benchmark/ffts/test.c:71:		double re, im;
./app/benchmark/ffts/test.c:74:			im = -sin(2 * PI * (double)i / (double)N); 
./app/benchmark/ffts/test.c:77:			im = sin(2 * PI * (double)i / (double)N); 
./app/benchmark/ffts/test.c:80:		long double re, im;
./app/benchmark/ffts/test.c:83:			im = -sinl(2 * PI * (long double)i / (long double)N); 
./app/benchmark/ffts/test.c:86:			im = sinl(2 * PI * (long double)i / (long double)N); 
./app/benchmark/ffts/test.c:89:		sum += re * re + im * im;
./app/benchmark/ffts/test.c:92:		im = im - data[2*i+1];
./app/benchmark/ffts/test.c:94:		delta_sum += re * re + im * im;
./app/benchmark/ffts/test.c:125:		bbu_printf(" %3d  | %9d | %10e\n\r", sign, n, impulse_error(n, sign, output));
./app/benchmark/ffts/test.c:210:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_real.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_real.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_real.c:227:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/macros-sse.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/macros-sse.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/macros-sse.h:72:__INLINE V IMUL(V d, V re, V im) {
./app/benchmark/ffts/macros-sse.h:74:  im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-sse.h:75:  return VSUB(re, im);  
./app/benchmark/ffts/macros-sse.h:78:__INLINE V IMULJ(V d, V re, V im) {
./app/benchmark/ffts/macros-sse.h:80:  im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-sse.h:81:  return VADD(re, im);  
./app/benchmark/ffts/macros-sse.h:85:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/codegen_arm.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/codegen_arm.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/codegen_arm.h:51:void ADDI(uint32_t **p, uint8_t dst, uint8_t src, int32_t imm) {
./app/benchmark/ffts/codegen_arm.h:52:	int32_t oimm = imm;
./app/benchmark/ffts/codegen_arm.h:53:	if(imm < 0) {
./app/benchmark/ffts/codegen_arm.h:54:		imm = -imm;
./app/benchmark/ffts/codegen_arm.h:55:		uint32_t shamt = (__builtin_ctzl(imm)>23)?23:__builtin_ctzl(imm);
./app/benchmark/ffts/codegen_arm.h:57:		imm >>= shamt;
./app/benchmark/ffts/codegen_arm.h:60:	//	if(imm > 255) fprintf(stderr, "imm>255: %d\n", oimm);
./app/benchmark/ffts/codegen_arm.h:61:		*(*p)++ = 0xe2400000 | ((src & 0xf) << 16) | ((dst & 0xf) << 12) | ((shamt & 0xf) << 8) | (imm & 0xff);
./app/benchmark/ffts/codegen_arm.h:63:		if(imm > 255) ADDI(p, dst, src, (oimm + ((imm & 0xff) << (32-shamt*2))));
./app/benchmark/ffts/codegen_arm.h:66:		uint32_t shamt = (__builtin_ctzl(imm)>23)?23:__builtin_ctzl(imm);
./app/benchmark/ffts/codegen_arm.h:68:		imm >>= shamt;
./app/benchmark/ffts/codegen_arm.h:71://		if(imm > 255) fprintf(stderr, "imm>255: %d\n", oimm);
./app/benchmark/ffts/codegen_arm.h:73:		*(*p)++ = 0xe2800000 | ((src & 0xf) << 16) | ((dst & 0xf) << 12) | ((shamt & 0xf) << 8) | (imm & 0xff);
./app/benchmark/ffts/codegen_arm.h:75:		if(imm > 255) ADDI(p, dst, src, (oimm - ((imm & 0xff) << (32-shamt*2))));
./app/benchmark/ffts/codegen_arm.h:84:void MOVI(uint32_t **p, uint8_t dst, uint32_t imm) {
./app/benchmark/ffts/codegen_arm.h:85:	uint32_t oimm = imm;
./app/benchmark/ffts/codegen_arm.h:87:		uint32_t shamt = (__builtin_ctzl(imm)>23)?23:__builtin_ctzl(imm);
./app/benchmark/ffts/codegen_arm.h:89:		imm >>= shamt;
./app/benchmark/ffts/codegen_arm.h:91:	*(*p)++ = 0xe3a00000 | ((dst & 0xf) << 12) | ((shamt & 0xf) << 8) | (imm & 0xff) ;
./app/benchmark/ffts/codegen_arm.h:92:		if(imm > 255) ADDI(p, dst, dst, (oimm - ((imm & 0xff) << (32-shamt*2))));
./app/benchmark/ffts/codegen_arm.h:102:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_small.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_small.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_small.c:157:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/neon_float.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/neon_float.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/neon_float.h:1128:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/macros.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/macros.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/macros.h:65:static inline void K_N(int inv, V re, V im, V *r0, V *r1, V *r2, V *r3)
./app/benchmark/ffts/macros.h:69:    zk_p = IMUL(*r2, re, im);
./app/benchmark/ffts/macros.h:70:    zk_n = IMULJ(*r3, re, im);
./app/benchmark/ffts/macros.h:162:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/codegen_sse.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/codegen_sse.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/codegen_sse.h:86:void IMM8(uint8_t **p, int32_t imm) {
./app/benchmark/ffts/codegen_sse.h:87:		*(*p)++ = (imm & 0xff);
./app/benchmark/ffts/codegen_sse.h:90:void IMM16(uint8_t **p, int32_t imm) {
./app/benchmark/ffts/codegen_sse.h:93:		*(*p)++ = (imm & (0xff << (i*8))) >> (i*8);
./app/benchmark/ffts/codegen_sse.h:96:void IMM32(uint8_t **p, int32_t imm) {
./app/benchmark/ffts/codegen_sse.h:99:		*(*p)++ = (imm & (0xff << (i*8))) >> (i*8);
./app/benchmark/ffts/codegen_sse.h:102:void IMM32_NI(uint8_t *p, int32_t imm) {
./app/benchmark/ffts/codegen_sse.h:105:		*(p+i) = (imm & (0xff << (i*8))) >> (i*8);
./app/benchmark/ffts/codegen_sse.h:118:void MOVI(uint8_t **p, uint8_t dst, uint32_t imm) {
./app/benchmark/ffts/codegen_sse.h:119://  if(imm < 65536) *(*p)++ = 0x66; 
./app/benchmark/ffts/codegen_sse.h:122:  //if(imm < 65536 && imm >= 256) *(*p)++ = 0x66; 
./app/benchmark/ffts/codegen_sse.h:124:  //if(imm >= 256) 
./app/benchmark/ffts/codegen_sse.h:128: // if(imm < 256) IMM8(p, imm);
./app/benchmark/ffts/codegen_sse.h:130://if(imm < 65536) IMM16(p, imm);
./app/benchmark/ffts/codegen_sse.h:132:	IMM32(p, imm);
./app/benchmark/ffts/codegen_sse.h:141://IMM32(p, imm);
./app/benchmark/ffts/codegen_sse.h:167:void ADDI(uint8_t **p, uint8_t dst, int32_t imm) {
./app/benchmark/ffts/codegen_sse.h:172:	if(imm > 127 || imm <= -128) *(*p)++ = 0x81;
./app/benchmark/ffts/codegen_sse.h:177:	if(imm > 127 || imm <= -128) IMM32(p, imm);
./app/benchmark/ffts/codegen_sse.h:178:	else          IMM8(p, imm);
./app/benchmark/ffts/codegen_sse.h:196:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_nd.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_nd.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_nd.h:59:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/macros-altivec.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/macros-altivec.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/macros-altivec.h:49:/* It appears vec_malloc() and friends are not implemented on Linux */
./app/benchmark/ffts/macros-altivec.h:88:static inline V IMUL(V d, V re, V im)
./app/benchmark/ffts/macros-altivec.h:90:    im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-altivec.h:92:    return VSUB(re, im);  
./app/benchmark/ffts/macros-altivec.h:96:static inline V IMULJ(V d, V re, V im)
./app/benchmark/ffts/macros-altivec.h:98:    im = VMUL(im, VSWAPPAIRS(d));
./app/benchmark/ffts/macros-altivec.h:99:    return VMULADD(re, d, im);
./app/benchmark/ffts/macros-altivec.h:138:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/codegen.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/codegen.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/codegen.h:43:#include <limits.h>	   /* for PAGESIZE */
./app/benchmark/ffts/codegen.h:50:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/ffts_real.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_real.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_real.h:54:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/vfp.S:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/vfp.S:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/vfp.S:342:	vldr s8, [r3, #4] @ x0-im 
./app/benchmark/ffts/vfp.S:344:	vldr s0, [r4, #4] @ x1-im 
./app/benchmark/ffts/vfp.S:346:	vldr s4, [r5, #4] @ x2-im 
./app/benchmark/ffts/vfp.S:348:	vldr s15, [r6, #4] @ x3-im 
./app/benchmark/ffts/vfp.S:352:	vldr s1, [r7, #4] @ x4-im 
./app/benchmark/ffts/vfp.S:354:	vldr s18, [r9, #4] @ x6-im 
./app/benchmark/ffts/vfp.S:413:	vldr s8, [r8, #4] @ x5-im 
./app/benchmark/ffts/vfp.S:415:	vldr s11, [r10, #4] @ x7-im 
./app/benchmark/ffts/include/ffts.h:11: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/include/ffts.h:13: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/include/ffts.h:56:// For real transforms, sign == -1 implies a real-to-complex forwards tranform,
./app/benchmark/ffts/include/ffts.h:57:// and sign == 1 implies a complex-to-real backwards transform
./app/benchmark/ffts/include/ffts.h:72:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/neon.S:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/neon.S:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/config.h:23:/* Define to 1 if you have the `gettimeofday' function. */
./app/benchmark/ffts/config.h:65:/* Define to 1 if you have the <sys/time.h> header file. */
./app/benchmark/ffts/config.h:147:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/neon_static_i.S:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/neon_static_i.S:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_real_nd.c:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/ffts_real_nd.c:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/ffts_real_nd.c:197:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/patterns.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/patterns.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/patterns.h:45:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/vfp.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/vfp.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/vfp.h:46:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/ffts/Makefile.in:7:# gives unlimited permission to copy and/or distribute it,
./app/benchmark/ffts/Makefile.in:12:# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
./app/benchmark/ffts/Makefile.in:729:# Otherwise a system limit (for SysV at least) may be exceeded.
./app/benchmark/ffts/types.h:13: 		notice, this list of conditions and the following disclaimer.
./app/benchmark/ffts/types.h:15: 		notice, this list of conditions and the following disclaimer in the
./app/benchmark/ffts/types.h:50:// vim: set autoindent noexpandtab tabstop=3 shiftwidth=3:
./app/benchmark/coremark/ee_printf.c:2:	This file contains an implementation of ee_printf that only requires a method to output a char to a UART without pulling in library code.
./app/benchmark/coremark/ee_printf.c:12:    notice, this list of conditions and the following disclaimer.  
./app/benchmark/coremark/ee_printf.c:14:    notice, this list of conditions and the following disclaimer in the
./app/benchmark/coremark/ee_printf.c:318:static void decimal_point(char *buffer)
./app/benchmark/coremark/ee_printf.c:400:  if ((flags & HEX_PREP) && precision == 0) decimal_point(tmp);
./app/benchmark/coremark/ee_printf.c:581://BBU #error "You must implement the method uart_send_char to use this file!\n";
./app/benchmark/coremark/core_matrix.c:24:	This very simple algorithm forms the basis of many more complex algorithms. 
./app/benchmark/coremark/core_matrix.c:26:	The tight inner loop is the focus of many optimizations (compiler as well as hardware based) 
./app/benchmark/coremark/core_matrix.c:34:	The actual values for A and B must be derived based on input that is not available at compile time.
./app/benchmark/coremark/core_matrix.c:78:	Iterate <matrix_test> N times, 
./app/benchmark/coremark/core_matrix.c:79:	changing the matrix values slightly by a constant amount each time.
./app/benchmark/coremark/core_matrix.c:97:	N - Dimensions of the matrix.
./app/benchmark/coremark/core_matrix.c:160:	Matrix dimensions.
./app/benchmark/coremark/core_matrix.c:163:	The seed parameter MUST be supplied from a source that cannot be determined at compile time
./app/benchmark/coremark/core_matrix.c:263:	This is common in many simple filters (e.g. fir where a vector of coefficients is applied to the matrix.)
./app/benchmark/coremark/core_portme.c:28:/* Porting : Timing functions
./app/benchmark/coremark/core_portme.c:29:	How to capture time and convert to seconds must be ported to whatever is supported by the platform.
./app/benchmark/coremark/core_portme.c:31:	Sample implementation for standard time.h and windows.h definitions included.
./app/benchmark/coremark/core_portme.c:34:   return timer_get_count(0); //BBU
./app/benchmark/coremark/core_portme.c:35:	//#error "You must implement a method to measure time in barebones_clock()! This function should return current time.\n"
./app/benchmark/coremark/core_portme.c:38:	Divider to trade off timer resolution and total time that can be measured.
./app/benchmark/coremark/core_portme.c:50:/** Define Host specific (POSIX), or target specific global time variables. */
./app/benchmark/coremark/core_portme.c:51:static CORETIMETYPE start_time_val, stop_time_val;
./app/benchmark/coremark/core_portme.c:53:/* Function : start_time
./app/benchmark/coremark/core_portme.c:54:	This function will be called right before starting the timed portion of the benchmark.
./app/benchmark/coremark/core_portme.c:56:	Implementation may be capturing a system timer (as implemented in the example code) 
./app/benchmark/coremark/core_portme.c:59:void start_time(void) {
./app/benchmark/coremark/core_portme.c:60:	GETMYTIME(&start_time_val );      
./app/benchmark/coremark/core_portme.c:62:/* Function : stop_time
./app/benchmark/coremark/core_portme.c:63:	This function will be called right after ending the timed portion of the benchmark.
./app/benchmark/coremark/core_portme.c:65:	Implementation may be capturing a system timer (as implemented in the example code) 
./app/benchmark/coremark/core_portme.c:68:void stop_time(void) {
./app/benchmark/coremark/core_portme.c:69:	GETMYTIME(&stop_time_val );      
./app/benchmark/coremark/core_portme.c:71:/* Function : get_time
./app/benchmark/coremark/core_portme.c:72:	Return an abstract "ticks" number that signifies time on the system.
./app/benchmark/coremark/core_portme.c:75:	as long as it can be converted to seconds by <time_in_secs>.
./app/benchmark/coremark/core_portme.c:76:	This methodology is taken to accomodate any hardware or simulated platform.
./app/benchmark/coremark/core_portme.c:77:	The sample implementation returns millisecs by default, 
./app/benchmark/coremark/core_portme.c:80:CORE_TICKS get_time(void) {
./app/benchmark/coremark/core_portme.c:81:	CORE_TICKS elapsed=(CORE_TICKS)(TIMER_GET_INTERVAL(stop_time_val, start_time_val));
./app/benchmark/coremark/core_portme.c:84:/* Function : time_in_secs
./app/benchmark/coremark/core_portme.c:85:	Convert the value returned by get_time to seconds.
./app/benchmark/coremark/core_portme.c:88:	Default implementation implemented by the EE_TICKS_PER_SEC macro above.
./app/benchmark/coremark/core_portme.c:90:secs_ret time_in_secs(CORE_TICKS ticks) {
Binary file ./app/benchmark/coremark/obj/arm/cvt.o matches
Binary file ./app/benchmark/coremark/obj/arm/core_portme.o matches
Binary file ./app/benchmark/coremark/obj/arm/core_main.o matches
./app/benchmark/coremark/core_state.c:25:	Simple state machines like this one are used in many embedded products.
./app/benchmark/coremark/core_state.c:27:	For more complex state machines, sometimes a state transition table implementation is used instead, 
./app/benchmark/coremark/core_state.c:93:	/* end timing */
./app/benchmark/coremark/core_state.c:114:	The seed parameter MUST be supplied from a source that cannot be determined at compile time
./app/benchmark/coremark/core_util.c:21:	Get a values that cannot be determined at compile time.
./app/benchmark/coremark/core_util.c:25:	reads the value of a volatile variable from memory at run time. 
./app/benchmark/coremark/core_util.c:31:	e.g. read the value on GPIO pins connected to switches, or invoke special simulator functions.
./app/benchmark/coremark/core_util.c:111:/* If using OS based function, you must define and implement the functions below in core_portme.h and core_portme.c ! */
./app/benchmark/coremark/core_list_join.c:143:	/* find <find_num> values in the list, and change the list each time (reverse and cache if value found) */
./app/benchmark/coremark/core_list_join.c:207:		The seed parameter MUST be supplied from a source that cannot be determined at compile time
./app/benchmark/coremark/core_list_join.c:323:	/* and eliminate item */
./app/benchmark/coremark/core_list_join.c:410:	Also, since this is aimed at embedded, care was taken to use iterative rather then recursive algorithm.
./app/benchmark/coremark/core_portme.h:22:	Define to 1 if platform has the time.h header file,
./app/benchmark/coremark/core_portme.h:23:	and implementation of functions thereof.
./app/benchmark/coremark/core_portme.h:29:	Define to 1 if platform has the time.h header file,
./app/benchmark/coremark/core_portme.h:30:	and implementation of functions thereof.
./app/benchmark/coremark/core_portme.h:42:	Define to 1 if the platform has stdio.h and implements the printf function.
./app/benchmark/coremark/core_portme.h:58:extern unsigned int timer_get_count(int id) ;
./app/benchmark/coremark/core_portme.h:98:	Define type of return from the timing functions.
./app/benchmark/coremark/core_portme.h:104:	Defines method to get seed values that cannot be computed at compile time.
./app/benchmark/coremark/core_portme.h:119:	MEM_MALLOC - for platforms that implement malloc and have malloc.h.
./app/benchmark/coremark/core_portme.h:135:	If this flag is defined to more then 1, an implementation for launching parallel contexts must be defined.
./app/benchmark/coremark/core_portme.h:137:	Two sample implementations are provided. Use <USE_PTHREAD> or <USE_FORK> to enable them.
./app/benchmark/coremark/core_portme.h:139:	It is valid to have a different implementation of <core_start_parallel> and <core_end_parallel> in <core_portme.c>,
./app/benchmark/coremark/core_portme.h:175:	Not used for this simple port, must cintain the value 1.
./app/benchmark/coremark/core_main.c:30:		b - Execute the algorithm N times.
./app/benchmark/coremark/core_main.c:75:	1 - Initialize input seeds from a source that cannot be determined at compile time.
./app/benchmark/coremark/core_main.c:77:	3 - Run and time the benchmark.
./app/benchmark/coremark/core_main.c:98:	CORE_TICKS total_time;
./app/benchmark/coremark/core_main.c:203:			start_time();
./app/benchmark/coremark/core_main.c:205:			stop_time();
./app/benchmark/coremark/core_main.c:206:			secs_passed=time_in_secs(get_time());
./app/benchmark/coremark/core_main.c:208:		/* now we know it executes for at least 1 sec, set actual run time at about 10 secs */
./app/benchmark/coremark/core_main.c:215:	start_time();
./app/benchmark/coremark/core_main.c:231:	stop_time();
./app/benchmark/coremark/core_main.c:232:	total_time=get_time();
./app/benchmark/coremark/core_main.c:288:	ee_printf("Total ticks      : %lu\n\r",(ee_u32)total_time);
./app/benchmark/coremark/core_main.c:290:	ee_printf("Total time (secs): %f\n\r",time_in_secs(total_time));
./app/benchmark/coremark/core_main.c:291:	if (time_in_secs(total_time) > 0)
./app/benchmark/coremark/core_main.c:292:		ee_printf("Iterations/Sec   : %f\n\r",default_num_contexts*results[0].iterations/time_in_secs(total_time));
./app/benchmark/coremark/core_main.c:294:	ee_printf("Total time (secs): %d\n\r",time_in_secs(total_time));
./app/benchmark/coremark/core_main.c:295:	if (time_in_secs(total_time) > 0)
./app/benchmark/coremark/core_main.c:296:		ee_printf("Iterations/Sec   : %d\n\r",default_num_contexts*results[0].iterations/time_in_secs(total_time));
./app/benchmark/coremark/core_main.c:298:	if (time_in_secs(total_time) < 10) {
./app/benchmark/coremark/core_main.c:327:			ee_printf("CoreMark 1.0 : %f / %s %s",default_num_contexts*results[0].iterations/time_in_secs(total_time),COMPILER_VERSION,COMPILER_FLAGS);
./app/benchmark/coremark/coremark.h:68:void start_time(void);
./app/benchmark/coremark/coremark.h:69:void stop_time(void);
./app/benchmark/coremark/coremark.h:70:CORE_TICKS get_time(void);
./app/benchmark/coremark/coremark.h:71:secs_ret time_in_secs(CORE_TICKS ticks);
Binary file ./app/benchmark/dhrystone/obj/arm/drys_2.o matches
Binary file ./app/benchmark/dhrystone/obj/arm/drys_1.o matches
./app/benchmark/dhrystone/obj/arm/drys_1.d:33: /home/feature_phone/crane/driver/timer/clock.h
./app/benchmark/dhrystone/drys.h:19: *                                      (8-17 Central European Time)
./app/benchmark/dhrystone/drys.h:30: *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
./app/benchmark/dhrystone/drys.h:31: *              are used for execution time measurement. For measurements
./app/benchmark/dhrystone/drys.h:49: *      Software information includes: Compiler (and runtime library)
./app/benchmark/dhrystone/drys.h:72: *              statistics, optimizing compilers should be prevented from
./app/benchmark/dhrystone/drys.h:78: *              him over the UNIX network Usenet.
./app/benchmark/dhrystone/drys.h:79: *              I also thank Chaim Benedelac (National Semiconductor),
./app/benchmark/dhrystone/drys.h:95: *              are not executed. The intention is that optimizing compilers
./app/benchmark/dhrystone/drys.h:101: *              still hold. Except for sophisticated optimizing compilers,
./app/benchmark/dhrystone/drys.h:102: *              execution times for this version should be the same as
./app/benchmark/dhrystone/drys.h:105: *              Since it has proven difficult to subtract the time for the
./app/benchmark/dhrystone/drys.h:108: *              an impact - though a very minor one - on the distribution
./app/benchmark/dhrystone/drys.h:115: *              Because of the self-imposed limitation that the order and
./app/benchmark/dhrystone/drys.h:117: *              changed, there are still cases where optimizing compilers
./app/benchmark/dhrystone/drys.h:134: *                      As an approximation to what an average C programmer
./app/benchmark/dhrystone/drys.h:138: *                        five or more times
./app/benchmark/dhrystone/drys.h:140: *                        six or more times
./app/benchmark/dhrystone/drys.h:141: *                      Note that an optimal "register" strategy is
./app/benchmark/dhrystone/drys.h:152: *                      The "times" function of UNIX (returning process times)
./app/benchmark/dhrystone/drys.h:153: *                      or the "time" function (returning wallclock time)
./app/benchmark/dhrystone/drys.h:155: *                      For single user machines, "time ()" is adequate. For
./app/benchmark/dhrystone/drys.h:157: *                      access, use the "times ()" function. If you have
./app/benchmark/dhrystone/drys.h:159: *                      "printf"s are provided marking the points "Start Timer"
./app/benchmark/dhrystone/drys.h:160: *                      and "Stop Timer". DO NOT use the UNIX "time(1)"
./app/benchmark/dhrystone/drys.h:161: *                      command, as this will measure the total time to
./app/benchmark/dhrystone/drys.h:163: *                      the time to allocate storage (malloc) and to perform
./app/benchmark/dhrystone/drys.h:166: *                      In Berkeley UNIX, the function "times" returns process
./app/benchmark/dhrystone/drys.h:167: *                      time in 1/HZ seconds, with HZ = 60 for most systems.
./app/benchmark/dhrystone/drys.h:183: *  - Otherwise, compiler optimizations are allowed but should be indicated
./app/benchmark/dhrystone/drys.h:188: *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
./app/benchmark/dhrystone/drys.h:215: *  The combination of these three aspects is balanced only approximately.    
./app/benchmark/dhrystone/drys.h:246: *     for ...                     7  |  counted every time
./app/benchmark/dhrystone/drys.h:273: *                          number    approximate
./app/benchmark/dhrystone/drys.h:304: *                          number    approximate
./app/benchmark/dhrystone/drys.h:322: *                                number    approximate
./app/benchmark/dhrystone/drys.h:361:                /* Use times(2) time function unless    */
./app/benchmark/dhrystone/drys.h:367:#include <time.h>
./app/benchmark/dhrystone/drys.h:374:#include <sys/times.h>
./app/benchmark/dhrystone/drys.h:375:                /* for "times" */
./app/benchmark/dhrystone/drys.h:379:                /* Berkeley UNIX C returns process times in seconds/HZ */
./app/benchmark/dhrystone/drys.h:415:typedef int     Arr_1_Dim [50];
./app/benchmark/dhrystone/drys.h:416:typedef int     Arr_2_Dim [50] [50];
./app/benchmark/dhrystone/drys.h:440:void Drys_timer0_ISR(void);
./app/benchmark/dhrystone/drys_2.c:67:    /* executed three times                                      */ 
./app/benchmark/dhrystone/drys_2.c:90:Arr_1_Dim       Arr_1_Par_Ref;
./app/benchmark/dhrystone/drys_2.c:91:Arr_2_Dim       Arr_2_Par_Ref;
./app/benchmark/dhrystone/drys_2.c:112:    /* executed three times                                         */
./app/benchmark/dhrystone/drys_1.c:34:extern void (*timer0_handler)();
./app/benchmark/dhrystone/drys_1.c:36:  /* forward declaration necessary since Enumeration may not simply be int */
./app/benchmark/dhrystone/drys_1.c:47:/* variables for time measurement: */
./app/benchmark/dhrystone/drys_1.c:50:struct tms      time_info;
./app/benchmark/dhrystone/drys_1.c:51:extern  int     times ();
./app/benchmark/dhrystone/drys_1.c:52:                /* see library function "times" */
./app/benchmark/dhrystone/drys_1.c:53:#define Too_Small_Time (2*HZ)
./app/benchmark/dhrystone/drys_1.c:57:extern long     time();
./app/benchmark/dhrystone/drys_1.c:58:                /* see library function "time"  */
./app/benchmark/dhrystone/drys_1.c:59:#define Too_Small_Time 2
./app/benchmark/dhrystone/drys_1.c:64:#define Too_Small_Time (2*HZ)
./app/benchmark/dhrystone/drys_1.c:67:double     User_Hz,User_Time;
./app/benchmark/dhrystone/drys_1.c:68:long            Begin_Time,
./app/benchmark/dhrystone/drys_1.c:69:                End_Time;
./app/benchmark/dhrystone/drys_1.c:83:void Proc_8 (Arr_1_Dim Arr_1_Par_Ref, Arr_2_Dim Arr_2_Par_Ref, int Int_1_Par_Val, int Int_2_Par_Val);
./app/benchmark/dhrystone/drys_1.c:85:/* end of variables for time measurement */
./app/benchmark/dhrystone/drys_1.c:119:#define Too_Small_Time   2
./app/benchmark/dhrystone/drys_1.c:165:  /* Start timer */
./app/benchmark/dhrystone/drys_1.c:217:  /* Stop timer */
./app/benchmark/dhrystone/drys_1.c:221:  User_Time = (double)usec/1000000;  //User_Time is in second
./app/benchmark/dhrystone/drys_1.c:223:  if (User_Time < Too_Small_Time)
./app/benchmark/dhrystone/drys_1.c:225:    bbu_printf ("Measured time too small to obtain meaningful results\n\r");
./app/benchmark/dhrystone/drys_1.c:231:    Microseconds = (double) User_Time * Mic_secs_Per_Second 
./app/benchmark/dhrystone/drys_1.c:233:    Dhrystones_Per_Second = (Number_Of_Runs / (double) User_Time);
./app/benchmark/dhrystone/drys_1.c:234:    bbu_printf("Used time for %d drystone test: \r\n", Number_Of_Runs);
./app/benchmark/dhrystone/drys_1.c:235:    bbu_printf("%10.6f sec\r\n", User_Time);
./app/benchmark/memcpy/machine/asm.h:15: *    notice, this list of conditions and the following disclaimer.
./app/benchmark/memcpy/machine/asm.h:17: *    notice, this list of conditions and the following disclaimer in the
./app/benchmark/memcpy/machine/cpu-features.h:9: *    notice, this list of conditions and the following disclaimer.
./app/benchmark/memcpy/machine/cpu-features.h:11: *    notice, this list of conditions and the following disclaimer in
./app/benchmark/memcpy/machine/cpu-features.h:32: * to CPU features that may or may not be available at build time on
./app/benchmark/memcpy/machine/cpu-features.h:73:#    error ARMv4 is not supported, please use ARMv4T at a minimum
./app/benchmark/memcpy/machine/cpu-features.h:79:/* experimental feature used to check that our ARMv4 workarounds
./app/benchmark/memcpy/machine/cpu-features.h:166: * (also present in ARMv6K, but not implemented in ARMv7-M, neither of which
./app/benchmark/memcpy/machine/cpu-features.h:180: * Neon SIMD instruction set extensions. This also implies
./app/benchmark/memcpy/memcpy_jb4_3_in_cortexa15.S:9: *    notice, this list of conditions and the following disclaimer.
./app/benchmark/memcpy/memcpy_jb4_3_in_cortexa15.S:11: *    notice, this list of conditions and the following disclaimer in
./app/benchmark/memcpy/memcpy_jb4_3_in_cortexa15.S:81:0:      /* preload immediately the next cache line, which we may need */
./app/benchmark/memcpy/memcpy_jb4_3_in_cortexa15.S:95:         * experimentation.
./app/benchmark/memcpy/memcpy_jb4_3_in_cortexa15.S:101:1:      /* The main loop copies 64 bytes at a time */
./app/benchmark/memcpy/memcpy_jb4_3_in_cortexa15.S:115:3:      /* 32 bytes at a time. These cache lines were already preloaded */
./app/benchmark/memcpy/memcpy.a15_new.S:11: *    notice, this list of conditions and the following disclaimer.
./app/benchmark/memcpy/memcpy.a15_new.S:13: *    notice, this list of conditions and the following disclaimer in the
./app/benchmark/memcpy/memcpy.a15_new.S:43:        * bytes, copy 2 words a time until less than 8 bytes left, then copy a
./app/benchmark/memcpy/memcpy.a15_new.S:64:        /* preload immediately the next cache line, which we may need */
./app/benchmark/memcpy/memcpy.a15_new.S:76:         * is not 32-bytes aligned, then it's more important to align dst than
./app/benchmark/memcpy/memcpy.a15_new.S:123:         * experimentation.
./app/benchmark/memcpy/memcpy.a15_new.S:129:1:      /* The main loop copies 64 bytes at a time */
./app/benchmark/memcpy/memcpy.a15_new.S:152:        /* Copy 8 bytes at a time.  */
./app/benchmark/memcpy/memcpy.a15_new.S:243:        /* Copy 8 bytes at a time.  */
./app/benchmark/memcpy/memcpy_jb_4_2_mrvl_opt.S:108: * Function that is similar to standard memcpy function
./app/benchmark/memcpy/memcpy_test.c:85:		bbu_printf("Time measured using cycle counter: %.2f\n\r", (double)(cycle*divider)/(double)(coreFreqMHz*1000000));
./app/benchmark/memcpy/memcpy.a15_old.S:9: *    notice, this list of conditions and the following disclaimer.
./app/benchmark/memcpy/memcpy.a15_old.S:11: *    notice, this list of conditions and the following disclaimer in the
./app/benchmark/memcpy/memcpy.a15_old.S:31:        /* Use the version of memcpy implemented using LDRD and STRD.
./app/benchmark/memcpy/memcpy.a15_old.S:42:           However, by using the same code, we may be missing optimization
./app/benchmark/memcpy/memcpy.a15_old.S:62:          optimized push {r0, r4, r5, r6, r7, lr}.
./app/benchmark/memcpy/memcpy.a15_old.S:63:          To try and improve performance, stack layout changed,
./app/benchmark/memcpy/memcpy.a15_old.S:104:           then it's more important to align dst than src,
./app/benchmark/memcpy/memcpy.a15_old.S:122:        /* TODO: Align to cacheline (useful for PLD optimization).  */
./app/benchmark/memcpy/memcpy.a15_old.S:143:        /* Copy 8 bytes at a time.  */
./app/benchmark/memcpy/memcpy.a15_old.S:191:        /* Restore registers: optimized pop {r0, r4, r5, r6, r7, pc}   */
./app/benchmark/memcpy/memcpy.a15_old.S:199:       /* The following assembly macro implements misaligned copy in software.
./app/benchmark/memcpy/memcpy.a15_old.S:255:        /* Copy 8 bytes at a time.
Binary file ./app/benchmark/llcbench/obj/arm/flushall.o matches
./app/benchmark/llcbench/cachebench/cachebench.c:64:static long resolution = RESOLUTION, timeslots, duration = MEASURE_TIME, type = NOCALIBRATE;
./app/benchmark/llcbench/cachebench/cachebench.c:66:static int timer_used;
./app/benchmark/llcbench/cachebench/cachebench.c:88:  free_timer(timer_used);
./app/benchmark/llcbench/cachebench/cachebench.c:92:extern void free_timer(int index);
./app/benchmark/llcbench/cachebench/cachebench.c:96:  free_timer(timer_used);
./app/benchmark/llcbench/cachebench/cachebench.c:101:		   double *times, double *bws, double *percents, long *sizes,
./app/benchmark/llcbench/cachebench/cachebench.c:106:  ARRAY(times,i,j,repeat_count) = 
./app/benchmark/llcbench/cachebench/cachebench.c:111:    ((ARRAY(times,i,j,repeat_count)*refcnt)/1.0E9);
./app/benchmark/llcbench/cachebench/cachebench.c:121:	    ARRAY(times,i,j,repeat_count) / 
./app/benchmark/llcbench/cachebench/cachebench.c:122:	    ARRAY(times,i,j-1,repeat_count);
./app/benchmark/llcbench/cachebench/cachebench.c:130:	    ARRAY(times,i,j,repeat_count) / 
./app/benchmark/llcbench/cachebench/cachebench.c:131:	    ARRAY(times,i-1,repeat_count-1,repeat_count);
./app/benchmark/llcbench/cachebench/cachebench.c:136:	    ARRAY(times,i,j,repeat_count) / 
./app/benchmark/llcbench/cachebench/cachebench.c:137:	    ARRAY(times,i,j-1,repeat_count);
./app/benchmark/llcbench/cachebench/cachebench.c:145:	       ARRAY(times,i,j,repeat_count),
./app/benchmark/llcbench/cachebench/cachebench.c:155:void compute_cache_sizes(double *times, double *bws, double *percents, long *sizes)
./app/benchmark/llcbench/cachebench/cachebench.c:162:  for (i=0; i < timeslots; i++)
./app/benchmark/llcbench/cachebench/cachebench.c:166:  for (i=0; i < timeslots; i++)
./app/benchmark/llcbench/cachebench/cachebench.c:178:      bbu_printf("No L1 limit found, must be larger than %ld bytes.\n\r",memsize);
./app/benchmark/llcbench/cachebench/cachebench.c:193:      if ((times[maxa]/times[maxb] < THRESHOLD) && (1.0/percents[maxb] < THRESHOLD))
./app/benchmark/llcbench/cachebench/cachebench.c:290:  timeslots = resolution*(logmemsize - CACHE_MIN_BITS) + 1;
./app/benchmark/llcbench/cachebench/cachebench.c:292:  DBG(bbu_printf("%ld %ld %ld %ld\n\r",logmemsize,memsize,duration,timeslots)); 
./app/benchmark/llcbench/cachebench/cachebench.c:298:void fake_out_optimizations(DATATYPE *x, long bytes)
./app/benchmark/llcbench/cachebench/cachebench.c:308:/* double calibrate_benchmark_ronly(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:316:  limit -= 4; foolem = (DATATYPE)limit;
./app/benchmark/llcbench/cachebench/cachebench.c:322:  if (((index+=4) < limit) && (keepgoing))
./app/benchmark/llcbench/cachebench/cachebench.c:335:  //fake_out_optimizations(x,2*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:339:  return(((double)loops*(double)limit)+(double)index);  
./app/benchmark/llcbench/cachebench/cachebench.c:342:double calibrate_benchmark_wonly(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:350:  limit -= 4; 
./app/benchmark/llcbench/cachebench/cachebench.c:359:  if (((index+=4) < limit) && (keepgoing))
./app/benchmark/llcbench/cachebench/cachebench.c:372:  //fake_out_optimizations(x,2*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:374:  return(((double)loops*(double)limit)+(double)index);
./app/benchmark/llcbench/cachebench/cachebench.c:377:double calibrate_benchmark(REGISTER DATATYPE *x, REGISTER long to_do_loops, REGISTER long limit, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:385:      for (index = 0; index < limit; index++)
./app/benchmark/llcbench/cachebench/cachebench.c:395:  //fake_out_optimizations(x,2*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:399:    double refcnt = ((double)loops*(double)limit)+(double)index;
./app/benchmark/llcbench/cachebench/cachebench.c:400:    DBG(bbu_printf("C: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:405:double benchmark_cache_ronly(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:415:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:424:      for  (index = 0; index < limit; index++)
./app/benchmark/llcbench/cachebench/cachebench.c:435:  //fake_out_optimizations(x,2*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:440:    double refcnt = ((double)loops*(double)limit);
./app/benchmark/llcbench/cachebench/cachebench.c:441:    DBG(bbu_printf("T: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:446:double hand_benchmark_cache_ronly(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:455:  limit -= 8;
./app/benchmark/llcbench/cachebench/cachebench.c:458:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:464:  if ((index += 8) < limit)
./app/benchmark/llcbench/cachebench/cachebench.c:478:  //fake_out_optimizations(x,2*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:483:    double refcnt = ((double)loops*(double)limit);
./app/benchmark/llcbench/cachebench/cachebench.c:484:    DBG(bbu_printf("T: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:489:double benchmark_cache_wonly(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:497:  wval = (DATATYPE)limit;
./app/benchmark/llcbench/cachebench/cachebench.c:500:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:505:      for  (index = 0; index < limit; index++)
./app/benchmark/llcbench/cachebench/cachebench.c:512:  //fake_out_optimizations(x,limit*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:517:    double refcnt = ((double)loops*(double)limit);
./app/benchmark/llcbench/cachebench/cachebench.c:518:    DBG(bbu_printf("T: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:523:double hand_benchmark_cache_wonly(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:531:  limit -= 8; wval = (DATATYPE)limit;
./app/benchmark/llcbench/cachebench/cachebench.c:534:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:546:  if ((index+=8) < limit)
./app/benchmark/llcbench/cachebench/cachebench.c:558:  //fake_out_optimizations(x,limit*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:563:    double refcnt = ((double)loops*(double)limit);
./app/benchmark/llcbench/cachebench/cachebench.c:564:    DBG(bbu_printf("T: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:569:double benchmark_cache(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:578:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:583:      for (index = 0; index < limit; index++)
./app/benchmark/llcbench/cachebench/cachebench.c:590:  //fake_out_optimizations(x,limit*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:595:    double refcnt = ((double)loops*(double)limit);
./app/benchmark/llcbench/cachebench/cachebench.c:596:    DBG(bbu_printf("T: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:601:double hand_benchmark_cache(REGISTER DATATYPE *x, REGISTER long limit, long *oloops, double *ous)
./app/benchmark/llcbench/cachebench/cachebench.c:610:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:622:  if ((index+=8) <= limit-8)
./app/benchmark/llcbench/cachebench/cachebench.c:633:  //fake_out_optimizations(x,limit*sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:638:    double refcnt = ((double)loops*(double)limit);
./app/benchmark/llcbench/cachebench/cachebench.c:639:    DBG(bbu_printf("T: %ld loops at limit %ld took %f us, %f refs.\n\r",loops,limit,*ous,refcnt));
./app/benchmark/llcbench/cachebench/cachebench.c:654:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:665:  //fake_out_optimizations(x,bytes);
./app/benchmark/llcbench/cachebench/cachebench.c:666:  //fake_out_optimizations(y,bytes);
./app/benchmark/llcbench/cachebench/cachebench.c:682:  timer_used = start_timer(1000*duration, handler, TIMER_ONE_SHOT);
./app/benchmark/llcbench/cachebench/cachebench.c:693:  //fake_out_optimizations(x,bytes);
./app/benchmark/llcbench/cachebench/cachebench.c:704:  for (j=0; j<timeslots; j+=resolution)
./app/benchmark/llcbench/cachebench/cachebench.c:711:	  if (j+i < timeslots)
./app/benchmark/llcbench/cachebench/cachebench.c:721:void do_memory_copy(long *sizes, void *x, double *times, double *bws, double *percents)
./app/benchmark/llcbench/cachebench/cachebench.c:723:  long limit, j, i, tloops;
./app/benchmark/llcbench/cachebench/cachebench.c:739:  for (i = 0; i < timeslots; i++) 
./app/benchmark/llcbench/cachebench/cachebench.c:741:      limit = sizes[i];
./app/benchmark/llcbench/cachebench/cachebench.c:744:	  refcnt = benchmark_cache_memory_copy(x, y, limit, &tloops, &tmicrosec) * 2.0;
./app/benchmark/llcbench/cachebench/cachebench.c:754:	      nullcnt = calibrate_benchmark_cache_memory_copy(x, tloops, limit, &cmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:759:	  compute_stats(i,j,refcnt,overhead_per_ref,times,bws,percents,sizes,tmicrosec,1);
./app/benchmark/llcbench/cachebench/cachebench.c:764:    compute_cache_sizes(times,bws,percents,sizes); */
./app/benchmark/llcbench/cachebench/cachebench.c:769:void do_memory_set(long *sizes, DATATYPE *x, double *times, double *bws, double *percents)
./app/benchmark/llcbench/cachebench/cachebench.c:771:  long limit, j, i, tloops;
./app/benchmark/llcbench/cachebench/cachebench.c:784:  for (i = 0; i < timeslots; i++) 
./app/benchmark/llcbench/cachebench/cachebench.c:786:      limit = sizes[i];
./app/benchmark/llcbench/cachebench/cachebench.c:789:	  refcnt = benchmark_cache_memory_set(x, limit, &tloops, &tmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:799:	      nullcnt = calibrate_benchmark_cache_memory_copy(x, tloops, limit, &cmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:804:	  compute_stats(i,j,refcnt,overhead_per_ref,times,bws,percents,sizes,tmicrosec,1);
./app/benchmark/llcbench/cachebench/cachebench.c:809:    compute_cache_sizes(times,bws,percents,sizes); */
./app/benchmark/llcbench/cachebench/cachebench.c:812:void do_read_only(long *sizes, DATATYPE *x, double *times, double *bws, double *percents)
./app/benchmark/llcbench/cachebench/cachebench.c:814:  long limit, j, i, tloops;
./app/benchmark/llcbench/cachebench/cachebench.c:828:  for (i = 0; i < timeslots; i++) 
./app/benchmark/llcbench/cachebench/cachebench.c:830:      limit = sizes[i] / (long)sizeof(DATATYPE);
./app/benchmark/llcbench/cachebench/cachebench.c:834:	    refcnt = hand_benchmark_cache_ronly(x, limit, &tloops, &tmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:836:	    refcnt = benchmark_cache_ronly(x, limit, &tloops, &tmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:846:	      nullcnt = calibrate_benchmark(x, tloops, limit, &cmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:851:	  compute_stats(i,j,refcnt,overhead_per_ref,times,bws,percents,sizes,tmicrosec,sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:856:    compute_cache_sizes(times,bws,percents,sizes); */
./app/benchmark/llcbench/cachebench/cachebench.c:859:void do_write_only(long *sizes, DATATYPE *x, double *times, double *bws, double *percents)
./app/benchmark/llcbench/cachebench/cachebench.c:861:  long limit, j, i, tloops;
./app/benchmark/llcbench/cachebench/cachebench.c:875:  for (i = 0; i < timeslots; i++) 
./app/benchmark/llcbench/cachebench/cachebench.c:877:      limit = sizes[i] / (long)sizeof(DATATYPE);
./app/benchmark/llcbench/cachebench/cachebench.c:881:	    refcnt = hand_benchmark_cache_wonly(x, limit, &tloops, &tmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:883:	    refcnt = benchmark_cache_wonly(x, limit, &tloops, &tmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:893:	      nullcnt = calibrate_benchmark(x, tloops, limit, &cmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:898:	  compute_stats(i,j,refcnt,overhead_per_ref,times,bws,percents,sizes,tmicrosec,sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:903:    compute_cache_sizes(times,bws,percents,sizes); */
./app/benchmark/llcbench/cachebench/cachebench.c:906:void do_read_write(long *sizes, DATATYPE *x, double *times, double *bws, double *percents)
./app/benchmark/llcbench/cachebench/cachebench.c:908:  long limit, j, i, tloops;
./app/benchmark/llcbench/cachebench/cachebench.c:922:  for (i = 0; i < timeslots; i++) 
./app/benchmark/llcbench/cachebench/cachebench.c:924:      limit = sizes[i] / (long)sizeof(DATATYPE);
./app/benchmark/llcbench/cachebench/cachebench.c:929:	    refcnt = hand_benchmark_cache(x, limit, &tloops, &tmicrosec) * 2.0;
./app/benchmark/llcbench/cachebench/cachebench.c:931:	    refcnt = benchmark_cache(x, limit, &tloops, &tmicrosec) * 2.0;
./app/benchmark/llcbench/cachebench/cachebench.c:941:	      nullcnt = calibrate_benchmark(x, tloops, limit, &cmicrosec);
./app/benchmark/llcbench/cachebench/cachebench.c:947:	  compute_stats(i,j,refcnt,overhead_per_ref,times,bws,percents,sizes,tmicrosec,sizeof(DATATYPE));
./app/benchmark/llcbench/cachebench/cachebench.c:952:    compute_cache_sizes(times,bws,percents,sizes); */
./app/benchmark/llcbench/cachebench/cachebench.c:959:  double *times, *bws, *percents;
./app/benchmark/llcbench/cachebench/cachebench.c:966:  assert(sizes = (long *)bbu_malloc(timeslots*sizeof(long)));
./app/benchmark/llcbench/cachebench/cachebench.c:967:  memset(sizes,0x00,(timeslots*sizeof(long)));
./app/benchmark/llcbench/cachebench/cachebench.c:968:  assert(times = (double *)bbu_malloc(timeslots*repeat_count*sizeof(double)));
./app/benchmark/llcbench/cachebench/cachebench.c:969:  memset(times,0x00,(timeslots*repeat_count*sizeof(double)));
./app/benchmark/llcbench/cachebench/cachebench.c:970:  assert(bws = (double *)bbu_malloc(timeslots*repeat_count*sizeof(double)));
./app/benchmark/llcbench/cachebench/cachebench.c:971:  memset(bws,0x00,(timeslots*repeat_count*sizeof(double)));
./app/benchmark/llcbench/cachebench/cachebench.c:972:  assert(percents = (double *)bbu_malloc(timeslots*repeat_count*sizeof(double)));
./app/benchmark/llcbench/cachebench/cachebench.c:973:  memset(percents,0x00,(timeslots*repeat_count*sizeof(double)));
./app/benchmark/llcbench/cachebench/cachebench.c:983:      do_memory_set(sizes,x,times,bws,percents);
./app/benchmark/llcbench/cachebench/cachebench.c:988:      do_memory_copy(sizes,x,times,bws,percents);
./app/benchmark/llcbench/cachebench/cachebench.c:993:      do_read_only(sizes,x,times,bws,percents);
./app/benchmark/llcbench/cachebench/cachebench.c:998:      do_write_only(sizes,x,times,bws,percents);
./app/benchmark/llcbench/cachebench/cachebench.c:1003:      do_read_write(sizes,x,times,bws,percents);
./app/benchmark/llcbench/cachebench/cachebench.c:1008:  bbu_mfree((void *)times);
./app/benchmark/llcbench/cachebench/obj/arm/cachebench.d:26: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/benchmark/llcbench/cachebench/obj/arm/cachebench.d:36: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./app/benchmark/llcbench/cachebench/obj/arm/cachebench.o matches
./app/benchmark/llcbench/llcbench.h:4:extern void timer_start(void);
./app/benchmark/llcbench/llcbench.h:5:extern void timer_stop(void);
./app/benchmark/llcbench/llcbench.h:6:extern double timer_elapsed(void);
./app/benchmark/llcbench/llcbench.h:7:#include "timer_dec.h"
./app/benchmark/llcbench/llcbench.h:11://#define TIMER_START timer_start()
./app/benchmark/llcbench/llcbench.h:12://#define TIMER_STOP timer_stop()
./app/benchmark/llcbench/llcbench.h:13://#define TIMER_ELAPSED timer_elapsed()
./app/benchmark/llcbench/llcbench.h:14:#define TIMER_START uint32_t begin_count = timer_get_count(0)
./app/benchmark/llcbench/llcbench.h:15:#define TIMER_STOP  uint32_t end_count = timer_get_count(0)
./app/benchmark/superpi/pi_fftcs.c:31:#include <limits.h>
./app/benchmark/superpi/pi_fftcs.c:35:#include <time.h>
./app/benchmark/superpi/pi_fftcs.c:40:#include "timer_dec.h"
./app/benchmark/superpi/pi_fftcs.c:49:void mp_imul (int n, int radix, int in1[], int in2, int out[]);
./app/benchmark/superpi/pi_fftcs.c:103:  //clock_t start_time;
./app/benchmark/superpi/pi_fftcs.c:104:  double start_time;
./app/benchmark/superpi/pi_fftcs.c:105:  double elap_time, loop_time;
./app/benchmark/superpi/pi_fftcs.c:172:  start_time = timer_get_count(0);
./app/benchmark/superpi/pi_fftcs.c:239:   *      Calculation of PI to 51.5 Billion Decimal Digits on
./app/benchmark/superpi/pi_fftcs.c:252:  mp_imul (n, radix, c, 3, e);
./app/benchmark/superpi/pi_fftcs.c:270:  elap_time = ((double) timer_get_count(0) - (double) start_time)/TIMER_FREQUENCY;
./app/benchmark/superpi/pi_fftcs.c:274:      double start_loop_time = timer_get_count(0);
./app/benchmark/superpi/pi_fftcs.c:296:      loop_time =
./app/benchmark/superpi/pi_fftcs.c:297:    ((double) timer_get_count(0) - (double) start_loop_time)/TIMER_FREQUENCY;
./app/benchmark/superpi/pi_fftcs.c:298:      elap_time += loop_time;
./app/benchmark/superpi/pi_fftcs.c:300:           loop_time);
./app/benchmark/superpi/pi_fftcs.c:303:  start_time = timer_get_count(0);
./app/benchmark/superpi/pi_fftcs.c:322:  elap_time += ((double) timer_get_count(0) - (double) start_time)/TIMER_FREQUENCY ;
./app/benchmark/superpi/pi_fftcs.c:399:  /* ---- difftime ---- */
./app/benchmark/superpi/pi_fftcs.c:400:  bbu_printf("\n\r%0.6f sec. (real time)\n\r", elap_time);
./app/benchmark/superpi/pi_fftcs.c:442:    void mp_imul(int n, int radix, int in1[], int in2, int out[]);
./app/benchmark/superpi/pi_fftcs.c:839:/* -------- mp_imul routines -------- */
./app/benchmark/superpi/pi_fftcs.c:843:mp_imul (int n, int radix, int in1[], int in2, int out[])
./app/benchmark/superpi/pi_fftcs.c:845:  void mp_unsgn_imul (int n, double dradix, int in1[], double din2,
./app/benchmark/superpi/pi_fftcs.c:861:  mp_unsgn_imul (n, radix, &in1[1], in2, &out[1]);
./app/benchmark/superpi/pi_fftcs.c:928:/* -------- mp_imul child routines -------- */
./app/benchmark/superpi/pi_fftcs.c:932:mp_unsgn_imul (int n, double dradix, int in1[], double din2, int out[])
./app/benchmark/superpi/pi_fftcs.c:2784:  void mp_imul (int n, int radix, int in1[], int in2, int out[]);
./app/benchmark/superpi/pi_fftcs.c:2802:  mp_imul (n, radix, tmp1, in, tmp1);
Binary file ./app/benchmark/superpi/obj/arm/fftsg_h.o matches
Binary file ./app/benchmark/superpi/obj/arm/pi_fftcs.o matches
./app/benchmark/superpi/obj/arm/pi_fftcs.d:27: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/benchmark/superpi/obj/arm/pi_fftcs.d:37: /home/feature_phone/crane/driver/timer/clock.h \
./app/benchmark/superpi/fftsg_h.c:3:    dimension   :one 
./app/benchmark/superpi/fftsg_h.c:5:    decimation  :frequency 
./app/benchmark/tmark/src/common/mrvl_fast.S:108: * Function that is similar to standard memcpy function
./app/benchmark/tmark/src/common/mrvl_memcpy_v4.S:3:	Marvell Optimized Memcopy Routine
./app/benchmark/tmark/src/common/memcpy-only-patch.S:9:*  This is a ASM optimized memcpy, memmove & bcopy function
./app/benchmark/tmark/src/common/mrvl_memcpy_v3-2.S:3:	Marvell Optimized Memcopy Routine
./app/benchmark/tmark/src/common/mrvl_memcpy_v3-2.S:167:	/*prime the pump, so to speak*/
./app/benchmark/tmark/src/common/mrvl_memcpy_v2.S:3:	Marvell Optimized Memcopy Routine
./app/benchmark/tmark/src/common/mrvl_memcpy_v2.S:167:	/*prime the pump, so to speak*/
./app/benchmark/tmark/src/common/load.S:31:@ 	r1: ldr times
./app/benchmark/tmark/src/common/memcpy_feroceon.S:14:   provides additional details about this warranty disclaimer. */
./app/benchmark/tmark/src/common/memcpy_feroceon.S:27:   but WITHOUT ANY WARRANTY; without even the implied warranty of
./app/benchmark/tmark/src/common/memcpy_feroceon.S:36:/* fastmem-arm9.S - memset/memcpy functions optimized for ARM926EJ-S
./app/benchmark/tmark/src/common/memcpy_feroceon.S:41:   This software is provided 'as-is', without any express or implied
./app/benchmark/tmark/src/common/memcpy_feroceon.S:50:      claim that you wrote the original software. If you use this software
./app/benchmark/tmark/src/common/memcpy_feroceon.S:275: * Function that is similar to standard memcpy function
./app/benchmark/tmark/src/common/mrvl_memcpy_v3.S:3:	Marvell Optimized Memcopy Routine
./app/benchmark/tmark/src/common/mrvl_memcpy_v3.S:159:	/*prime the pump, so to speak*/
./app/benchmark/tmark/src/common/mrvl_memcpy_v7.S:3:	Marvell Optimized Memcopy Routine
./app/benchmark/tmark/src/common/memcpyv5.S:1:# 1 "/home/zcyang/work/pmu_experiment/events/memcpyv5.S"
./app/benchmark/tmark/src/common/memcpyv5.S:4:# 1 "/home/zcyang/work/pmu_experiment/events/memcpyv5.S"
Binary file ./app/benchmark/tmark/src/common/obj/arm/memcpyv5.o matches
./app/benchmark/tmark/src/baremetal/mrvl_times.c:8://#include <time.h>
./app/benchmark/tmark/src/baremetal/mrvl_times.c:9://#include <sys/times.h>
./app/benchmark/tmark/src/baremetal/mrvl_times.c:124: * times
./app/benchmark/tmark/src/baremetal/mrvl_times.c:127:_mrvl_uint32 mrvl_times ()
./app/benchmark/tmark/src/baremetal/mrvl_times.c:129:	_mrvl_uint32 local_time=0;
./app/benchmark/tmark/src/baremetal/mrvl_times.c:147:	//__buffer->tms_utime = ut[uti] = MRVL_GET_COUNTER(MRVL_COUNTER_NO);
./app/benchmark/tmark/src/baremetal/mrvl_times.c:154:	local_time = ut[uti] = ccnt[uti];
./app/benchmark/tmark/src/baremetal/mrvl_times.c:181:        int_dummy = local_time / bkey;
./app/benchmark/tmark/src/baremetal/mrvl_times.c:182:	return local_time;
./app/benchmark/tmark/src/baremetal/mrvl_times.c:186:        int_dummy = local_time / bkey;
./app/benchmark/tmark/src/baremetal/mrvl_times.c:187:	return local_time / coreFreqMHz;
./app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.d:1:/home/feature_phone/crane/app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o: \
./app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.d:2: /home/feature_phone/crane/app/benchmark/tmark/src/baremetal/mrvl_times.c \
Binary file ./app/benchmark/tmark/src/baremetal/obj/arm/mrvl_times.o matches
./app/benchmark/tmark/tmark.h:92:unsigned int mrvl_times(void);
./app/benchmark/tmark/TMark_main.c:9:#include "timer_dec.h"
./app/benchmark/tmark/TMark_main.c:15:extern uint32_t timer_get_count(int id);
./app/benchmark/tmark/TMark_main.c:16:#define GetTimerCount timer_get_count
./app/benchmark/tmark/TMark_main.c:42:void dump_info(char *title, void *src_addr, void *dst_addr, int buf_size, int iters, int stride, unsigned long total_time)
./app/benchmark/tmark/TMark_main.c:46:      /* use cycles for total_time */
./app/benchmark/tmark/TMark_main.c:47:      lat = (float)total_time/iters/(buf_size/stride);
./app/benchmark/tmark/TMark_main.c:49:      /* use microseonds(us) for total_time */
./app/benchmark/tmark/TMark_main.c:50:      lat = (float)total_time*coreFreqMHz/iters/(buf_size/stride);
./app/benchmark/tmark/TMark_main.c:56:      /* use cycles for total_time */
./app/benchmark/tmark/TMark_main.c:59:         total_time,
./app/benchmark/tmark/TMark_main.c:61:         (float)buf_size*iters/total_time*(1000000000./1024./1024.));
./app/benchmark/tmark/TMark_main.c:65:      /* use microseonds(us) for total_time */
./app/benchmark/tmark/TMark_main.c:68:         total_time,
./app/benchmark/tmark/TMark_main.c:70:         (float)buf_size*iters/1024./1024./total_time*1000000.);
./app/benchmark/tmark/TMark_main.c:98:      throughput[0] = (float)buf_size*iters/total_time*(1000000000./1024./1024.);
./app/benchmark/tmark/TMark_main.c:100:      throughput[0] = (float)buf_size*iters/1024./1024./total_time*1000000.;
./app/benchmark/tmark/TMark_main.c:103:      t = (float)buf_size*iters/total_time*(1000000000./1024./1024.);
./app/benchmark/tmark/TMark_main.c:105:      t = (float)buf_size*iters/1024./1024./total_time*1000000.;
./app/benchmark/tmark/TMark_main.c:112:      t = (float)buf_size*iters/total_time*(1000000000./1024./1024.);
./app/benchmark/tmark/TMark_main.c:114:      t = (float)buf_size*iters/1024./1024./total_time*1000000.;
./app/benchmark/tmark/TMark_main.c:128:   TMARK_Printf("Optimistic latency number\r\n\r");
./app/benchmark/tmark/TMark_main.c:165:   unsigned int Begin_Time, End_Time;
./app/benchmark/tmark/TMark_main.c:362:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:367:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:368:      dump_info("Single load #32", src_ddr, 0, count*CACHELINE_SIZE, MAX(LOOP_TIME, 1000), CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:377:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:382:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:383:      dump_info("Single load DSB #32", src_ddr, 0, count*CACHELINE_SIZE, MAX(LOOP_TIME, 1000), CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:394:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:399:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:400:      dump_info("Single load Linked #32", src_ddr, 0, count*CACHELINE_SIZE, MAX(LOOP_TIME, 1000), CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:409:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:414:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:415:      dump_info("Single load #32", src_ddr, 0, count*CACHELINE_SIZE, MAX(LOOP_TIME, 1000), CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:422:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:427:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:428:      dump_info("Single load DSB #32", src_ddr, 0, count*CACHELINE_SIZE, MAX(LOOP_TIME, 1000), CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:440:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:445:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:446:      dump_info("Single load Linked #32", src_ddr, 0, count*CACHELINE_SIZE, MAX(LOOP_TIME, 1000), CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:455:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:460:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:461:      dump_info("Single load #32", src_ddr, 0, count*CACHELINE_SIZE, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:468:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:473:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:474:      dump_info("Single load DSB #32", src_ddr, 0, count*CACHELINE_SIZE, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:485:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:490:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:491:      dump_info("Single load Linked #32", src_ddr, 0, count*CACHELINE_SIZE, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:507:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:512:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:513:         dump_info("Single load #64", src_ddr_a[j], 0, count*CACHEBLOCK_SIZE, LOOP_TIME, CACHEBLOCK_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:532:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:537:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:538:         dump_info("Single load linked #64", src_ddr_a[j], 0, count*CACHEBLOCK_SIZE, LOOP_TIME, CACHEBLOCK_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:553:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:558:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:559:      dump_info("Single load #4", src_ddr, 0, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:572:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:576:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:577:      dump_info("Pipelined load #4", src_ddr, 0, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:590:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:594:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:595:      dump_info("Pipelined ldrd #8", src_ddr, 0, count*8, LOOP_TIME, 8, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:608:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:612:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:613:      dump_info("Pipelined Load #32", src_ddr, 0, count*CACHELINE_SIZE, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:620:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:624:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:625:      dump_info("Pipelined pld #32", src_ddr, 0, count*CACHELINE_SIZE, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:632:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:636:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:637:      dump_info("Pipelined ldr W/O BU #32", src_ddr, 0, count*CACHELINE_SIZE, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:651:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:655:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:656:      dump_info("Pipelined load #64", src_ddr, 0, count*CACHEBLOCK_SIZE, LOOP_TIME, CACHEBLOCK_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:669:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:673:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:674:      dump_info("Single Store #4", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:689:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:693:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:694:      dump_info("Coalesced Store (STR)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:705:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:709:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:710:      dump_info("Coalesced Store (STR)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:723:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:727:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:728:      dump_info("Coalesced Store (STRD)", 0, dst_ddr, count*8, LOOP_TIME, 8, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:741:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:745:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:746:      dump_info("Coalesced Store (STRD post incr)", 0, dst_ddr, count*8, LOOP_TIME, 8, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:759:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:763:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:764:      dump_info("Coalesced Store (STM 2 reg list)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:771:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:775:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:776:      dump_info("Coalesced Store (STM 4 reg list)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:783:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:787:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:788:      dump_info("Coalesced Store (STM 8 reg list)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:798:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:803:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:804:         dump_info("Memcpy (system default)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:808:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:813:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:814:         dump_info("Memcpy (feroceon)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:818:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:823:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:824:         dump_info("Memcpy (xscv5)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:828:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:833:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:834:         dump_info("Memcpy (glibc_opt)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:838:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:843:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:844:         dump_info("Memcpy (mrvl_fast)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:849:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:854:            End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:855:         dump_info("Memcpy (memcpy_32k)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:860:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:865:            End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:866:         dump_info("Memcpy (memcpy_v2)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:870:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:875:            End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:876:         dump_info("Memcpy (memcpy_v3)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:880:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:885:            End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:886:         dump_info("Memcpy (mrvl_memcpy_v3_2)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:890:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:895:            End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:896:         dump_info("Memcpy (mrvl_memcpy4)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:901:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:906:            End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:907:         dump_info("Memcpy (mrvl_memcpy_v7)", src_ddr, dst_ddr, j, LOOP_TIME, 1, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:921:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:930:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:931:      dump_info("ReadTest form RIM", src_ddr, 0, count, LOOP_TIME, CACHELINE_SIZE, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:941:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:945:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:946:      dump_info("Coalesced_Store Halfword (STRH)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:956:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:960:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:961:      dump_info("Coalesced_Store Byte #1 (STRB)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:971:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:975:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:976:      dump_info("Coalesced_Store Byte #2 (STRB)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:986:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:990:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:991:      dump_info("Coalesced_Store 1-8-7", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1001:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1005:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1006:      dump_info("Coalesced_Store 9-7", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1016:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1020:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1021:      dump_info("Coalesced_Store (STM 7 skip 1)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1031:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1035:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1036:      dump_info("Single_Store #4 (min1)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1046:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1050:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1051:      dump_info("Single_Store #4 (min1)", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1061:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1065:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1066:      dump_info("Combine_Store_4", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1076:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1080:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1081:      dump_info("Hop_Store_4_1", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1091:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1095:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1096:      dump_info("Hop_Store_4_2", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1106:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1110:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1111:      dump_info("Hop_Store_4_3", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1121:      Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1125:      End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1126:      dump_info("Hop_Store_4_4", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/TMark_main.c:1134:         Begin_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1138:         End_Time = mrvl_times();
./app/benchmark/tmark/TMark_main.c:1140:         dump_info("Delay_Store_4", 0, dst_ddr, count*4, LOOP_TIME, 4, End_Time-Begin_Time);
./app/benchmark/tmark/Rules.mk:18:#SET Timing way
./app/benchmark/tmark/Rules.mk:89:CFLAGS_$(d) += $(CFLAGS_OPTS) $(ARCH_CFLAG) -fno-builtin-printf -g -O3 --debug -fno-inline-functions -fno-jump-tables -fno-if-conversion -fno-if-conversion2 -fno-tree-loop-optimize -fno-tree-pre -fno-tree-fre -fsplit-ivs-in-unroller -falign-functions=8 -fpeel-loops -fivopts -funroll-loops -fsched2-use-traces -fno-rerun-cse-after-loop -D_TMARK_LINUX $(TIME_WAY)
./app/benchmark/tmark/mem_config.h:71:extern unsigned int dtime(void);
./app/benchmark/tmark/mem_config.h:72:#define mrvl_times dtime
./app/benchmark/tmark/mem_config.h:98:	TMARK_Printf("Title, Src Addr, Dst Addr, Buf Size(KB), Outer Loops, Stride(Byte), Total Time(cycles), Latency(cycle), Throughput(MB/giga cycle)\n\r");
./app/benchmark/tmark/mem_config.h:100:	TMARK_Printf("Title, Src Addr, Dst Addr, Buf Size(KB), Outer Loops, Stride(Byte), Total Time(us), Latency(cycle), Throughput(MB/s)\n\r");
Binary file ./app/benchmark/tmark/obj/arm/TMark_main.o matches
Binary file ./app/benchmark/tmark/obj/arm/version.o matches
Binary file ./app/benchmark/tmark/obj/arm/tmark.a matches
./app/benchmark/tmark/obj/arm/TMark_main.d:11: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/benchmark/tmark/obj/arm/TMark_main.d:42: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/benchmark/linpack/obj/arm/linpack.o matches
./app/benchmark/linpack/obj/arm/linpack.d:32: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/benchmark/linpack/obj/arm/linpack.d:35: /home/feature_phone/crane/driver/timer/clock.h
./app/benchmark/linpack/linpack.c:29:#include "timer_dec.h"
./app/benchmark/linpack/linpack.c:59:static REAL time[9][9];
./app/benchmark/linpack/linpack.c:66:print_time (row)
./app/benchmark/linpack/linpack.c:69:   DBG_PRINT(ON_OFF,"%11.4f%11.4f%11.4f%11.0f%11.4f%11.4f\n\r",   (double)time[0][row],
./app/benchmark/linpack/linpack.c:70:       (double)time[1][row], (double)time[2][row], (double)time[3][row], 
./app/benchmark/linpack/linpack.c:71:       (double)time[4][row], (double)time[5][row]);
./app/benchmark/linpack/linpack.c:114:     dgefa factors a double precision matrix by gaussian elimination.
./app/benchmark/linpack/linpack.c:117:     directly with a saving in time if  rcond  is not needed.
./app/benchmark/linpack/linpack.c:118:     (time for dgeco) = (1 + 9/n)*(time for dgefa) .
./app/benchmark/linpack/linpack.c:126:                the leading dimension of the array  a .
./app/benchmark/linpack/linpack.c:165:/*     gaussian elimination with partial pivoting   */
./app/benchmark/linpack/linpack.c:178:         /* zero pivot implies this column already 
./app/benchmark/linpack/linpack.c:196:            /* row elimination with column indexing */
./app/benchmark/linpack/linpack.c:237:                the leading dimension of the array  a .
./app/benchmark/linpack/linpack.c:261:        but it is often caused by improper arguments or improper
./app/benchmark/linpack/linpack.c:345:     constant times a vector plus a vector.
./app/benchmark/linpack/linpack.c:555:     estimate unit roundoff in quantities of size x.
./app/benchmark/linpack/linpack.c:569:     force optimizing compilers to generate code satisfying 
./app/benchmark/linpack/linpack.c:609:     multiply matrix m times vector x and add the result to vector y.
./app/benchmark/linpack/linpack.c:622:     ldm integer, leading dimension of array m
./app/benchmark/linpack/linpack.c:705:#include <sys/time.h>
./app/benchmark/linpack/linpack.c:715:t = (REAL) (ru.ru_utime.tv_sec+ru.ru_stime.tv_sec) + 
./app/benchmark/linpack/linpack.c:716:    ((REAL) (ru.ru_utime.tv_usec+ru.ru_stime.tv_usec))/1.0e6 ;
./app/benchmark/linpack/linpack.c:724:   count = timer_get_count(0);
./app/benchmark/linpack/linpack.c:737:   static int ipvt[200],n,i,ntimes,info,lda,ldaa,kflops;
./app/benchmark/linpack/linpack.c:738:   REAL total_time;
./app/benchmark/linpack/linpack.c:746:   total_time = second();
./app/benchmark/linpack/linpack.c:752:   time[0][0] = second() - t1;
./app/benchmark/linpack/linpack.c:755:   time[1][0] = second() - t1;
./app/benchmark/linpack/linpack.c:756:   total = time[0][0] + time[1][0];
./app/benchmark/linpack/linpack.c:785:   DBG_PRINT(ON_OFF,"    times are reported for matrices of order %5d\n\r",n);
./app/benchmark/linpack/linpack.c:789:   time[2][0] = total;
./app/benchmark/linpack/linpack.c:790:   time[3][0] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:791:   time[4][0] = 2.0e3/time[3][0];
./app/benchmark/linpack/linpack.c:792:   time[5][0] = total/cray;
./app/benchmark/linpack/linpack.c:794:   DBG_PRINT(ON_OFF," times for array with leading dimension of%5d\n\r",lda);
./app/benchmark/linpack/linpack.c:795:   print_time(0);
./app/benchmark/linpack/linpack.c:800:   time[0][1] = second() - t1;
./app/benchmark/linpack/linpack.c:803:   time[1][1] = second() - t1;
./app/benchmark/linpack/linpack.c:804:   total = time[0][1] + time[1][1];
./app/benchmark/linpack/linpack.c:805:   time[2][1] = total;
./app/benchmark/linpack/linpack.c:806:   time[3][1] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:807:   time[4][1] = 2.0e3/time[3][1];
./app/benchmark/linpack/linpack.c:808:   time[5][1] = total/cray;
./app/benchmark/linpack/linpack.c:813:   time[0][2] = second() - t1;
./app/benchmark/linpack/linpack.c:816:   time[1][2] = second() - t1;
./app/benchmark/linpack/linpack.c:817:   total = time[0][2] + time[1][2];
./app/benchmark/linpack/linpack.c:818:   time[2][2] = total;
./app/benchmark/linpack/linpack.c:819:   time[3][2] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:820:   time[4][2] = 2.0e3/time[3][2];
./app/benchmark/linpack/linpack.c:821:   time[5][2] = total/cray;
./app/benchmark/linpack/linpack.c:823:   ntimes = NTIMES;
./app/benchmark/linpack/linpack.c:827:   for (i = 0; i < ntimes; i++) {
./app/benchmark/linpack/linpack.c:834:   time[0][3] = (second() - t1 - tm2)/ntimes;
./app/benchmark/linpack/linpack.c:837:   for (i = 0; i < ntimes; i++) {
./app/benchmark/linpack/linpack.c:841:   time[1][3] = (second() - t1)/ntimes;
./app/benchmark/linpack/linpack.c:842:   total = time[0][3] + time[1][3];
./app/benchmark/linpack/linpack.c:843:   time[2][3] = total;
./app/benchmark/linpack/linpack.c:844:   time[3][3] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:845:   time[4][3] = 2.0e3/time[3][3];
./app/benchmark/linpack/linpack.c:846:   time[5][3] = total/cray;
./app/benchmark/linpack/linpack.c:848:   print_time(1);
./app/benchmark/linpack/linpack.c:849:   print_time(2);
./app/benchmark/linpack/linpack.c:850:   print_time(3);
./app/benchmark/linpack/linpack.c:855:   time[0][4] = second() - t1;
./app/benchmark/linpack/linpack.c:858:   time[1][4] = second() - t1;
./app/benchmark/linpack/linpack.c:859:   total = time[0][4] + time[1][4];
./app/benchmark/linpack/linpack.c:860:   time[2][4] = total;
./app/benchmark/linpack/linpack.c:861:   time[3][4] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:862:   time[4][4] = 2.0e3/time[3][4];
./app/benchmark/linpack/linpack.c:863:   time[5][4] = total/cray;
./app/benchmark/linpack/linpack.c:868:   time[0][5] = second() - t1;
./app/benchmark/linpack/linpack.c:871:   time[1][5] = second() - t1;
./app/benchmark/linpack/linpack.c:872:   total = time[0][5] + time[1][5];
./app/benchmark/linpack/linpack.c:873:   time[2][5] = total;
./app/benchmark/linpack/linpack.c:874:   time[3][5] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:875:   time[4][5] = 2.0e3/time[3][5];
./app/benchmark/linpack/linpack.c:876:   time[5][5] = total/cray;
./app/benchmark/linpack/linpack.c:881:   time[0][6] = second() - t1;
./app/benchmark/linpack/linpack.c:884:   time[1][6] = second() - t1;
./app/benchmark/linpack/linpack.c:885:   total = time[0][6] + time[1][6];
./app/benchmark/linpack/linpack.c:886:   time[2][6] = total;
./app/benchmark/linpack/linpack.c:887:   time[3][6] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:888:   time[4][6] = 2.0e3/time[3][6];
./app/benchmark/linpack/linpack.c:889:   time[5][6] = total/cray;
./app/benchmark/linpack/linpack.c:891:   ntimes = NTIMES;
./app/benchmark/linpack/linpack.c:894:   for (i = 0; i < ntimes; i++) {
./app/benchmark/linpack/linpack.c:900:   time[0][7] = (second() - t1 - tm2)/ntimes;
./app/benchmark/linpack/linpack.c:902:   for (i = 0; i < ntimes; i++) {
./app/benchmark/linpack/linpack.c:905:   time[1][7] = (second() - t1)/ntimes;
./app/benchmark/linpack/linpack.c:906:   total = time[0][7] + time[1][7];
./app/benchmark/linpack/linpack.c:907:   time[2][7] = total;
./app/benchmark/linpack/linpack.c:908:   time[3][7] = ops/(1.0e3*total);
./app/benchmark/linpack/linpack.c:909:   time[4][7] = 2.0e3/time[3][7];
./app/benchmark/linpack/linpack.c:910:   time[5][7] = total/cray;
./app/benchmark/linpack/linpack.c:912:   /* the following code sequence implements the semantics of
./app/benchmark/linpack/linpack.c:913:      the Fortran intrinsics "nint(min(time[3][3],time[3][7]))"   */
./app/benchmark/linpack/linpack.c:915:   kf = (time[3][3] < time[3][7]) ? time[3][3] : time[3][7];
./app/benchmark/linpack/linpack.c:924:   DBG_PRINT(ON_OFF," times for array with leading dimension of%4d\n\r",ldaa);
./app/benchmark/linpack/linpack.c:925:   total_time = second() - total_time;
./app/benchmark/linpack/linpack.c:926:   print_time(4);
./app/benchmark/linpack/linpack.c:927:   print_time(5);
./app/benchmark/linpack/linpack.c:928:   print_time(6);
./app/benchmark/linpack/linpack.c:929:   print_time(7);
./app/benchmark/linpack/linpack.c:932:                    " Total time: %.3fsec \n\r",kflops,((double)kflops/1024),
./app/benchmark/linpack/linpack.c:933:                    NTIMES, total_time);
Binary file ./app/pmu/obj/arm/pmu_ao.o matches
./app/pmu/pmu_ao.c:21:*  +Stress test: PP_change time, LPM entry/exit, reset
./app/pmu/pmu_ao.c:23:*  +Limit test: Vmin(both active and D2), Fmax
./app/pmu/pmu_ao.c:51:    //other data                             /* just start with simple test, will be evolved gradually*/
./app/main/main.c:40:static QEvent const *l_timerQSto[16];      /* Event queue storage for Timer */
./app/main/main.c:64:    Timer_ctor();
./app/main/main.c:130:    QACTIVE_START(AO_Timer,                                                              
./app/main/main.c:132:                  l_timerQSto, Q_DIM(l_timerQSto),             /* evt queue */ 
./app/main/main.c:180:    bbu_printf(BBU_PROMPT" %d ms", QS_onGetTime()/3250);
./app/main/bbu.h:20:#define SCREEN_TEST_DEADLINE 15  /* Each command execution time limit in screen test, in seconds */
./app/main/bbu.h:66:    COM_RX_REQUEST_SIG,                     /*Rx FIFO half full or time out send this event*/
./app/main/bbu.h:96:    /* Timer AO Signals */
./app/main/bbu.h:110:    BBU_TTDM_SIG,                   /* temperature-time dynamic measurement */
./app/main/bbu.h:133:    I2C_TIMEOUT_SIG,                         /*   I2C time out signal       */
./app/main/bbu.h:206:    SCREEN_TIMEOUT_SIG,            /* signal for command timeout event of screen test */
./app/main/bbu.h:291:    BBU_CPLD_SIG,                               /* load CP image & release CP */
./app/main/bbu.h:384:    USB_IUSB_STORAGE, /*Simple USB test*/
./app/main/bbu.h:436:    STRESS_CPBP_SIG,                    /* calc and print the biggest prime */
./app/main/bbu.h:808:typedef void (*timer_irq_func)(void*);
./app/main/bbu.h:809:typedef struct TimerIrqEvtTag{
./app/main/bbu.h:811:    timer_irq_func func_p;
./app/main/bbu.h:813:}TimerIrqEvt;
./app/main/bbu.h:846:void Timer_ctor(void);
./app/main/bbu.h:898:extern QActive * const AO_Timer;
Binary file ./app/main/obj/arm/main.o matches
./app/test/ate/ate_comp.h:19:	QTimeEvt TestTimeEvt;					/* time event for screen test */
./app/test/ate/ate_test.c:5:#include "timer_dec.h"
./app/test/ate/ate_test.c:26:	 * Command does not receive response before timeout_deadline arrived
./app/test/ate/ate_test.c:29:	uint32_t timeout_deadline;  /* in seconds */
./app/test/ate/ate_test.c:50:	 * cmd_index is an ID used to discrimiate which command 
./app/test/ate/ate_test.c:63:	 * Command does not receive response before timeout_deadline arrived
./app/test/ate/ate_test.c:66:	uint32_t timeout_deadline;
./app/test/ate/ate_test.c:68:	/* Used to save time consumed by each command */
./app/test/ate/ate_test.c:69:	uint32_t time_used_ms;
./app/test/ate/ate_test.c:72:	 * Commands in same group_id will be post at the same time,
./app/test/ate/ate_test.c:85:	 * 0x04 -- command execution time out 
./app/test/ate/ate_test.c:98:	 * group_max_timeout is the maximum timeout value of all commands of
./app/test/ate/ate_test.c:101:	uint32_t group_max_timeout;
./app/test/ate/ate_test.c:122:int ate_timer;
./app/test/ate/ate_test.c:128:#define ATE_CMD_CELL(_name, _timeout, _group_id, _stat_gpio, _res_gpio)      \
./app/test/ate/ate_test.c:131:	.timeout_deadline = _timeout,                                        \
./app/test/ate/ate_test.c:136:#define ATE_CMD_CELL_NGPIO(name, timeout, group_id)	                     \
./app/test/ate/ate_test.c:137:	ATE_CMD_CELL(name, timeout, group_id, GPIO_INVALID, GPIO_INVALID)
./app/test/ate/ate_test.c:196:		cmd_entry->time_used_ms = 0xffffffff;
./app/test/ate/ate_test.c:283:                              uint32_t timeout)
./app/test/ate/ate_test.c:296:			cmd_entry->time_used_ms = 0xffffffff;
./app/test/ate/ate_test.c:307:			cmd_entry->timeout_deadline = timeout;
./app/test/ate/ate_test.c:310:			if (cmd_entry->timeout_deadline > sub_gp->group_max_timeout)
./app/test/ate/ate_test.c:311:				sub_gp->group_max_timeout = cmd_entry->timeout_deadline;
./app/test/ate/ate_test.c:323:		sub_gp_new->group_max_timeout = timeout;
./app/test/ate/ate_test.c:336:		cmd_entry->time_used_ms = 0xffffffff;
./app/test/ate/ate_test.c:347:		cmd_entry->timeout_deadline = timeout;
./app/test/ate/ate_test.c:367:		                     entry->timeout_deadline);
./app/test/ate/ate_test.c:398:		cmd_entry->time_used_ms = bbu_get_msec();
./app/test/ate/ate_test.c:402:	/* First screen command is sleep test, just need 1s timeout */  
./app/test/ate/ate_test.c:403:	QTimeEvt_postIn(&(l_ate_comp.TestTimeEvt), AO_TEST,
./app/test/ate/ate_test.c:404:	                BSP_TICKS_PER_SEC * sub_gp->group_max_timeout);
./app/test/ate/ate_test.c:433:				cmd_entry->time_used_ms = 
./app/test/ate/ate_test.c:434:					bbu_get_msec() - cmd_entry->time_used_ms;
./app/test/ate/ate_test.c:436:				cmd_entry->time_used_ms = 0xffffffff;
./app/test/ate/ate_test.c:489:	ate_timer = start_timer(5, ate_invert_live_status_pin, 0);
./app/test/ate/ate_test.c:490:	if(ate_timer < 0) {
./app/test/ate/ate_test.c:491:	    bbu_printf("ERROR: No free timer for ate...\r\n");
./app/test/ate/ate_test.c:599:		QTimeEvt_rearm(&(l_ate_comp.TestTimeEvt),
./app/test/ate/ate_test.c:600:	                       BSP_TICKS_PER_SEC * sub_gp->group_max_timeout);
./app/test/ate/ate_test.c:603:	/* disarm ate test time event when over */
./app/test/ate/ate_test.c:604:	QTimeEvt_disarm(&(l_ate_comp.TestTimeEvt));
./app/test/ate/ate_test.c:629: * ate_timeout_handle
./app/test/ate/ate_test.c:632: * If not receiving ACK before timeout happen, post a timeout event to myself,
./app/test/ate/ate_test.c:636:void ate_timeout_handle(void)
./app/test/ate/ate_test.c:645:				 * For "lpmset 3 1", after 1s timeout, 
./app/test/ate/ate_test.c:764:	            "ATE Test", "Result", "Ind Time(ms)", "Timeout(seconds)");
./app/test/ate/ate_test.c:778:			if (cmd_entry->time_used_ms == 0xffffffff) {
./app/test/ate/ate_test.c:782:				    cmd_entry->timeout_deadline);
./app/test/ate/ate_test.c:786:				    cmd_entry->cmd, result, cmd_entry->time_used_ms,
./app/test/ate/ate_test.c:787:				    cmd_entry->timeout_deadline);
./app/test/ate/ate_comp.c:13:#include "timer_dec.h"
./app/test/ate/ate_comp.c:36:	QTimeEvt_ctor(&me->TestTimeEvt, ATE_TEST_TIMEOUT_SIG);
./app/test/ate/ate_comp.c:109:			ate_timeout_handle();
./app/test/ate/ate_test.h:57:void ate_timeout_handle(void);
./app/test/ate/ate_test.h:68:uint32_t ate_add_cmd_to_group(uint32_t seq, uint32_t index, char *cmd, uint32_t timeout);
./app/test/screen/screen_comp.c:13:#include "timer_dec.h"
./app/test/screen/screen_comp.c:36:	QTimeEvt_ctor(&me->ScreenTestTimeEvt, SCREEN_TIMEOUT_SIG);
./app/test/screen/screen_comp.c:84:			screen_timeout_handle();
./app/test/screen/screen_test.c:17:#include "timer_dec.h"
./app/test/screen/screen_test.c:32:	 * Command does not receive response before timeout_deadline arrived
./app/test/screen/screen_test.c:35:	uint32_t timeout_deadline;
./app/test/screen/screen_test.c:50:	 * cmd_index is an ID used to discrimiate which command 
./app/test/screen/screen_test.c:59:	 * Command does not receive response before timeout_deadline arrived
./app/test/screen/screen_test.c:62:	uint32_t timeout_deadline;
./app/test/screen/screen_test.c:64:	/* Used to save time consumed by each command */
./app/test/screen/screen_test.c:65:	uint32_t time_used_ms;
./app/test/screen/screen_test.c:68:	 * Commands in same group_id will be post at the same time,
./app/test/screen/screen_test.c:81:	 * 0x04 -- command execution time out 
./app/test/screen/screen_test.c:94:	 * group_max_timeout is the maximum timeout value of all commands of
./app/test/screen/screen_test.c:97:	uint32_t group_max_timeout;
./app/test/screen/screen_test.c:127:#define SLT_CMD_CELL(_name, _timeout, _group_id)        \
./app/test/screen/screen_test.c:130:	.timeout_deadline = _timeout,                   \
./app/test/screen/screen_test.c:380:		                     entry->timeout_deadline);
./app/test/screen/screen_test.c:411:uint32_t slt_add_cmd_to_group(uint32_t seq, uint32_t index, char *cmd, uint32_t timeout)
./app/test/screen/screen_test.c:424:			cmd_entry->time_used_ms = 0xffffffff;
./app/test/screen/screen_test.c:427:			cmd_entry->timeout_deadline = timeout;
./app/test/screen/screen_test.c:430:			if (cmd_entry->timeout_deadline > sub_gp->group_max_timeout)
./app/test/screen/screen_test.c:431:				sub_gp->group_max_timeout = cmd_entry->timeout_deadline;
./app/test/screen/screen_test.c:443:		sub_gp_new->group_max_timeout = timeout;
./app/test/screen/screen_test.c:456:		cmd_entry->time_used_ms = 0xffffffff;
./app/test/screen/screen_test.c:459:		cmd_entry->timeout_deadline = timeout;
./app/test/screen/screen_test.c:481:		cmd_entry->time_used_ms = bbu_get_msec();
./app/test/screen/screen_test.c:485:	/* First screen command is sleep test, just need 1s timeout */  
./app/test/screen/screen_test.c:486:	QTimeEvt_postIn(&(l_screen_comp.ScreenTestTimeEvt), AO_TEST,
./app/test/screen/screen_test.c:487:	                BSP_TICKS_PER_SEC * sub_gp->group_max_timeout);
./app/test/screen/screen_test.c:516:				cmd_entry->time_used_ms = bbu_get_msec() - 
./app/test/screen/screen_test.c:517:					                  cmd_entry->time_used_ms;
./app/test/screen/screen_test.c:532:			cmd_entry->time_used_ms = 0xffffffff;
./app/test/screen/screen_test.c:553:	 * every time screen test start, need to clear previous test 
./app/test/screen/screen_test.c:612:			/* disarm screen test time event when over */
./app/test/screen/screen_test.c:613:			QTimeEvt_disarm(&(l_screen_comp.ScreenTestTimeEvt));  
./app/test/screen/screen_test.c:619:		QTimeEvt_rearm(&(l_screen_comp.ScreenTestTimeEvt),
./app/test/screen/screen_test.c:620:	                       BSP_TICKS_PER_SEC * sub_gp->group_max_timeout);
./app/test/screen/screen_test.c:623:	QTimeEvt_disarm(&(l_screen_comp.ScreenTestTimeEvt));
./app/test/screen/screen_test.c:628:		/* disarm screen test time event when over */
./app/test/screen/screen_test.c:629:		QTimeEvt_disarm(&(l_screen_comp.ScreenTestTimeEvt));
./app/test/screen/screen_test.c:642: * screen_timeout_handle
./app/test/screen/screen_test.c:645: * If not receiving ACK before timeout happen, post a timeout event to myself,
./app/test/screen/screen_test.c:649:void screen_timeout_handle(void)
./app/test/screen/screen_test.c:661:					 * For "lpmset 3 1", after 1s timeout, 
./app/test/screen/screen_test.c:685:	uint32_t total_timeout = 0;
./app/test/screen/screen_test.c:699:				total_timeout++;
./app/test/screen/screen_test.c:718:	bbu_printf("\r\n\t4) Timeout command number: %d\r\n",total_timeout);
./app/test/screen/screen_test.c:754:	if (total_timeout) {
./app/test/screen/screen_test.c:769:	if (total_failed == 0 && total_timeout == 0) {
./app/test/screen/screen_test.c:781:	} else if (total_failed || total_timeout) {
./app/test/screen/screen_test.c:826:	           "Result", "Ind Time(ms)", "Timeout(seconds)");
./app/test/screen/screen_test.c:837:				strcpy((char *)result, "Timeout");
./app/test/screen/screen_test.c:844:			if (cmd_entry->time_used_ms == 0xffffffff) {
./app/test/screen/screen_test.c:847:				           result, "NA", cmd_entry->timeout_deadline);
./app/test/screen/screen_test.c:851:				           result, cmd_entry->time_used_ms,
./app/test/screen/screen_test.c:852:				           cmd_entry->timeout_deadline);
./app/test/screen/screen_test.h:10:void screen_timeout_handle(void);
./app/test/screen/screen_test.h:14:uint32_t slt_add_cmd_to_group(uint32_t seq, uint32_t index, char *cmd, uint32_t timeout);
./app/test/screen/screen_comp.h:19:	QTimeEvt ScreenTestTimeEvt;					/* time event for screen test */
./app/test/obj/arm/test_ao.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/test/obj/arm/test_ao.d:36: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./app/test/obj/arm/test_ao.o matches
Binary file ./app/test/common/obj/arm/bbu_test.o matches
./app/test/common/obj/arm/bbu_test.d:32: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/test/common/obj/arm/bbu_test.d:35: /home/feature_phone/crane/driver/timer/clock.h \
./app/test/common/bbu_test.h:7://#define BBU_TEST_TIMEOUT    (1<<3)    /* Do not receive ack from test owner in time */
./app/test/common/bbu_test.h:14:#define BBU_TEST_TIMEOUT    4    /* Do not receive ack from test owner in time */
./app/test/common/bbu_test.c:4:#include "timer_dec.h"
./app/test/test_ao.c:13:#include "timer_dec.h"
./app/test/test_ao.c:42:	QTimeEvt TestTimeEvt;
./app/test/test_ao.c:91:	QTimeEvt_ctor(&me->TestTimeEvt, AO_TEST_TIMEOUT_SIG);
./app/test/test_ao.c:160:			 * Disarm screen test time event first to ensure next arm command correct 
./app/test/test_ao.c:162:			QTimeEvt_disarm(&(l_test.TestTimeEvt));
./app/test/test_ao.c:163:			QTimeEvt_postIn(&(l_test.TestTimeEvt), AO_TEST, BSP_TICKS_PER_SEC * 5);
./app/test/test_ao.c:169:			QTimeEvt_disarm(&(l_test.TestTimeEvt));
./app/test/test_ao.c:330:	uint32_t timeout = 0;
./app/test/test_ao.c:332:	char *ptr_timeout = NULL;
./app/test/test_ao.c:335:	ptr_timeout = strstr((char *)cmd, ",");
./app/test/test_ao.c:336:	if (ptr_timeout) {
./app/test/test_ao.c:337:		*ptr_timeout = '\0';					
./app/test/test_ao.c:339:		ptr_seq = strstr((char *)(ptr_timeout+1), ",");
./app/test/test_ao.c:349:	if (ptr_timeout) {
./app/test/test_ao.c:350:		char *ptr = ptr_timeout;
./app/test/test_ao.c:378:			timeout = conv_dec(ptr_timeout + 1);
./app/test/test_ao.c:383:		timeout = 10;
./app/test/test_ao.c:422:	if (load_command(seq, line, (char *)cmd, timeout))
./app/Rules.mk:2:SUBDIRS := cli console main timer i2c common memory stress benchmark ipc pmu test usb_test dma
./app/common/dma_nano_test.c:62:    	//bbu_printf("DMA transfer %d times\n\r",irq_count);
./app/common/lcd_test.c:74:	bbu_printf("INFO: before lcd_draw_images\r\n ");
./app/common/lcd_test.c:75://	lcd_draw_images(SRC_BUFFER_1_ADDR,NULL,NULL,LCD_FORMAT_RGB1555,
./app/common/lcd_test.c:77://	lcd_draw_images(SRC_BUFFER_2_ADDR,NULL,NULL,LCD_FORMAT_RGB1555,
./app/common/lcd_test.c:79://	lcd_draw_images(SRC_BUFFER_1_ADDR,&addr_p2,&addr_p3,LCD_FORMAT_YUV422_PLANAR,
./app/common/lcd_test.c:81://	lcd_draw_images(SRC_BUFFER_2_ADDR,&addr_p2_t,&addr_p3_t,LCD_FORMAT_YUV422_PLANAR,
./app/common/lcd_test.c:83://	lcd_draw_images(SRC_BUFFER_1_ADDR,&addr_p2,NULL,LCD_FORMAT_YUV420_SEMI,
./app/common/lcd_test.c:85://	lcd_draw_images(SRC_BUFFER_2_ADDR,&addr_p2_t,NULL,LCD_FORMAT_YUV420_SEMI,
./app/common/lcd_test.c:87://	lcd_draw_images(SRC_BUFFER_1_ADDR,NULL,NULL,LCD_FORMAT_YUV422_PACKED,
./app/common/lcd_test.c:89://	lcd_draw_images(SRC_BUFFER_2_ADDR,NULL,NULL,LCD_FORMAT_YUV422_PACKED,
./app/common/lcd_test.c:91:	lcd_draw_images(SRC_BUFFER_1_ADDR,&addr_p2,&addr_p3,test_format,
./app/common/lcd_test.c:93:	lcd_draw_images(SRC_BUFFER_2_ADDR,&addr_p2_t,&addr_p3_t,test_format,
./app/common/lcd_test.c:95:	bbu_printf("INFO: after lcd_draw_images\r\n ");
./app/common/bbu_help.h:51:void bbu_timer_help(void);
./app/common/ddr_sweep.c:5:#include "timer_dec.h"
./app/common/bbu_help.c:35:    bbu_printf("             -- Can support more than one <bit> one time\n\r");
./app/common/bbu_help.c:45:    bbu_printf("             -- Can support more than one <bit> one time\n\r");
./app/common/bbu_help.c:55:    bbu_printf("             -- Can support more than one <bit> one time\n\r");
./app/common/bbu_help.c:141:   bbu_printf("  <byte_count>  -- Number of bytes(hexadecimal) to be tested.\n\r");
./app/common/bbu_help.c:165:   bbu_printf(" wake_src: 5: timer, 10: watchdog, 11: PMIC, 16: IPC, 17: RIPC, default is 16\n\r");
./app/common/bbu_help.c:166:   bbu_printf(" value: when wake_src is 5 & 10, it's time in msec\n\r");
./app/common/bbu_help.c:234:    bbu_printf("     fpi  -- determines an approximation to a system's approximate value of PI\n\r");
./app/common/bbu_help.c:235:    bbu_printf("     pi   -- attempts to determine a rational approximation A/B close to a\n\r");
./app/common/bbu_help.c:236:    bbu_printf("             system's approximate value of PI used in trigonometric argument reduction, and\n\r");
./app/common/bbu_help.c:237:    bbu_printf("             tests whether the system's approximation is used consistently\n\r");
./app/common/bbu_help.c:255:   bbu_printf("    -forever         --Test one function repeatedly (implies `-level 2').\n\r");
./app/common/bbu_help.c:261:   bbu_printf("    -precision80     --Only test maximum rounding precision.\n\r");
./app/common/bbu_help.c:303:   bbu_printf("   -cycle         --  Use cycle to mearsure throughput and time, otherwise use second\n\r");
./app/common/bbu_help.c:314:   bbu_printf("   -all           --  Equal to use -l1, -l2, -bpu, and -l2p simultaneously\n\r");
./app/common/bbu_help.c:341:   bbu_printf("                  arg1->onkey idx[0,1], arg2->press time[1~16]\n\r");
./app/common/bbu_help.c:400:   bbu_printf("\n\r ttdm - Temperature-Time dynamic measurement\n\r");
./app/common/bbu_help.c:402:   bbu_printf("    <secs>   - interval that temperature and time measured periodically\n\r"
./app/common/bbu_help.c:406:   bbu_printf(" Note: You can use 'ttdm stop' to stop and print the records anytime\n\r");
./app/common/bbu_help.c:475:   bbu_printf("  <min> The time the stress test will last, default value is 3 minutes\n\r");
./app/common/bbu_help.c:521:   bbu_printf(" Note: Can also set the print level to an immediate directly\n\r");
./app/common/bbu_help.c:635:   bbu_printf("      arg3  -  period time in ns\n\r");
./app/common/bbu_help.c:649:   bbu_printf(" Usage: mtsp <address> <size> <tests> [<test times>]\n\r");
./app/common/bbu_help.c:656:   bbu_printf("  test times = number for repeating tests. default: 1\n\r");
./app/common/bbu_help.c:754:void bbu_timer_help(void){
./app/common/bbu_help.c:755:   bbu_printf("\n\rtimer - Command to test timers.");
./app/common/bbu_help.c:756:   bbu_printf("\r\nUsage: timer <command> <index> <unit> <run mode> <interval>\r\n");
./app/common/bbu_help.c:758:              "      start  -- start timer\n\r");
./app/common/bbu_help.c:759:   bbu_printf("      stop   -- stop timer\n\r");
./app/common/bbu_help.c:760:   bbu_printf("    <index>: timer index\n\r");
./app/common/bbu_help.c:761:   bbu_printf("    <unit>: timer unit\n\r");
./app/common/bbu_help.c:765:   bbu_printf("    <interval>: timer interval\n\r");
./app/common/bbu_help.c:766:   bbu_printf("Note: timer start all <run mode > <interval> can start all timers.\r\n"
./app/common/bbu_help.c:767:              "      timer stop all can stop all timers.\r\n");
./app/common/common_tests.c:5:#include "timer_dec.h"
./app/common/bbu_setv.c:617:    int onkey_idx, press_time;
./app/common/bbu_setv.c:627:                press_time = conv_dec((char*)argv[3]);
./app/common/bbu_setv.c:634:                if(press_time < 1 || press_time > 16)
./app/common/bbu_setv.c:636:                    bbu_printf("choose onkey press time 1~16\n\r");
./app/common/bbu_setv.c:640:                ustica_onkey_enable(onkey_idx, press_time);
./app/common/bbu_curm.c:4:#include "timer_dec.h"
./app/common/obj/arm/bbu_setv.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/bbu_setv.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/common_ao.d:38: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/common_ao.d:41: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/common_ao.d:47: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/common/obj/arm/bbu_help.o matches
Binary file ./app/common/obj/arm/ddr_sweep.o matches
./app/common/obj/arm/utils.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/utils.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/utils.d:42: /home/feature_phone/crane/driver/common/tim.h \
Binary file ./app/common/obj/arm/lcd_test.o matches
Binary file ./app/common/obj/arm/ddr_sweep_driver.o matches
Binary file ./app/common/obj/arm/utils.o matches
Binary file ./app/common/obj/arm/common_ao.o matches
./app/common/obj/arm/ddr_sweep.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/ddr_sweep.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/mfp_tests.d:43: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/mfp_tests.d:46: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/common/obj/arm/mcu_generate_pattern.o matches
Binary file ./app/common/obj/arm/bbu_setv.o matches
Binary file ./app/common/obj/arm/bbu_curm.o matches
./app/common/obj/arm/bbu_curm.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/bbu_curm.d:36: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/common/obj/arm/cpu_pat.o matches
./app/common/obj/arm/cpu_pat.d:6: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/cpu_pat.d:37: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./app/common/obj/arm/offline_test.o matches
Binary file ./app/common/obj/arm/dtc.o matches
./app/common/obj/arm/common_tests.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/common_tests.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/mcu_generate_pattern.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/mcu_generate_pattern.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/offline_test.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/offline_test.d:36: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/common/obj/arm/mfp_tests.o matches
./app/common/obj/arm/ddr_sweep_driver.d:33: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/common/obj/arm/ddr_sweep_driver.d:36: /home/feature_phone/crane/driver/timer/clock.h \
./app/common/obj/arm/ddr_sweep_driver.d:42: /home/feature_phone/crane/driver/timer/clock.h
Binary file ./app/common/obj/arm/md5.o matches
Binary file ./app/common/obj/arm/common_tests.o matches
Binary file ./app/common/obj/arm/ao_info.o matches
./app/common/mcu_generate_pattern.c:19:#include "timer_dec.h"
./app/common/md5.h:3: ** md5.h -- header file for implementation of MD5                    **
./app/common/md5.h:32: ** is" without express or implied warranty of any kind.              **
./app/common/md5.c:28: ** is" without express or implied warranty of any kind.              **
./app/common/utils.c:3:#include "timer_dec.h"
./app/common/utils.c:9:#include "tim.h"
./app/common/utils.c:94:uint32_t XpStrToDecimal(char * pStr)
./app/common/utils.c:105:            DEBUGMSG(DBG_LEVEL,("Xp error: invalided decimal value. \r\n"));
./app/common/utils.c:120:        return XpStrToDecimal(pStr);
./app/common/utils.c:195:	TIM tim;
./app/common/utils.c:196:    int imageNum, imageSize, i;
./app/common/utils.c:198:    SetTIMPointers((uint8_t *)0xd1000000, &tim);
./app/common/utils.c:199:    imageNum = get_image_number(&tim);
./app/common/utils.c:202:    for(i = 0; i < imageNum; i++){
./app/common/utils.c:203:       pImage = ReturnPImgPtr(&tim, i);
./app/common/utils.c:205:          imageSize = pImage->ImageSize;
./app/common/utils.c:206:          if(imageSize == 0){
./app/common/utils.c:209:          file_buffer = bbu_malloc(imageSize);
./app/common/utils.c:215:          memcpy(file_buffer, (void *)pImage->LoadAddr, imageSize);
./app/common/utils.c:216:          mfile_init("slt_cmd.txt", (char *)file_buffer, imageSize);
./app/common/utils.c:220:          imageSize = pImage->ImageSize;
./app/common/utils.c:221:          if(imageSize == 0){
./app/common/utils.c:224:          file_buffer = bbu_malloc(imageSize);
./app/common/utils.c:230:          memcpy(file_buffer, (void *)pImage->LoadAddr, imageSize);
./app/common/utils.c:231:          mfile_init("ate_cmd.txt", (char *)file_buffer, imageSize);
./app/common/dtc.c:28:    int time_out = 1000;
./app/common/dtc.c:91:    while(time_out --){
./app/common/dtc.c:103:    if(time_out == 0)
./app/common/common_ao.c:24:#include "timer_dec.h"
./app/common/common_ao.c:80:	//simple_data_test(0);
./app/common/common_ao.c:297:         //print_current_time();
./app/common/common_ao.c:523:            for (uint32_t i = 0; i<loops; i++) { //at least test two times to make sure it pass stable
./app/common/common_ao.c:546:            bbu_printf("The commt test passed %d times, failed %d times.\r\n", count, (loops-count));
./app/common/common_ao.c:563:	    bbu_printf("Use CP timer(D0210000) as delay tick\r\n");
./app/common/common_ao.c:565:	    bbu_printf("Use AP timeras delay tick\r\n");
./app/common/cpu_pat.c:4:#include "timer_dec.h"
./app/common/cpu_pat.c:155:   bbu_printf("cpu test %d use time(ms): %d\n\r", idx, end - start);
./app/common/ddr_sweep_driver.c:6:// Run at maximum DDR frequency to ensure correct values
./app/common/ddr_sweep_driver.c:12://d)	Use a simple test writing/reading 1Mb size so we get a burst of 0xf s and 0x0 s and 0xa s and 0x5s (even/odd mode)
./app/common/ddr_sweep_driver.c:13://		Write and read from both CS0 and CS1. (if you run a bigger more stressful test, no issue, just takes time)
./app/common/ddr_sweep_driver.c:15://f)	Use a simple test writing/reading 1Mb size so we get a burst of 0xf s and 0x0 s and 0xa s and 0x5s (even/odd mode)
./app/common/ddr_sweep_driver.c:16://		Write and read from both CS0 and CS1. (if you run a bigger more stressful test, no issue, just takes time)
./app/common/ddr_sweep_driver.c:24://d)	Use a simple test to read 1Mb size so we get a burst of 0xf s and 0x0 s and 0xa s and 0x5s (even/odd mode)
./app/common/ddr_sweep_driver.c:25://		Read from both CS0 and CS1. (if you run a bigger more stressful test, no issue, just takes time)
./app/common/ddr_sweep_driver.c:27://f)	Use a simple test to read 1Mb size so we get a burst of 0xf s and 0x0 s and 0xa s and 0x5s (even/odd mode)
./app/common/ddr_sweep_driver.c:28://		Read from both CS0 and CS1. (if you run a bigger more stressful test, no issue, just takes time)
./app/common/ddr_sweep_driver.c:40:#include "timer_dec.h"
./app/common/ddr_sweep_driver.c:165:	//check after a 100 cycles wait time to see if offset 0x0420 bit 2 is set (phy_cal_done) and phy_cal_err (bit 3) is not set 
./app/common/ddr_sweep_driver.c:688:int dq_dqs_sweep_test(uint32_t phsel_test_bytes,uint32_t phsel_test_bytes1, int dqs_map, int is_simu)
./app/common/ddr_sweep_driver.c:716:		if(is_simu&&(dqs0 == dqs1)&&(dqs1==dqs2)&&(dqs2==dqs3))
./app/common/ddr_sweep_driver.c:718:		else if(!is_simu)
./app/common/ddr_sweep_driver.c:794:		if(is_simu&&(dqs0 == dqs1)&&(dqs1==dqs2)&&(dqs2==dqs3))
./app/common/ddr_sweep_driver.c:796:		else if(!is_simu)
./app/common/offline_test.c:8:#include "timer_dec.h"
./app/common/offline_test.c:100:	buf_fill_by_img(scl_src_buf);
./app/common/offline_test.c:152:		buf_in->plane[0].sizeimage = pitch * buf_in->height;
./app/common/offline_test.c:163:		buf_in->plane[0].sizeimage = pitch * buf_in->height;
./app/common/offline_test.c:168:		buf_in->plane[1].sizeimage = pitch * buf_in->height / 2;
./app/common/offline_test.c:172:		buf_in->plane[2].sizeimage = pitch * buf_in->height / 2;
./app/common/offline_test.c:185:		buf_in->plane[0].sizeimage = pitch * buf_in->height;
./app/common/offline_test.c:190:		buf_in->plane[1].sizeimage = pitch * buf_in->height / 2;
./app/common/offline_test.c:305:	buf_fill_by_img(ire_src_buf);
./app/common/ao_info.c:13:      {"timer",       AO_Timer},
./app/usb_test/usb_test_app.c:10:    QTimeEvt USBTimeOutEvt;
./app/usb_test/usb_test_app.c:39:    QTimeEvt_ctor(&me->USBTimeOutEvt, USB_TIMEOUT_SIG);
./app/usb_test/usb_test_app.c:99:    QTimeEvt_disarm(&(I_USBApp.USBTimeOutEvt));
./app/usb_test/usb_test_app.c:122:    bbu_printf("close cdc timer\r\n");
./app/usb_test/usb_test_app.c:123:    QTimeEvt_disarm(&(I_USBApp.USBTimeOutEvt));
./app/usb_test/usb_test_app.c:333:                    QTimeEvt_disarm(&(I_USBApp.USBTimeOutEvt));
./app/usb_test/usb_test_app.c:334:                    QTimeEvt_postIn(&(I_USBApp.USBTimeOutEvt), AO_USB, BSP_TICKS_PER_SEC * 2);
./app/usb_test/usb_test_app.c:397:        QTimeEvt_disarm(&(I_USBApp.USBTimeOutEvt));
./app/usb_test/usb_test_app.c:398:        QTimeEvt_postIn(&(I_USBApp.USBTimeOutEvt), AO_USB, BSP_TICKS_PER_SEC * 4);
./app/usb_test/usb_test_app.c:470:        QTimeEvt_disarm(&(I_USBApp.USBTimeOutEvt));
Binary file ./app/usb_test/obj/arm/usb_test_app.o matches
Binary file ./app/timer/obj/arm/timer_ao.o matches
./app/timer/obj/arm/timer_ao.d:1:/home/feature_phone/crane/app/timer/obj/arm/timer_ao.o: \
./app/timer/obj/arm/timer_ao.d:2: /home/feature_phone/crane/app/timer/timer_ao.c \
./app/timer/obj/arm/timer_ao.d:3: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/timer/obj/arm/timer_ao.d:35: /home/feature_phone/crane/driver/timer/clock.h
./app/timer/timer_ao.c:1:#include "timer_dec.h"
./app/timer/timer_ao.c:6:typedef struct TimerAoTag{
./app/timer/timer_ao.c:8:}Timer;    
./app/timer/timer_ao.c:10:static QState Timer_initial(Timer *me, QEvent const *e);
./app/timer/timer_ao.c:11:static QState Timer_process(Timer *me, QEvent const *e);
./app/timer/timer_ao.c:13:static Timer l_timer;
./app/timer/timer_ao.c:14:QActive * const AO_Timer = (QActive *)&l_timer;
./app/timer/timer_ao.c:16:/* Timer Construction */
./app/timer/timer_ao.c:17:void Timer_ctor(void){
./app/timer/timer_ao.c:18:    Timer *me = &l_timer;
./app/timer/timer_ao.c:19:    QActive_ctor(&me->super, (QStateHandler)&Timer_initial);
./app/timer/timer_ao.c:22:QState Timer_initial(Timer *me, QEvent const *e){
./app/timer/timer_ao.c:25:    QS_OBJ_DICTIONARY(&l_timer);
./app/timer/timer_ao.c:27:    QS_FUN_DICTIONARY(&Timer_initial);
./app/timer/timer_ao.c:28:    QS_FUN_DICTIONARY(&Timer_process);
./app/timer/timer_ao.c:30:    QS_SIG_DICTIONARY(TIMER_FROM_COM_SIG, &l_timer);
./app/timer/timer_ao.c:31:    QS_SIG_DICTIONARY(TIMER_SIG, &l_timer);
./app/timer/timer_ao.c:35:    //QA_IRQ_CONNECT(IRQ_MMP_RTC_ALARM,  AO_Timer);
./app/timer/timer_ao.c:36:    //QA_IRQ_CONNECT(IRQ_MMP_WDT,        AO_Timer);
./app/timer/timer_ao.c:40:  	start_timer(5000, pmic_watchdog_timer_reset, 0);
./app/timer/timer_ao.c:42:    return Q_TRAN(&Timer_process);
./app/timer/timer_ao.c:45:QState Timer_process(Timer *me, QEvent const *e){
./app/timer/timer_ao.c:49:            timer_test(evt->argc, evt->argv);
./app/timer/timer_ao.c:60:            TimerIrqEvt *evt = (TimerIrqEvt*)e;
./app/timer/timer_ao.c:61:            timer_irq_func func = evt->func_p;
Binary file ./app/cli/obj/arm/cli_comp.o matches
Binary file ./app/cli/obj/arm/cli.o matches
./app/cli/cli.c:100:        {"timer", AO_Timer, TIMER_FROM_COM_SIG, "Timer test Command"},
./app/cli/cli.c:101:        {"rtc", AO_Timer, TIMER_RTC_SIG, "RTC test Command"},
./app/cli/cli.c:103:		{"genct", AO_Timer, TIMER_GEN_TEST_SIG, "Generic count test Command"},
./app/cli/cli.c:187:        {"cpbp",   AO_STRESS,  STRESS_CPBP_SIG, "Calc and print the biggest prime"},
./app/ipc/ipc_common.c:95:            me->nMin = nFree;                      /* update minimum so far */
Binary file ./app/ipc/obj/arm/ipc_common.o matches
Binary file ./app/ipc/obj/arm/ipc_app.o matches
./app/stress/sched_ao.c:14:#include "prime_test.h"
./app/stress/sched_ao.c:18:#include "timer_dec.h"
./app/stress/sched_ao.c:43:   uint32_t lastTime;
./app/stress/sched_ao.c:44:   uint32_t testTime;
./app/stress/sched_ao.c:47:   QTimeEvt testOver;
./app/stress/sched_ao.c:48:   QTimeEvt displayDelay; 
./app/stress/sched_ao.c:49:   QTimeEvt contEvt;
./app/stress/sched_ao.c:50:   QTimeEvt checkEvt;
./app/stress/sched_ao.c:92:   /* If no fail evt received before this timeEvt 
./app/stress/sched_ao.c:94:   QTimeEvt_ctor(&me->testOver,     STRESS_PASS_SIG);
./app/stress/sched_ao.c:95:   QTimeEvt_ctor(&me->displayDelay, STRESS_OVER_SIG);
./app/stress/sched_ao.c:96:   QTimeEvt_ctor(&me->contEvt,      STRESS_CONT_SIG);
./app/stress/sched_ao.c:97:   QTimeEvt_ctor(&me->checkEvt,     STRESS_CHECK_SIG);
./app/stress/sched_ao.c:105:   me->lastTime = STRESS_TEST_TIME;
./app/stress/sched_ao.c:106:   me->testTime = STRESS_TEST_TIME;
./app/stress/sched_ao.c:141:               bbu_printf(DBG_MSG "POST testOver TimeEvt\n\r");
./app/stress/sched_ao.c:142:               if(me->lastTime > UPPER_STEP_TIME){
./app/stress/sched_ao.c:143:                  QTimeEvt_postIn(&me->testOver, (QActive *)me,
./app/stress/sched_ao.c:145:                  me->lastTime -= UPPER_STEP_TIME;
./app/stress/sched_ao.c:147:                  QTimeEvt_postIn(&me->testOver, (QActive *)me,
./app/stress/sched_ao.c:148:                                me->lastTime*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:149:                  me->lastTime = 0;
./app/stress/sched_ao.c:151:               //print_current_time();
./app/stress/sched_ao.c:165:                  bbu_printf("Stress test will be terminated immediately\n\r");
./app/stress/sched_ao.c:176:                     uint32_t time = conv_dec((char *)cmdEvt->argv[1])*60;
./app/stress/sched_ao.c:177:                     if(time){
./app/stress/sched_ao.c:178:                        me->lastTime = time;
./app/stress/sched_ao.c:179:                        me->testTime = time;
./app/stress/sched_ao.c:198:                  uint32_t time = conv_dec((char *)cmdEvt->argv[2])*60;
./app/stress/sched_ao.c:199:                  if(time)
./app/stress/sched_ao.c:200:                     me->lastTime = time;
./app/stress/sched_ao.c:222:                        uint32_t time = conv_dec((char *)cmdEvt->argv[2])*60;
./app/stress/sched_ao.c:223:                        if(time){
./app/stress/sched_ao.c:224:                           me->lastTime = time;
./app/stress/sched_ao.c:225:                           me->testTime = time;
./app/stress/sched_ao.c:242:                  uint32_t time = conv_dec((char *)cmdEvt->argv[3])*60;
./app/stress/sched_ao.c:243:                  if(time)
./app/stress/sched_ao.c:244:                     me->lastTime  = time;
./app/stress/sched_ao.c:308:         QTimeEvt_disarm(&me->contEvt);
./app/stress/sched_ao.c:318:                  cmd_len = bbu_sprintf(cmdstr, "stress cw %d", me->testTime/60);
./app/stress/sched_ao.c:345:                  QTimeEvt_postEvery(&me->checkEvt, (QActive *)me,
./app/stress/sched_ao.c:351:               QTimeEvt_postIn(&me->contEvt, (QActive *)me,
./app/stress/sched_ao.c:358:         if(me->lastTime == 0){
./app/stress/sched_ao.c:369:               QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:373:            if(me->lastTime > UPPER_STEP_TIME){
./app/stress/sched_ao.c:374:               QTimeEvt_postIn(&me->testOver, (QActive *)me,
./app/stress/sched_ao.c:376:               me->lastTime -= UPPER_STEP_TIME;
./app/stress/sched_ao.c:378:               QTimeEvt_postIn(&me->testOver, (QActive *)me,
./app/stress/sched_ao.c:379:                             me->lastTime*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:380:               me->lastTime = 0;
./app/stress/sched_ao.c:395:            QTimeEvt_postIn(&me->displayDelay, (QActive *)me,  3*200);
./app/stress/sched_ao.c:409:               bbu_printf("Stress test will be terminated immediately\n\r");
./app/stress/sched_ao.c:472:          QTimeEvt_disarm(&me->displayDelay);
./app/stress/sched_ao.c:473:          QTimeEvt_disarm(&me->testOver);
./app/stress/sched_ao.c:474:          QTimeEvt_disarm(&me->checkEvt);
./app/stress/sched_ao.c:499:         QTimeEvt_disarm(&me->displayDelay);
./app/stress/sched_ao.c:500:         QTimeEvt_disarm(&me->testOver);
./app/stress/sched_ao.c:501:         QTimeEvt_disarm(&me->checkEvt);
./app/stress/sched_ao.c:526:            QTimeEvt_postIn(&me->displayDelay,(QActive *)me,10*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:531:         QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:535:         QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:540:         QTimeEvt_disarm(&me->displayDelay);
./app/stress/sched_ao.c:541:         QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:566:            QTimeEvt_postIn(&me->displayDelay,(QActive *)me,10*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:571:         QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:575:         QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:580:         QTimeEvt_disarm(&me->displayDelay);
./app/stress/sched_ao.c:581:         QTimeEvt_postIn(&me->displayDelay,(QActive *)me,3*BSP_TICKS_PER_SEC);
./app/stress/sched_ao.c:596:             (l_sched.lastTime/60));
./app/stress/sched_ao.c:675:   if(!me->autoRun){ /* In autoRun, don't need to reset the last_time */
./app/stress/sched_ao.c:676:      me->lastTime = STRESS_TEST_TIME;
./app/stress/sched_ao.c:677:      me->testTime = STRESS_TEST_TIME;
./app/stress/Rules.mk:5:SUBDIRS := prime
./app/stress/obj/arm/sched_ao.d:32: /home/feature_phone/crane/app/stress/prime/prime_test.h \
./app/stress/obj/arm/sched_ao.d:34: /home/feature_phone/crane/driver/timer/clock.h \
./app/stress/obj/arm/sched_ao.d:35: /home/feature_phone/crane/driver/timer/timer_dec.h \
./app/stress/obj/arm/sched_ao.d:38: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/stress/obj/arm/sched_ao.o matches
./app/stress/obj/arm/stress_ao.d:32: /home/feature_phone/crane/app/stress/prime/prime_test.h \
Binary file ./app/stress/obj/arm/stress_ao.o matches
./app/stress/stress_ao.c:14:#include "prime_test.h"
./app/stress/stress_ao.c:111:            calc_print_biggest_prime();
./app/stress/prime/lucdwt.c:5: *	Mersenne primality tester prototype source code.
./app/stress/prime/lucdwt.c:164:	 * This is a decimation-in-time, split-radix algorithm.
./app/stress/prime/lucdwt.c:287:	 * This is a decimation-in-frequency, split-radix algorithm.
./app/stress/prime/lucdwt.c:420:		b[n-k] = 2.0*c*d;   //im
./app/stress/prime/lucdwt.c:572:	 double 	hi = high, lo = low, highliminv, lowliminv;
./app/stress/prime/lucdwt.c:574:	double  			highlim,lowlim, lim, inv, base;
./app/stress/prime/lucdwt.c:577:	highlim = hi*0.5;
./app/stress/prime/lucdwt.c:578:	lowlim = lo*0.5;
./app/stress/prime/lucdwt.c:579:	highliminv =1.0/highlim;
./app/stress/prime/lucdwt.c:580:	lowliminv = 1.0/lowlim;
./app/stress/prime/lucdwt.c:583:	if (xx >= highlim)
./app/stress/prime/lucdwt.c:584:		carry =((int)(xx*highliminv+1))>>1;
./app/stress/prime/lucdwt.c:585:	else if (xx<-highlim)
./app/stress/prime/lucdwt.c:586:		carry = -(((int)(1-xx*highliminv))>>1);
./app/stress/prime/lucdwt.c:597:			if (xx >= highlim)
./app/stress/prime/lucdwt.c:598:				carry =((int)(xx*highliminv+1))>>1;
./app/stress/prime/lucdwt.c:599:			else if (xx<-highlim)
./app/stress/prime/lucdwt.c:600:				carry = -(((int)(1-xx*highliminv))>>1);
./app/stress/prime/lucdwt.c:608:			if (xx >= lowlim)
./app/stress/prime/lucdwt.c:609:				carry =((int)(xx*lowliminv+1))>>1;
./app/stress/prime/lucdwt.c:610:			else if (xx<-lowlim)
./app/stress/prime/lucdwt.c:611:				carry = -(((int)(1-xx*lowliminv))>>1);
./app/stress/prime/lucdwt.c:622:	if (xx >= lowlim)
./app/stress/prime/lucdwt.c:623:		carry = ((int)(xx*lowliminv+1))>>1;
./app/stress/prime/lucdwt.c:624:	else if (xx<-lowlim)
./app/stress/prime/lucdwt.c:625:		carry = -(((int)(1-xx*lowliminv))>>1);
./app/stress/prime/lucdwt.c:640:				lim = highlim;
./app/stress/prime/lucdwt.c:641:				inv = highliminv;
./app/stress/prime/lucdwt.c:646:				lim = lowlim;
./app/stress/prime/lucdwt.c:647:				inv = lowliminv;
./app/stress/prime/lucdwt.c:652:				lim = highlim;
./app/stress/prime/lucdwt.c:653:				inv = highliminv;
./app/stress/prime/lucdwt.c:658:				lim = lowlim;
./app/stress/prime/lucdwt.c:659:				inv = lowliminv;
./app/stress/prime/lucdwt.c:663:			if (xx>=lim)
./app/stress/prime/lucdwt.c:665:			else if (xx<-lim)
./app/stress/prime/lucdwt.c:690:	double 	limit, hilim,lolim,*ptrx = x;
./app/stress/prime/lucdwt.c:692:	hilim = high*0.5;
./app/stress/prime/lucdwt.c:693:	lolim = low*0.5;
./app/stress/prime/lucdwt.c:697:			limit = hilim;
./app/stress/prime/lucdwt.c:699:			limit = lolim;
./app/stress/prime/lucdwt.c:701:			limit = hilim;
./app/stress/prime/lucdwt.c:703:			limit = lolim;
./app/stress/prime/lucdwt.c:705:		assert ((*ptrx<=limit) && (*ptrx>=-limit));
./app/stress/prime/lucdwt.c:849:	bbu_printf("   err = 1 to report maximum errors\n\r");
./app/stress/prime/lucdwt.c:851:	bbu_printf("Note: If the final result is 0, then 2^q-1 is a Mersenne prime\n\r");
./app/stress/prime/prime_print.c:34:void calc_print_biggest_prime(void)
./app/stress/prime/prime_print.c:37:              "Mersenne prime ***************\n\r");
./app/stress/prime/prime_print.c:40:   print_current_time();
./app/stress/prime/prime_print.c:65:             "Mersenne prime **************\n\r");
./app/stress/prime/prime_print.c:66:   print_current_time();
./app/stress/prime/prime_print.c:71:   print_current_time();
./app/stress/prime/obj/arm/lucdwt.d:1:/home/feature_phone/crane/app/stress/prime/obj/arm/lucdwt.o: \
./app/stress/prime/obj/arm/lucdwt.d:2: /home/feature_phone/crane/app/stress/prime/lucdwt.c \
Binary file ./app/stress/prime/obj/arm/lucdwt.o matches
./app/stress/prime/obj/arm/prime_print.d:1:/home/feature_phone/crane/app/stress/prime/obj/arm/prime_print.o: \
./app/stress/prime/obj/arm/prime_print.d:2: /home/feature_phone/crane/app/stress/prime/prime_print.c \
./app/stress/prime/obj/arm/prime_print.d:26: /home/feature_phone/crane/driver/timer/clock.h \
Binary file ./app/stress/prime/obj/arm/prime_print.o matches
./app/stress/prime/prime_test.h:6:extern void calc_print_biggest_prime(void);
Binary file ./app/console/obj/arm/console.o matches
./app/i2c/i2c_comp.h:44:extern void disarm_i2c_time_evt(void);
Binary file ./app/i2c/obj/arm/i2c_ao.o matches
Binary file ./app/i2c/obj/arm/i2c_comp.o matches
./app/i2c/i2c_comp.c:62:            disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:93:         disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:126:         disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:187:         disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:291:            bbu_printf("ri2c--> I2C bus time out. No device at address"
./app/i2c/i2c_comp.c:363:            bbu_printf("wi2c--> I2C bus time out. No device at address "
./app/i2c/i2c_comp.c:453:         disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:459:         disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:465:         disarm_i2c_time_evt();
./app/i2c/i2c_comp.c:471:         disarm_i2c_time_evt();
./app/i2c/i2c_ao.c:24:   QTimeEvt  time_out;
./app/i2c/i2c_ao.c:54:   QTimeEvt_ctor(&me->time_out,     I2C_TIMEOUT_SIG);
./app/i2c/i2c_ao.c:130:                     QTimeEvt_postIn(&me->time_out, (QActive *)me, BSP_TICKS_PER_SEC);
./app/i2c/i2c_ao.c:141:                     QTimeEvt_postIn(&me->time_out, (QActive *)me, BSP_TICKS_PER_SEC);
./app/i2c/i2c_ao.c:168:               QTimeEvt_postIn(&me->time_out, (QActive *)me,
./app/i2c/i2c_ao.c:234:                        QTimeEvt_postIn(&me->time_out, (QActive *)me, BSP_TICKS_PER_SEC);
./app/i2c/i2c_ao.c:247:                     QTimeEvt_postIn(&me->time_out, (QActive *)me, BSP_TICKS_PER_SEC);
./app/i2c/i2c_ao.c:285:                     QTimeEvt_postIn(&me->time_out, (QActive *)me, BSP_TICKS_PER_SEC);
./app/i2c/i2c_ao.c:297:                     QTimeEvt_postIn(&me->time_out, (QActive *)me, BSP_TICKS_PER_SEC);
./app/i2c/i2c_ao.c:365:         bbu_printf("I2C time out %d\n\r", me->i2c_index);
./app/i2c/i2c_ao.c:366:         QTimeEvt_disarm(&me->time_out);
./app/i2c/i2c_ao.c:466:void disarm_i2c_time_evt(void){
./app/i2c/i2c_ao.c:467:   QTimeEvt_disarm(&(l_i2c.time_out));
./final.mk:1:# Just a simple example how final.mk can be used for 'install' targets
Binary file ./.git/objects/99/27aba8ad3cd140328b9ebe4e8ec5fa340352be matches
Binary file ./.git/objects/pack/pack-488a8f4d8b85777a9bcb9f17e6ff7d4dad25fac0.pack matches
./.git/hooks/pre-rebase.sample:105:   it makes it easier to keep your history simple.
./.git/hooks/pre-rebase.sample:124:    Then you can delete it.  More importantly, you should not
Binary file ./.git/index matches
